open HolKernel Parse boolLib bossLib;
open chap1Theory;
open pred_setTheory;
open relationTheory;
open arithmeticTheory;
open set_relationTheory;

open chap2_1Theory;
open chap2_2Theory;
open IBCDNFTheory;
open equiv_on_partitionTheory;
open IBCDNFrevisedTheory;


(* open chap2_3Theory; *)

val _ = ParseExtras.tight_equality()

val _ = new_theory "chap2_3";

(* finite model property via selection *)


val DEG_def =
  Define
    `DEG (VAR p) = 0 /\
     DEG (FALSE) = 0 /\
     DEG (NOT form) = DEG form /\
     DEG (DISJ form1 form2) = MAX (DEG form1) (DEG form2) /\
     DEG (DIAM form) = (DEG form) + 1`;


val DEG_0_propform = store_thm(
"DEG_0_propform",
``!f. DEG f = 0 <=> propform f``,
Induct_on `f` >> fs[DEG_def,propform_def]);


(* base case *)

val subforms_def = Define`
  subforms (VAR a) = {VAR a} /\
  subforms (FALSE) = {FALSE} /\
  subforms (NOT f) = NOT f INSERT subforms f /\
  subforms (DISJ f1 f2) = DISJ f1 f2 INSERT subforms f1 UNION subforms f2 /\
  subforms (DIAM f) = DIAM f INSERT subforms f
  `;

val subforms_phi_phi = store_thm(
"subforms_phi_phi",
``!phi. phi IN subforms phi``,
Induct_on `phi` >> fs[subforms_def]);

val subforms_DISJ = store_thm(
"subforms_DISJ",
``f1 IN (subforms (DISJ f1 f2)) /\ f2 IN (subforms (DISJ f1 f2))``,
rw[subforms_def,subforms_phi_phi]);

val subforms_NOT = store_thm(
"subforms_NOT",
``f IN (subforms (NOT f))``,
rw[subforms_def,subforms_phi_phi]);

val subforms_DIAM = store_thm(
"subforms_DIAM",
``f IN (subforms (DIAM f))``,
rw[subforms_def,subforms_phi_phi]);

val subforms_trans = store_thm(
"subforms_trans",
``!f. f IN subforms phi /\ phi IN subforms psi ==> f IN subforms psi``,
rw[] >> Induct_on `psi` >> rw[] >> fs[subforms_def] 
>> fs[subforms_def]);

val subforms_FINITE = store_thm(
"subforms_FINITE",
``FINITE (subforms phi)``,
Induct_on `phi` >> fs[subforms_def]);

val peval_satis_strengthen = store_thm(
"peval_satis_strengthen",
``!M w f. propform f /\ (âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s) /\ w IN M.frame.world ==> (satis M w f <=> peval ((Î»a. w IN M.valt a) INTER s) f)``,
Induct_on `f` >> rw[]
>- (`(VAR a) IN subforms (VAR a)` by fs[subforms_def] >>
   `a IN s` by fs[] >> metis_tac[satis_def])
>- (simp[satis_def] >> 
   `(âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s)`
          by (`âˆ€a. VAR a âˆˆ subforms f â‡’ (VAR a) IN subforms (DISJ f f')` suffices_by metis_tac[] >>
	      `f IN (subforms (DISJ f f'))` by fs[subforms_def,subforms_phi_phi] >>
	      metis_tac[subforms_trans]) >>
   `(âˆ€a. VAR a âˆˆ subforms f' â‡’ a âˆˆ s)`
          by (`âˆ€a. VAR a âˆˆ subforms f' â‡’ (VAR a) IN subforms (DISJ f f')` suffices_by metis_tac[] >>
	      `f' IN (subforms (DISJ f f'))` by fs[subforms_def,subforms_phi_phi] >>
	      metis_tac[subforms_trans]) >> metis_tac[])
>- metis_tac[satis_def]
>- (simp[satis_def] >>
   `(âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s)`
          by (`âˆ€a. VAR a âˆˆ subforms f â‡’ (VAR a) IN subforms (Â¬f)` suffices_by metis_tac[] >>
	      `f IN (subforms (Â¬f))` by fs[subforms_def,subforms_phi_phi] >>
	      metis_tac[subforms_trans]) >> metis_tac[]));


val equiv0_peval_strengthen = store_thm(
"equiv0_peval_strengthen",
``!f1 f2. propform f1 /\ propform f2 /\
(âˆ€a. VAR a âˆˆ subforms f1 â‡’ a âˆˆ s) /\
(âˆ€a. VAR a âˆˆ subforms f2 â‡’ a âˆˆ s) ==>
(!Ïƒ. Ïƒ IN (POW s) ==> peval Ïƒ f1 = peval Ïƒ f2) ==> (!M w. satis M w f1 <=> satis M w f2)``,
rw[] >> eq_tac >> rw[] >> `w IN M.frame.world` by metis_tac[satis_in_world]
>- (`peval ((Î»a. w IN M.valt a) INTER s) f2` suffices_by metis_tac[peval_satis_strengthen,satis_in_world] >>
   `peval ((Î»a. w IN M.valt a) INTER s) f1` by metis_tac[peval_satis_strengthen] >>
   `((Î»a. w IN M.valt a) INTER s) IN (POW s)` by fs[POW_DEF,INTER_DEF,SUBSET_DEF] >>
   metis_tac[])
>- (`peval ((Î»a. w IN M.valt a) INTER s) f1` suffices_by metis_tac[peval_satis_strengthen,satis_in_world] >>
   `peval ((Î»a. w IN M.valt a) INTER s) f2` by metis_tac[peval_satis_strengthen] >>
   `((Î»a. w IN M.valt a) INTER s) IN (POW s)` by fs[POW_DEF,INTER_DEF,SUBSET_DEF] >>
   metis_tac[]));



val peval_restriction = store_thm(
  "peval_restriction",
  ``!f. propform f ==> (âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s) ==> !Ïƒ. peval Ïƒ f = peval (Ïƒ INTER s) f``,
  Induct_on `f` 
  >- (rw[] >>
     `(VAR a) âˆˆ subforms (VAR a)`  by fs[subforms_def] >>
     `a IN s` by fs[] >> fs[IN_DEF])
  >- (rw[] >>
     `(âˆ€a. VAR a âˆˆ subforms f' â‡’ a âˆˆ s)`
         by (`âˆ€a. VAR a âˆˆ subforms f' â‡’ (VAR a) IN subforms (DISJ f f')` suffices_by metis_tac[] >>
	      `f' IN (subforms (DISJ f f'))` by fs[subforms_def,subforms_phi_phi] >>
	      metis_tac[subforms_trans]) >>
     `(âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s)`
         by (`âˆ€a. VAR a âˆˆ subforms f â‡’ (VAR a) IN subforms (DISJ f f')` suffices_by metis_tac[] >>
	      `f IN (subforms (DISJ f f'))` by fs[subforms_def,subforms_phi_phi] >>
	      metis_tac[subforms_trans]) >>
     metis_tac[])
  >- fs[peval_def]
  >- (rw[] >>
   `(âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s)`
       by (`âˆ€a. VAR a âˆˆ subforms f â‡’ (VAR a) IN subforms (Â¬f)` suffices_by metis_tac[] >>
	      `f IN (subforms (Â¬f))` by fs[subforms_def,subforms_phi_phi] >>
	      metis_tac[subforms_trans]) >> metis_tac[])
  >- fs[propform_def]);


val peval_satis = store_thm(
"peval_satis",
``!M w f. propform f /\ w IN M.frame.world ==> (satis M w f <=> peval (Î»a. w IN M.valt a) f)``,
Induct_on `f` >> rw[] 
>> metis_tac[satis_def]);

val peval_equiv0 = store_thm(
"peval_equiv0",
``!f1 f2. propform f1 /\ propform f2 /\ (!M w. satis M w f1 <=> satis M w f2) ==> (!Ïƒ. peval Ïƒ f1 = peval Ïƒ f2)``,
gen_tac >> gen_tac >> strip_tac >> SPOSE_NOT_THEN ASSUME_TAC >>
`?Ïƒ. (peval Ïƒ f1 /\ Â¬(peval Ïƒ f2)) \/ (Â¬(peval Ïƒ f1) /\ peval Ïƒ f2)` by metis_tac[] 
>- (`?M w. satis M w f1 /\ Â¬satis M w f2` suffices_by metis_tac[] >>
    `(univ(:'b)) <> {}` by metis_tac[UNIV_NOT_EMPTY] >>
    `?b. b IN univ(:'b)` by metis_tac[MEMBER_NOT_EMPTY] >>
   qexists_tac `<| frame := <| world := {b};
                           rel := Î»n1 n2. (n1 = b /\ n2 = b) |>;
                   valt := Î»a w. (Ïƒ a) |>` >>
   qabbrev_tac `M = <| frame := <| world := {b};
                           rel := Î»n1 n2. (n1 = b /\ n2 = b) |>;
                   valt := Î»a w. (Ïƒ a) |>` >>
   qexists_tac `b` >> rw[]
   >- (`satis M b f1` suffices_by metis_tac[] >>
      `b IN M.frame.world` by fs[Abbr`M`] >>
      `peval (Î»a. b âˆˆ M.valt a) f1` suffices_by metis_tac[peval_satis] >>
      rw[IN_DEF,Abbr`M`] >> `(Î»a. Ïƒ a) = Ïƒ` by rw[FUN_EQ_THM] >> fs[])
   >- (`b IN M.frame.world` by fs[Abbr`M`] >>
      `Â¬(peval (Î»a. b âˆˆ M.valt a) f2)` suffices_by metis_tac[peval_satis] >>
      rw[IN_DEF,Abbr`M`] >> `(Î»a. Ïƒ a) = Ïƒ` by rw[FUN_EQ_THM] >> fs[]))
>- (`?M w. Â¬satis M w f1 /\ satis M w f2` suffices_by metis_tac[] >>
   qexists_tac `<| frame := <| world := {b};
                           rel := Î»n1 n2. (n1 = b /\ n2 = b) |>;
                   valt := Î»a w. (Ïƒ a) |>` >>
   qabbrev_tac `M = <| frame := <| world := {b};
                           rel := Î»n1 n2. (n1 = b /\ n2 = b) |>;
                   valt := Î»a w. (Ïƒ a) |>` >>
   qexists_tac `b` >> rw[]
   >- (`Â¬satis M b f1` suffices_by metis_tac[] >>
      `b IN M.frame.world` by fs[Abbr`M`] >>
      `Â¬peval (Î»a. b âˆˆ M.valt a) f1` suffices_by metis_tac[peval_satis] >>
      rw[IN_DEF,Abbr`M`] >> `(Î»a. Ïƒ a) = Ïƒ` by rw[FUN_EQ_THM] >> fs[])
   >- (`b IN M.frame.world` by fs[Abbr`M`] >>
      `(peval (Î»a. b âˆˆ M.valt a) f2)` suffices_by metis_tac[peval_satis] >>
      rw[IN_DEF,Abbr`M`] >> `(Î»a. Ïƒ a) = Ïƒ` by rw[FUN_EQ_THM] >> fs[])));

val partition_to_peval_well_defined = store_thm(
"partition_to_peval_well_defined",
``!f1 f2. (propform f1 /\ propform f2 /\ equiv0 Î¼ f1 f2) ==> ((Î»f s. peval s f) f1) = ((Î»f s. peval s f) f2)``,
rw[equiv0_def] >> simp[FUN_EQ_THM] >> metis_tac[peval_equiv0]);



val IMAGE_peval_singlton_strengthen = store_thm(
"IMAGE_peval_singlton_strengthen",
``!x form. x IN {f | propform f /\ âˆ€a. (VAR a) IN (subforms f) â‡’ a âˆˆ s}//e /\ form IN x ==>
IMAGE (Î»f. {Ïƒ | peval Ïƒ f} âˆ© POW s) x = {{Ïƒ | (peval Ïƒ form)} INTER (POW s)}``,
rw[partition_def] >> rw[IMAGE_DEF] >>
`!f. propform f /\ (equiv0 Î¼ x' f) ==> ((Î»s. peval s f) = (Î»s. peval s form))` by
(rw[] >> fs[] >> `equiv0 Î¼ f form` by metis_tac[equiv0_def] >> simp[FUN_EQ_THM] >> metis_tac[partition_to_peval_well_defined]) >>
simp[Once EXTENSION] >> rw[] >> eq_tac >> rw[]
>- fs[EXTENSION]
>- (qexists_tac `form` >> fs[EXTENSION]));

val INTER_EQ = store_thm(
  "INTER_EQ",
  ``!a b c. a âˆ© c = b âˆ© c ==>
  (!x. x IN c ==> (x IN a <=> x IN b))``,
  rw[EQ_IMP_THM]
  >- (`x IN (a âˆ© c)` by fs[INTER_DEF] >>
     `x IN (b âˆ© c)` by (fs[EXTENSION] >> metis_tac[]) >>
     `x IN b` by fs[INTER_DEF])
  >- (`x IN (b âˆ© c)` by fs[INTER_DEF] >>
     `x IN (a âˆ© c)` by (fs[EXTENSION] >> metis_tac[]) >>
     fs[INTER_DEF]));

val INJ_peval_partition_strengthen = store_thm(
  "INJ_peval_partition_strengthen",
  ``INJ
  (\eqc. ((IMAGE (Î»f. {s| peval s f} INTER (POW s)) eqc)))
  {f | propform f /\ âˆ€a. (VAR a) IN (subforms f) â‡’ a âˆˆ s}//e
  (POW (POW (POW s)))``, 
  rw[INJ_DEF] >> fs[partition_def] >> simp[EXTENSION] >> fs[]
  >- (rw[IMAGE_DEF] >> fs[POW_DEF,SUBSET_DEF] >> rw[] >> fs[INTER_DEF])
  >- (rw[EQ_IMP_THM] >>
      `equiv0 Î¼ x x'` suffices_by metis_tac[equiv0_SYM,equiv0_TRANS] >>
        `{y |
              (propform y âˆ§ âˆ€a. VAR a âˆˆ subforms y â‡’ a âˆˆ s) âˆ§
              equiv0 Î¼ x y} IN
         {f | propform f /\ âˆ€a. (VAR a) IN (subforms f) â‡’ a âˆˆ s}//e`
            by (rw[partition_def] >> qexists_tac `x` >> rw[]) >>
	`x IN {y |
         (propform y âˆ§ âˆ€a. VAR a âˆˆ subforms y â‡’ a âˆˆ s) âˆ§ equiv0 Î¼ x y}` by fs[equiv0_REFL] >>
	`{y |
              (propform y âˆ§ âˆ€a. VAR a âˆˆ subforms y â‡’ a âˆˆ s) âˆ§
              equiv0 Î¼ x' y} IN
         {f | propform f /\ âˆ€a. (VAR a) IN (subforms f) â‡’ a âˆˆ s}//e`
            by (rw[partition_def] >> qexists_tac `x'` >> rw[]) >>
	`x' IN {y |
         (propform y âˆ§ âˆ€a. VAR a âˆˆ subforms y â‡’ a âˆˆ s) âˆ§ equiv0 Î¼ x' y}` by fs[equiv0_REFL] >>
        `IMAGE (Î»f. {Ïƒ | peval Ïƒ f} âˆ© POW s) {y | (propform y âˆ§ âˆ€a. VAR a âˆˆ subforms y â‡’ a âˆˆ s) âˆ§ equiv0 Î¼ x y} =
     {{Ïƒ | peval Ïƒ x} âˆ© POW s}` by metis_tac[IMAGE_peval_singlton_strengthen] >>
        `IMAGE (Î»f. {Ïƒ | peval Ïƒ f} âˆ© POW s) {y | (propform y âˆ§ âˆ€a. VAR a âˆˆ subforms y â‡’ a âˆˆ s) âˆ§ equiv0 Î¼ x' y} =
     {{Ïƒ | peval Ïƒ x'} âˆ© POW s}` by metis_tac[IMAGE_peval_singlton_strengthen] >> fs[] >>
        `!Ïƒ. Ïƒ IN (POW s) ==> (Ïƒ IN {s | peval s x} <=> Ïƒ IN {s | peval s x'})` by metis_tac[INTER_EQ] >> fs[] >> rw[equiv0_def] >>
	irule equiv0_peval_strengthen >- (qexists_tac `s` >> rw[])
	                             >> rw[] >> qexists_tac `s` >> rw[]));




val DEG_IBC_strengthen = store_thm(
  "DEG_IBC_strengthen",
  ``âˆ€x.
   DEG x â‰¤ n + 1 âˆ§ (âˆ€a. (VAR a) IN subforms x â‡’ a âˆˆ s) â‡”
   IBC x
     ({VAR v | v âˆˆ s} âˆª
      {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. (VAR a) IN subforms psi â‡’ a âˆˆ s})``,
Induct_on `x` >> rw[DEG_def]
>- (simp[SimpRHS,Once IBC_cases] >> rw[subforms_def])
>- (`IBC (DISJ x x')
  ({VAR v | v âˆˆ s} âˆª
   {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s}) ==>
   IBC x 
  ({VAR v | v âˆˆ s} âˆª
   {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s})`
       by rw[Once IBC_cases] >>
   `(âˆ€a. VAR a âˆˆ subforms (DISJ x x') â‡’ a âˆˆ s) ==>
   (âˆ€a. VAR a âˆˆ subforms x â‡’ a âˆˆ s)` by rw[subforms_def] >>
   `IBC (DISJ x x')
  ({VAR v | v âˆˆ s} âˆª
   {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s}) ==>
   IBC x' 
  ({VAR v | v âˆˆ s} âˆª
   {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s})`
       by rw[Once IBC_cases] >>
   `(âˆ€a. VAR a âˆˆ subforms (DISJ x x') â‡’ a âˆˆ s) ==>
   (âˆ€a. VAR a âˆˆ subforms x' â‡’ a âˆˆ s)` by rw[subforms_def] >>
   rw[EQ_IMP_THM]
   >- metis_tac[IBC_cases]
   >- metis_tac[IBC_cases]
   >- metis_tac[IBC_cases]
   >- (`(âˆ€a. VAR a âˆˆ subforms x' â‡’ a âˆˆ s)` by metis_tac[] >>
      `(âˆ€a. VAR a âˆˆ subforms x â‡’ a âˆˆ s)` by metis_tac[] >>
      fs[subforms_def]))
>- fs[subforms_def,Once IBC_cases]
>- (`IBC (Â¬x)
  ({VAR v | v âˆˆ s} âˆª
   {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s}) ==>
   IBC x 
  ({VAR v | v âˆˆ s} âˆª
   {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s})`
       by rw[Once IBC_cases] >>
   `(âˆ€a. VAR a âˆˆ subforms (Â¬x) â‡’ a âˆˆ s) ==>
   (âˆ€a. VAR a âˆˆ subforms x â‡’ a âˆˆ s)` by rw[subforms_def] >>
   rw[EQ_IMP_THM]
   >- metis_tac[IBC_cases]
   >- metis_tac[IBC_cases]
   >- fs[subforms_def])
>- fs[Once IBC_cases,subforms_def]);


val IBC_EMPTY_lemma = prove(
  ``âˆ€f s. IBC f s ==> s = {} ==> equiv0 Î¼ f TRUE \/ equiv0 Î¼ f FALSE``,
  Induct_on `IBC` >> rw[] >> fs[equiv0_def,satis_def,TRUE_def]);


val FINITE_DNF = store_thm(
    "FINITE_DNF",
    ``!fs. FINITE fs ==> FINITE {f | DNF_OF f fs}``,
    rw[DNF_OF_def,DISJ_OF_def] >>
    `FINITE {c | CONJ_OF c fs}` by metis_tac[FINITE_CONJ_OF] >>
    `FINITE  {f | DISJ_OF0 f {c | CONJ_OF c fs}}` by metis_tac[FINITE_DISJ_OF0] >>
    `FINITE (FALSE INSERT {f | DISJ_OF0 f {c | CONJ_OF c fs}})` by metis_tac[FINITE_INSERT] >>
    `{f | f = âŠ¥ âˆ¨ DISJ_OF0 f {c | CONJ_OF c fs}} = (FALSE INSERT {f | DISJ_OF0 f {c | CONJ_OF c fs}})` by
    simp[EXTENSION,INSERT_DEF] >> fs[]);
    

val IBC_FINITE = store_thm(
  "IBC_FINITE",
  ``!fs. FINITE fs ==> FINITE (partition (equiv0 Î¼) {f | IBC f fs})``,
  rw[] >> Cases_on `fs = {}`
  >- (fs[partition_def] >>
     `{t | âˆƒx. IBC x âˆ… âˆ§ t = {y | IBC y âˆ… âˆ§ equiv0 Î¼ x y}} = {{y | IBC y âˆ… âˆ§ equiv0 Î¼ TRUE y};{y | IBC y âˆ… âˆ§ equiv0 Î¼ FALSE y}}` by (fs[EXTENSION] >> rw[] >> eq_tac >> rw[]
     >- (`equiv0 Î¼ x' TRUE \/ equiv0 Î¼ x' FALSE` by metis_tac[IBC_EMPTY_lemma]
        >> fs[equiv0_def,satis_def,TRUE_def])
     >- (qexists_tac `TRUE` >> rw[] >> rw[Once IBC_cases,TRUE_def] >> metis_tac[IBC_cases])
     >- (qexists_tac `FALSE` >> rw[] >> rw[Once IBC_cases,TRUE_def])) >>
     fs[]) >>
  qabbrev_tac `ff = \s.{d | DNF_OF d fs /\ (!f. f IN s ==> equiv0 Î¼ d f)}` >>
  `FINITE {f | DNF_OF f fs}` by metis_tac[FINITE_DNF] >>
  `INJ ff ({f | IBC f fs}//e) (POW {f | DNF_OF f fs})` suffices_by metis_tac[FINITE_POW,FINITE_INJ] >> 
  simp[INJ_DEF,IN_POW] >> rw[]
  >- simp[Abbr`ff`,SUBSET_DEF] >>
  SPOSE_NOT_THEN ASSUME_TAC >>
  `DISJOINT x y` by metis_tac[partition_elements_disjoint,equiv0_equiv_on]>>
  `(âˆ€f1 f2. f1 âˆˆ x /\ f2 âˆˆ x ==> equiv0 Î¼ f1 f2) /\
   (âˆ€f1 f2. f1 âˆˆ y /\ f2 âˆˆ y ==> equiv0 Î¼ f1 f2)`
     by metis_tac [partition_elements_interrelate,equiv0_equiv_on] >>
  fs[Abbr`ff`] >>
  `(equiv0 Î¼) equiv_on {f | IBC f fs}` by metis_tac[equiv0_equiv_on] >>
  `âˆ€f1 f2. f1 âˆˆ x /\ f2 âˆˆ y ==> Â¬equiv0 Î¼ f1 f2` by metis_tac[equiv_on_partition_NOT_R] >>
  qpat_x_assum `GSPEC _ = GSPEC _` mp_tac >> simp[EXTENSION] >>
  `x <> {}` by metis_tac[EMPTY_NOT_IN_partition,equiv0_equiv_on] >>
  `?fx. fx IN x` by metis_tac[MEMBER_NOT_EMPTY] >>
  `x âŠ† {f | IBC f fs}` by metis_tac[partition_SUBSET] >>
  `IBC fx fs` by (fs[SUBSET_DEF] >> metis_tac[]) >>
  `âˆƒd. DNF_OF d fs /\ equiv0 Î¼ fx d` by metis_tac[IBC_DNF_EXISTS] >>
  qexists_tac`d` >> simp[] >>
  `âˆ€f. f âˆˆ x ==> equiv0 Î¼ d f` by metis_tac[equiv0_SYM, equiv0_TRANS] >> simp[]>>
  `y <> {}` by metis_tac[EMPTY_NOT_IN_partition,equiv0_equiv_on] >>
  `âˆƒfy. fy âˆˆ y` by metis_tac[MEMBER_NOT_EMPTY] >>
  qexists_tac `fy` >> simp[] >> metis_tac[equiv0_SYM, equiv0_TRANS]);


val IBC_partition_equiv0 = store_thm(
  "IBC_partition_equiv0", 
  ``!f fs. IBC f fs ==> fs <> {} ==>
         ?p. IBC p (IMAGE CHOICE (partition (equiv0 Î¼) fs)) /\ equiv0 Î¼ f p``,
Induct_on `IBC` >> rw[]
>- (`âˆƒp. IBC p (IMAGE CHOICE fs//e) âˆ§ equiv0 Î¼ f p /\
   âˆƒp'. IBC p' (IMAGE CHOICE fs//e) âˆ§ equiv0 Î¼ f' p'` by metis_tac[] >>
   qexists_tac `DISJ p p'` >> rw[]
   >- metis_tac[IBC_cases]
   >- fs[equiv0_def,satis_def])
>- (qexists_tac `FALSE` >> rw[Once IBC_cases])
>- (`âˆƒp. IBC p (IMAGE CHOICE fs//e) âˆ§ equiv0 Î¼ f p` by metis_tac[] >>
   qexists_tac `Â¬p` >> rw[Once IBC_cases] >> fs[equiv0_def,satis_def])
>- (fs[partition_def] >>
   qexists_tac `CHOICE {y | y IN fs /\ equiv0 Î¼ f y}` >> rw[]
   >- (`(CHOICE {y | y âˆˆ fs âˆ§ equiv0 Î¼ f y}) IN (IMAGE CHOICE {t | âˆƒx. x âˆˆ fs âˆ§ t = {y | y âˆˆ fs âˆ§ equiv0 Î¼ x y}})` by (fs[IMAGE_DEF,PULL_EXISTS] >> qexists_tac `f` >> rw[]) >> metis_tac[IBC_cases]) >>
   `{y | y âˆˆ fs âˆ§ equiv0 Î¼ f y} <> {}` by (`f IN {y | y âˆˆ fs âˆ§ equiv0 Î¼ f y}` by fs[] >> metis_tac[MEMBER_NOT_EMPTY]) >>
   `(CHOICE {y | y âˆˆ fs âˆ§ equiv0 Î¼ f y}) IN {y | y âˆˆ fs âˆ§ equiv0 Î¼ f y}` by metis_tac[CHOICE_DEF] >> fs[]));

val IBC_SUBSET = store_thm(
    "IBC_SUBSET",
    ``!f fs. IBC f fs ==> !gs. fs SUBSET gs ==> IBC f gs``,
    Induct_on `IBC` >> rw[]
    >> metis_tac[SUBSET_DEF,IBC_cases]);

      
val FINITE_FINITE_IBC = store_thm(
  "FINITE_FINITE_IBC",
  ``!fs. fs <> {} ==> FINITE (partition (equiv0 Î¼) fs) ==> FINITE (partition (equiv0 Î¼) {f | IBC f fs})``,
  rw[] >>
  `FINITE (IMAGE CHOICE fs//e)` by metis_tac[IMAGE_FINITE] >>
  `FINITE {f | IBC f (IMAGE CHOICE fs//e)}//e` by metis_tac[IBC_FINITE] >>
  `fs//e <> {}` by metis_tac[partition_eq_EMPTY] >>
  `?ff. SURJ ff ({f | IBC f (IMAGE CHOICE fs//e)}//e) ({f | IBC f fs}//e)` by
  (fs[partition_def] >> 
  qabbrev_tac `ff = \s. {y | IBC y fs /\ !f. f IN s ==> equiv0 Î¼ y f}` >> rw[SURJ_DEF] >>
  qexists_tac `ff` >> rw[]
  >- (fs[partition_def,Abbr`ff`] >> qexists_tac `x'` >> rw[]
     >- (`(IMAGE CHOICE {t | âˆƒx. x âˆˆ fs âˆ§ t = {y | y âˆˆ fs âˆ§ equiv0 Î¼ x y}}) SUBSET fs` by
        (rw[IMAGE_DEF,SUBSET_DEF] >>
	`{y | y âˆˆ fs âˆ§ equiv0 Î¼ x''' y} <> {}` by (`x''' IN {y | y âˆˆ fs âˆ§ equiv0 Î¼ x''' y}` by fs[] >> metis_tac[MEMBER_NOT_EMPTY]) >>
	`CHOICE {y | y âˆˆ fs âˆ§ equiv0 Î¼ x''' y} IN {y | y âˆˆ fs âˆ§ equiv0 Î¼ x''' y}` by metis_tac[CHOICE_DEF] >>
	fs[]) >>
	metis_tac[IBC_SUBSET])
     >- (rw[EXTENSION,EQ_IMP_THM]
        >- (`{t | âˆƒx. x âˆˆ fs âˆ§ t = {y | y âˆˆ fs âˆ§ equiv0 Î¼ x y}} SUBSET
	    {t |
               âˆƒx.
                  x âˆˆ fs âˆ§
                  âˆ€x''.
                     (x'' âˆˆ t â‡’ x'' âˆˆ fs âˆ§ equiv0 Î¼ x x'') âˆ§
                     (x'' âˆˆ fs âˆ§ equiv0 Î¼ x x'' â‡’ x'' âˆˆ t)}` by (rw[SUBSET_DEF] >> qexists_tac `x'''` >> rw[]) >>
	   qabbrev_tac `A = {t | âˆƒx. x âˆˆ fs âˆ§ t = {y | y âˆˆ fs âˆ§ equiv0 Î¼ x y}}` >>
	   qabbrev_tac `B = {t |
                                 âˆƒx.
                                    x âˆˆ fs âˆ§
                                            âˆ€x''.
                                            (x'' âˆˆ t â‡’ x'' âˆˆ fs âˆ§ equiv0 Î¼ x x'') âˆ§
                                            (x'' âˆˆ fs âˆ§ equiv0 Î¼ x x'' â‡’ x'' âˆˆ t)}` >>
	   `(IMAGE CHOICE A) SUBSET (IMAGE CHOICE B)` by metis_tac[IMAGE_SUBSET] >>
	   `IBC x' (IMAGE CHOICE B)` by metis_tac[IBC_SUBSET] >>
	   metis_tac[equiv0_REFL,equiv0_SYM,equiv0_TRANS])
	>> metis_tac[equiv0_SYM,equiv0_TRANS]))
  >- (fs[partition_def] >>
     qabbrev_tac `A = {t | âˆƒx. x âˆˆ fs âˆ§ t = {y | y âˆˆ fs âˆ§ equiv0 Î¼ x y}}` >>
     simp[PULL_EXISTS] >> drule IBC_partition_equiv0 >> rw[] >> qexists_tac `p` >> rw[]
     >- fs[partition_def,Abbr`A`]
     >- (rw[Abbr`ff`,EXTENSION,EQ_IMP_THM]
        >- (fs[partition_def,Abbr`A`] >> `equiv0 Î¼ x p` by fs[] >> metis_tac[equiv0_SYM,equiv0_TRANS])
	>- metis_tac[equiv0_SYM,equiv0_TRANS]))) >>
  metis_tac[FINITE_SURJ]);

val NOT_equiv0_VAR_DIAM = store_thm(
    "NOT_equiv0_VAR_DIAM",
    ``!a f. Â¬(equiv0 Î¼ (VAR a) (DIAM f))``,
    rw[equiv0_def] >>
    `?M w. satis M w (VAR a) /\ Â¬(satis M w (â—‡ f))` suffices_by metis_tac[] >>
    `univ(:'b) <> {}` by metis_tac[UNIV_NOT_EMPTY] >>
    `?b. b IN (univ(:'b))` by metis_tac[MEMBER_NOT_EMPTY] >>
    qexists_tac `<| frame := <| world := {b};
                           rel := Î»n1 n2. F |>;
                   valt := Î»e w. T|>` >> qexists_tac `b` >> rw[]
    >> rw[satis_def]);


val equiv0_DIAM_lemma = store_thm(
  "equiv0_DIAM_lemma",
  ``!f g Î¼:'a itself. INFINITE univ(:'a) ==> Â¬(equiv0 Î¼ f g) ==> Â¬(equiv0 Î¼ (DIAM f) (DIAM g))``,
  rw[EQ_equiv0_def] >>
  `âˆƒf:'a -> 'a. (âˆ€x y. f x = f y â‡’ x = y) âˆ§ âˆƒy. âˆ€x. f x â‰  y` by metis_tac[INFINITE_UNIV] >>
  `(satis M w f /\ Â¬satis M w g) \/ (Â¬satis M w f /\ satis M w g)` by metis_tac[] (* 2 *)
  >- (qexists_tac `<| frame := <| world := y INSERT (IMAGE f' M.frame.world);
                                    rel := Î»n1 n2. (?m1 m2. m1 IN M.frame.world /\ m2 IN M.frame.world /\
			                   M.frame.rel m1 m2 /\ f' m1 = n1 /\ f' m2 = n2) \/
					   (n1 = y /\ n2 = f' w) |>;
		       valt := \a b. (?c. f' c = b /\ M.valt a c) |>` >>
     qmatch_abbrev_tac `?w'. w' IN M'.frame.world /\ (satis M' w' (DIAM f) â‡Ž satis M' w' (DIAM g))` >>
     qexists_tac `y` >> rw[] (* 2 *)
    >- fs[Abbr`M'`]
    >- (`satis M' y (DIAM f) /\ Â¬satis M' y (DIAM g)` suffices_by metis_tac[] >> rw[satis_def] (* 3 *)
       >- fs[Abbr`M'`]
       >- (qexists_tac `f' w` >> 
          `bounded_mor f' M M'`
	      by (rw[bounded_mor_def] (* 4 *)
	          >- fs[Abbr`M'`]
		  >- (fs[Abbr`M'`] >> rw[satis_def] >> fs[IN_DEF] >> rw[EQ_IMP_THM] >> metis_tac[])
		  >- (fs[Abbr`M'`] >> metis_tac[])
		  >- (fs[Abbr`M'`] (* 4 *) >> metis_tac[])) >>
          `satis M w f <=> satis M' (f' w) f` by fs[prop_2_14] >>
	  fs[Abbr`M'`])
       >- (`!v. M'.frame.rel y v /\ v IN M'.frame.world ==> Â¬satis M' v g` suffices_by metis_tac[] >> rw[] >>
          `bounded_mor f' M M'`
	      by (rw[bounded_mor_def] (* 4 *)
	          >- fs[Abbr`M'`]
		  >- (fs[Abbr`M'`] >> rw[satis_def] >> fs[IN_DEF] >> rw[EQ_IMP_THM] >> metis_tac[])
		  >- (fs[Abbr`M'`] >> metis_tac[])
		  >- (fs[Abbr`M'`] (* 4 *) >> metis_tac[])) >>
	  fs[Abbr`M'`] (* 4 *)
	  >- metis_tac[]
	  >- metis_tac[]
	  >- metis_tac[]
	  >- (qmatch_abbrev_tac `Â¬satis M' (f' x) g` >> rw[] >>
	     metis_tac[prop_2_14]))))
  >- (qexists_tac `<| frame := <| world := y INSERT (IMAGE f' M.frame.world);
                                    rel := Î»n1 n2. (?m1 m2. m1 IN M.frame.world /\ m2 IN M.frame.world /\
			                   M.frame.rel m1 m2 /\ f' m1 = n1 /\ f' m2 = n2) \/
					   (n1 = y /\ n2 = f' w) |>;
		       valt := \a b. (?c. f' c = b /\ M.valt a c) |>` >>
     qmatch_abbrev_tac `?w'. w' IN M'.frame.world /\ (satis M' w' (DIAM f) â‡Ž satis M' w' (DIAM g))` >>
     qexists_tac `y` >> rw[] (* 2 *)
    >- fs[Abbr`M'`]
    >- (`Â¬satis M' y (DIAM f) /\ satis M' y (DIAM g)` suffices_by metis_tac[] >> rw[satis_def] (* 3 *)
       >- (`!v. M'.frame.rel y v /\ v IN M'.frame.world ==> Â¬satis M' v f` suffices_by metis_tac[] >> rw[] >>
          `bounded_mor f' M M'`
	      by (rw[bounded_mor_def] (* 4 *)
	          >- fs[Abbr`M'`]
		  >- (fs[Abbr`M'`] >> rw[satis_def] >> fs[IN_DEF] >> rw[EQ_IMP_THM] >> metis_tac[])
		  >- (fs[Abbr`M'`] >> metis_tac[])
		  >- (fs[Abbr`M'`] (* 4 *) >> metis_tac[])) >>
	  fs[Abbr`M'`] (* 4 *)
	  >- metis_tac[]
	  >- metis_tac[]
	  >- metis_tac[]
	  >- (qmatch_abbrev_tac `Â¬satis M' (f' x) f` >> rw[] >>
	     metis_tac[prop_2_14]))
       >- fs[Abbr`M'`]
       >- (qexists_tac `f' w` >> 
          `bounded_mor f' M M'`
	      by (rw[bounded_mor_def] (* 4 *)
	          >- fs[Abbr`M'`]
		  >- (fs[Abbr`M'`] >> rw[satis_def] >> fs[IN_DEF] >> rw[EQ_IMP_THM] >> metis_tac[])
		  >- (fs[Abbr`M'`] >> metis_tac[])
		  >- (fs[Abbr`M'`] (* 4 *) >> metis_tac[])) >>
          `satis M w g <=> satis M' (f' w) g` by fs[prop_2_14] >>
	  fs[Abbr`M'`]))));


val equiv0_DIAM = store_thm(
    "equiv0_DIAM",
    ``!f g Î¼. INFINITE univ(:'b) ==> (equiv0 (Î¼:'b itself) (DIAM f) (DIAM g) <=> equiv0 Î¼ f g)``,
    rw[EQ_IMP_THM]
    >- (SPOSE_NOT_THEN ASSUME_TAC >> metis_tac[equiv0_DIAM_lemma])
    >- fs[equiv0_def,satis_def]);



val prop_2_29_strengthen = store_thm(
  "prop_2_29_strengthen",
  ``!s. FINITE s /\ INFINITE univ(:'b) ==> !n. FINITE (partition (equiv0 (Î¼:'b itself)) {f| DEG f <= n /\
                                                   (!a. (VAR a) IN (subforms f) ==> a IN s)})``,
gen_tac >> strip_tac >>
Induct_on `n` 
>- (`{f | DEG f â‰¤ 0 âˆ§ âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s} =
   {f | propform f âˆ§ âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s}` by (simp[EXTENSION] >> metis_tac[DEG_0_propform]) >> fs[] >>
   `FINITE (POW (POW (POW s)))` by metis_tac[FINITE_POW] >>
   metis_tac[INJ_peval_partition_strengthen,FINITE_INJ])
>> (* step case *)
   `SUC n = n + 1` by fs[] >> rw[] >>
   `{f | DEG f â‰¤ n + 1 âˆ§ âˆ€a. (VAR a) IN subforms f â‡’ a âˆˆ s} = {phi | IBC phi ({VAR v | v IN s} UNION {DIAM psi | DEG psi <= n /\ âˆ€a. (VAR a) IN subforms psi â‡’ a âˆˆ s})}`
       by (fs[EXTENSION] >> rw[EQ_IMP_THM] (* 3 *)
           >> metis_tac[DEG_IBC_strengthen]) >> simp[] >>
   Cases_on `{VAR v | v âˆˆ s} âˆª
      {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s} = {}`
   (* empty case *)
   >- (fs[] >> fs[partition_def] >>
      `{t | âˆƒx. IBC x âˆ… âˆ§ t = {y | IBC y âˆ… âˆ§ equiv0 Î¼ x y}} = {{f | IBC f {} /\ equiv0 Î¼ f TRUE};{f | IBC f {} /\ equiv0 Î¼ f FALSE}}` by
      (simp[Once EXTENSION] >> rw[] >> eq_tac >> rw[] (* 3 *)
      >- (drule IBC_EMPTY_lemma >> rw[]
         >- (`{y | IBC y âˆ… âˆ§ equiv0 Î¼ x' y} = {f | IBC f âˆ… âˆ§ equiv0 Î¼ f TRUE}` suffices_by metis_tac[] >>
	    rw[EXTENSION,EQ_IMP_THM] >> metis_tac[equiv0_SYM,equiv0_TRANS])
         >- (`{y | IBC y âˆ… âˆ§ equiv0 Î¼ x' y} = {f | IBC f âˆ… âˆ§ equiv0 Î¼ f FALSE}` suffices_by metis_tac[] >>
	    rw[EXTENSION,EQ_IMP_THM] >> metis_tac[equiv0_SYM,equiv0_TRANS]))
      >- (qexists_tac `TRUE` >> rw[]
         >- (rw[Once IBC_cases] >>
	    `âˆƒf. TRUE = Â¬f âˆ§ IBC f âˆ…` suffices_by metis_tac[] >> qexists_tac `FALSE` >> metis_tac[IBC_cases,TRUE_def])
	 >- (rw[EXTENSION,EQ_IMP_THM] >> metis_tac[equiv0_SYM]))
      >- (qexists_tac `FALSE` >> rw[]
         >- rw[Once IBC_cases] 
	 >- (rw[EXTENSION,EQ_IMP_THM] >> metis_tac[equiv0_SYM]))) >> fs[])
   (* nonempty case *)
   >- (irule FINITE_FINITE_IBC (* 2 *)
      >- (`({VAR v | v âˆˆ s} âˆª {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s})//e =
          {VAR v | v âˆˆ s}//e âˆª {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s}//e`
	     by (irule equiv_on_disjoint_partition
	        >- (rw[] >> metis_tac[NOT_equiv0_VAR_DIAM])
                >- metis_tac[equiv0_equiv_on]
	        >- metis_tac[equiv0_equiv_on])
	        >> rw[] (* 2 *)
          >-  (`FINITE {VAR v | v IN s}` suffices_by metis_tac[FINITE_partition] >>
	       `SURJ VAR s {VAR v | v IN s}` suffices_by metis_tac[FINITE_SURJ] >> rw[SURJ_DEF])
	  >- (qabbrev_tac `A = {psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s}//e` >> 
	       qabbrev_tac `B = {â—‡ psi | DEG psi â‰¤ n âˆ§ âˆ€a. VAR a âˆˆ subforms psi â‡’ a âˆˆ s}//e` >>
	       `?ff. SURJ ff A B` suffices_by metis_tac[FINITE_SURJ] >>
	       qexists_tac `\s. {DIAM t | t IN s}` >> rw[SURJ_DEF] (* 2 *)
               >- (fs[Abbr`B`] >> rw[Once EXTENSION,partition_def] >> fs[PULL_EXISTS] >> fs[Abbr`A`,partition_def] >>
	          qexists_tac `x` >> rw[] >> eq_tac >> rw[] (* 4 *) >> metis_tac[equiv0_DIAM])
	       >- (fs[Abbr`A`,Abbr`B`] (* 2 *)
	          >> (fs[partition_def] >> fs[PULL_EXISTS] >>
		     qexists_tac `psi` >> fs[] >> rw[EXTENSION] >> eq_tac >> rw[] (* 2 *) >> metis_tac[equiv0_DIAM]))))
       >- rw[]));



val prop_2_29 = store_thm(
"prop_2_29",
``INFINITE univ(:'b) /\ FINITE univ (:'a) ==> !n. FINITE (partition (equiv0 (Î¼:'b itself)) {f:'a form | DEG f <= n})``,
rw[] >> drule prop_2_29_strengthen >> rw[]);



(* n-bisimulation *)


val nbisim_def = Define`
nbisim M M' f n w w' <=>
w IN M.frame.world /\
w' IN M'.frame.world /\
(!m a b. a IN M.frame.world /\ b IN M'.frame.world ==> (m + 1 <= n ==> (f (m + 1)) a b ==> (f m) a b)) /\
((f n) w w') /\
(!v v'. v IN M.frame.world /\ v' IN M'.frame.world ==> ((f 0) v v' ==> !p. satis M v (VAR p) <=> satis M' v' (VAR p))) /\
(!v v' u i. (i + 1 <= n /\ v IN M.frame.world /\ v' IN M'.frame.world /\ u IN M.frame.world /\ M.frame.rel v u /\ (f (i + 1)) v v') ==>
(?u'. u' IN M'.frame.world /\ M'.frame.rel v' u' /\ (f i) u u')) /\
(!v v' u' i. (i + 1 <= n /\ v IN M.frame.world /\ v' IN M'.frame.world /\ u' IN M'.frame.world /\ M'.frame.rel v' u' /\ (f (i + 1)) v v') ==>
(?u. u IN M.frame.world /\ M.frame.rel v u /\ (f i) u u'))`;


val suc_bisim = store_thm(
"suc_bisim",
``!M M' f n w w'. nbisim M M' f (n + 1) w w' ==> nbisim M M' f n w w'``,
rpt strip_tac >>
`w IN M.frame.world` by metis_tac[nbisim_def] >>
`w' IN M'.frame.world` by metis_tac[nbisim_def] >>
`f (n + 1) w w'` by metis_tac[nbisim_def] >>
rw[nbisim_def]
>- (`m + 1 <= n + 1` by simp[] >> metis_tac[nbisim_def])
>- (`n + 1 <= n + 1` by simp[] >> metis_tac[nbisim_def])
>- metis_tac[nbisim_def]
>- (`i + 1 <= n + 1` by simp[] >> fs[nbisim_def] >> metis_tac[])
>- (`i + 1 <= n + 1` by simp[] >> fs[nbisim_def] >> metis_tac[nbisim_def]));

val suc_nbisim_rel = store_thm(
"suc_nbisim_rel",
``!M M' f n w w' v. nbisim M M' f (n + 1) w w' /\ M.frame.rel w v /\ v IN M.frame.world /\ w IN M.frame.world ==>
(?v'. v' IN M'.frame.world /\ M'.frame.rel w' v' /\ nbisim M M' f n v v')``,
rpt strip_tac >> `n + 1 <= n + 1` by simp[] >>
`(f (n + 1)) w w'` by metis_tac[nbisim_def] >>
`w IN M.frame.world` by metis_tac[nbisim_def] >>
`w' IN M'.frame.world` by metis_tac[nbisim_def] >>
fs[nbisim_def] >> `n <= n` by simp[] >>
`âˆƒu'. u' âˆˆ M'.frame.world âˆ§ M'.frame.rel w' u' âˆ§ f n v u'` by metis_tac[] >> qexists_tac`u'` >> rw[]
>> `i <= n` by simp[] >> metis_tac[]);

val suc_nbisim_rel_SYM = store_thm(
"suc_nbisim_rel_SYM",
``!M M' f n w w' v'. nbisim M M' f (n + 1) w w' /\ M'.frame.rel w' v' /\ v' IN M'.frame.world /\ w' IN M'.frame.world ==>
(?v. v IN M.frame.world /\ M.frame.rel w v /\ nbisim M M' f n v v')``,
rpt strip_tac >> `n + 1 <= n + 1` by simp[] >>
`(f (n + 1)) w w'` by metis_tac[nbisim_def] >>
`w IN M.frame.world` by metis_tac[nbisim_def] >>
fs[nbisim_def] >> `n <= n` by simp[] >>
`âˆƒu. u âˆˆ M.frame.world âˆ§ M.frame.rel w u âˆ§ f n u v'` by metis_tac[] >>
qexists_tac`u` >> rw[]
>> `i <= n` by simp[] >> metis_tac[]);


val DIAM_DEG_NOT_ZERO = store_thm(
"DIAM_DEG_NOT_ZERO",
``!phi. DEG (DIAM phi) <> 0``,
rpt strip_tac >> fs[DEG_def]);

val nbisim_rel_trans = store_thm(
"nbisim_rel_trans",
``!M M' f n w w'. nbisim M M' f n w w' ==> (f 0) w w'``,
rpt strip_tac >> Induct_on `n` >> rpt strip_tac
>- metis_tac[nbisim_def]
>- (`SUC n = n + 1` by simp[] >>
   `nbisim M M' f n w w'` by metis_tac[suc_bisim] >>
   metis_tac[]));


val prop_2_31_half1 = store_thm(
"prop_2_31_half1",
``!M M' n w w'. (?f. nbisim M M' f n w w') ==> (!(phi: 'a form). DEG phi <= n ==> (satis M w phi <=> satis M' w' phi))``,
gen_tac >> gen_tac >> gen_tac >> Induct_on `n`
>- (rpt strip_tac >>
    `DEG phi = 0` by simp[] >>
    `w IN M.frame.world /\ w' IN M'.frame.world` by metis_tac[nbisim_def] >>
    Induct_on `phi` >> rpt strip_tac 
    >- (`(f 0) w w'` by metis_tac[nbisim_def] >> fs[nbisim_def])
    >- (fs[DEG_def] >> metis_tac[satis_def])
    >- metis_tac[satis_def]
    >- (fs[DEG_def] >> metis_tac[satis_def])
    >- metis_tac[DIAM_DEG_NOT_ZERO])
>- (rw[] >>
    Induct_on `phi` >> simp[DEG_def]
    >- (gen_tac >> first_x_assum irule >> rw[DEG_def] >> metis_tac[suc_bisim,ADD1])
    >- rw[satis_def]
    >- rw[satis_def]
    >- (rw[satis_def] >> metis_tac[nbisim_def]) 
    >- (simp[ADD1, satis_def] >> rw[EQ_IMP_THM] 
      >- metis_tac[nbisim_def]
      >- (`M.frame.rel w v` by fs[IN_DEF] >>
        fs[ADD1] >>
        `?v'. M'.frame.rel w' v' /\ nbisim M M' f n v v' /\ v' âˆˆ M'.frame.world`
           by metis_tac[ADD1,suc_nbisim_rel] >>
        metis_tac[IN_DEF])
      >- metis_tac[nbisim_def]
      >- (fs[ADD1] >>
       `âˆƒp. p âˆˆ M.frame.world âˆ§ M.frame.rel w p âˆ§ nbisim M M' f n p v` by metis_tac[suc_nbisim_rel_SYM] >>
       metis_tac[]))));




val BIGCONJ_EXISTS_DEG = store_thm(
  "BIGCONJ_EXISTS_DEG",
  ``âˆ€s.
     FINITE s â‡’
     (!f. f IN s ==> DEG f <= n) ==>
     ?ff. DEG ff <= n /\
     âˆ€w M.
        w âˆˆ M.frame.world â‡’ (satis M w ff â‡” âˆ€f. f âˆˆ s â‡’ satis M w f)``,
  Induct_on `FINITE` >> rw[]
  >- (qexists_tac `TRUE` >> rw[TRUE_def,satis_def,DEG_def])
  >- (`âˆ€f. f âˆˆ s â‡’ DEG f â‰¤ n` by metis_tac[] >>
     first_x_assum drule >> rw[] >>
     qexists_tac `AND e ff` >> rw[DEG_def,satis_def,AND_def] >> eq_tac >> rw[]
     >- rw[]
     >> metis_tac[]));


(* all of these for 2.31 half 2 are commented out for this moment, up to the construction of FMP via filtration 

(*
val prop_2_31_half2 = store_thm(
"prop_2_31_half2",
``!M M' n w:'b w':'b. (INFINITE univ(:'b) /\ FINITE univ (:'a) /\ w IN M.frame.world /\ w' IN M'.frame.world) ==> (!(phi: 'a form). DEG phi <= n ==> (satis M w phi <=> satis M' w' phi)) ==> ?f. nbisim M M' f n w w'``,
rpt strip_tac
>> rw[nbisim_def]
>> qexists_tac `Î»n n1 n2. (!(phi: 'a form). DEG phi <= n ==> (satis M n1 phi <=> satis M' n2 phi))` >> rw[]
>- metis_tac[DEG_def]
>- (SPOSE_NOT_THEN ASSUME_TAC >>
    `âˆ€u'.
          u' âˆˆ M'.frame.world /\ M'.frame.rel v' u' ==>
          (?form. DEG form <= i /\ satis M u form /\ Â¬satis M' u' form)`
        by (rw[satis_def] >>
	   `âˆƒphi. DEG phi â‰¤ i âˆ§ (satis M u phi â‡Ž satis M' u' phi)` by metis_tac[] >>
	   Cases_on `satis M u phi` >- (qexists_tac `phi` >> metis_tac[])
	                            >- (qexists_tac `NOT phi` >> rw[]
				                                >- metis_tac[DEG_def]
								>> metis_tac[satis_def])) >>
								
    qabbrev_tac `
      s = {f | DEG f <= i /\ ?u'. u' IN M'.frame.world /\
               M'.frame.rel v' u' /\ satis M u f /\ Â¬satis M' u' f}` >>
   `s âŠ† {f| DEG f <= i}` by (fs[Abbr`s`,SUBSET_DEF]) >>
   `(equiv0 Î¼) equiv_on {f | DEG f â‰¤ i}` by metis_tac[equiv0_equiv_on] >>
   `FINITE s//e` by metis_tac[prop_2_29,FINITE_partition_SUBSET] >>
   `FINITE (IMAGE CHOICE s//e)` by metis_tac[IMAGE_FINITE] >>
   `(equiv0 Î¼) equiv_on s` by metis_tac[equiv0_equiv_on] >> 
   `!p. p IN s//e ==> p <> {}` by metis_tac[EMPTY_NOT_IN_partition] >>
   `!p. p IN s//e ==> (CHOICE p) IN p` by metis_tac[CHOICE_DEF] >>
   `!f. f IN (IMAGE CHOICE s//e) ==> DEG f <= i`
     by (dsimp[] >> rw[] >> `(CHOICE x) IN x` by metis_tac[] >>
         `x SUBSET s` by fs[partition_def,SUBSET_DEF] >>
         `(CHOICE x) IN s` by metis_tac[SUBSET_DEF, partition_def] >>
         fs[Abbr`s`]) >>
   `âˆƒff.
        DEG ff â‰¤ i âˆ§
        âˆ€w:'b M.
           w âˆˆ M.frame.world â‡’ (satis M w ff â‡” âˆ€f. f âˆˆ (IMAGE CHOICE s//e) â‡’ satis M w f)` by fs[BIGCONJ_EXISTS_DEG] >>
   `âˆ€f. f âˆˆ IMAGE CHOICE s//e â‡’ satis M u f`
     by (rw[] >>
        `(CHOICE x) IN x` by metis_tac[] >>
	fs[partition_def,Abbr`s`] >> rw[] >> fs[]) >>
   `satis M u ff` by metis_tac[] >> (*???????????????????????????????????????????? *)
   `satis M v (DIAM ff)` by metis_tac[satis_def] >>
   `DEG (DIAM ff) <= i + 1` by fs[DEG_def] >>
   `Â¬satis M' v' (DIAM ff)` suffices_by metis_tac[] >>
   `âˆ€u'. M'.frame.rel v' u' /\ u' âˆˆ M'.frame.world ==> Â¬satis M' u' ff`
      suffices_by metis_tac[satis_def] >>
   rw[partition_def,PULL_EXISTS] >>
   `âˆƒform. DEG form â‰¤ i âˆ§ satis M u form âˆ§ Â¬satis M' u' form` by metis_tac[] >>
   `form IN s` by (fs[Abbr`s`] >> qexists_tac `u'` >> rw[]) >>
   rw[] >>
   `equiv0 Î¼ form form` by metis_tac[equiv0_REFL] >> `form IN {y | y âˆˆ s âˆ§ equiv0 Î¼ form y}` by fs[] >>
   `{y | y âˆˆ s âˆ§ equiv0 Î¼ form y} <> {}` by metis_tac[MEMBER_NOT_EMPTY] >>
   `(CHOICE {y | y âˆˆ s âˆ§ equiv0 Î¼ form y}) IN {y | y âˆˆ s âˆ§ equiv0 Î¼ form y}` by metis_tac[CHOICE_DEF] >>
   fs[] >>
   metis_tac[equiv0_SYM,equiv0_def])
>- (SPOSE_NOT_THEN ASSUME_TAC >>
   `?u. u IN M.frame.world /\ M.frame.rel v u` by 
   (`Â¬(!u. u IN M.frame.world ==> Â¬M.frame.rel v u)` suffices_by metis_tac[] >>
   rpt strip_tac >>
   `satis M v (BOX FALSE)` by metis_tac[box_vac_true] >>
   `satis M v (NOT (DIAM TRUE))` by metis_tac[BOX_def,TRUE_def,satis_def] >>
   `Â¬(satis M v (DIAM TRUE))` by metis_tac[satis_def] >>
   `satis M' v' (DIAM TRUE)` by metis_tac[diam_exist_true] >>
   `DEG (DIAM TRUE) <= i + 1` by fs[TRUE_def,DEG_def] >>
   metis_tac[]) >> 
   `u IN {u | u âˆˆ M.frame.world âˆ§ M.frame.rel v u}` by simp[] >>
   `âˆ€u.
          u âˆˆ M.frame.world â‡’ M.frame.rel v u ==>
          Â¬(âˆ€form. DEG form <= i ==> (satis M' u' form â‡” satis M u form))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          Â¬(âˆ€form. DEG form <= i ==> (satis M' u' form â‡” satis M u form))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          Â¬(âˆ€form. DEG form <= i ==> (Â¬(Â¬(satis M' u' form â‡” satis M u form))))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          (?form. DEG form <= i /\ Â¬(satis M' u' form â‡” satis M u form))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          (?form. DEG form <= i /\ satis M' u' form /\ Â¬satis M u form)` by
       (rw[] >>
       last_x_assum drule >> rw[] >> 
       Cases_on `satis M u'' phi`
       >- (`Â¬satis M' u' phi` by metis_tac[] >> qexists_tac `Â¬phi` >> rw[satis_def,DEG_def])
       >- (`satis M' u' phi` by metis_tac[] >> qexists_tac `phi` >> rw[])) >> 
   qabbrev_tac `s = {f | DEG f <= i /\ ?u. u IN M.frame.world /\ M.frame.rel v u /\ satis M' u' f /\ Â¬satis M u f}` >>
   `s âŠ† {f| DEG f <= i}` by (fs[Abbr`s`,SUBSET_DEF]) >>
   `equiv0 equiv_on {f | DEG f â‰¤ i}` by metis_tac[equiv0_equiv_on] >>
   `FINITE s//e` by metis_tac[prop_2_29,FINITE_partition_SUBSET] >>
   `FINITE (IMAGE CHOICE s//e)` by
   (`equiv0 equiv_on s` by metis_tac[equiv0_equiv_on] >>
   `BIJ CHOICE s//e (IMAGE CHOICE s//e)` by metis_tac[CHOICE_BIJ_partition] >>
   metis_tac[FINITE_BIJ]) >>
   `equiv0 equiv_on s` by metis_tac[equiv0_equiv_on] >> 
   `!p. p IN s//e ==> p <> {}` by metis_tac[EMPTY_NOT_IN_partition] >>
   `!p. p IN s//e ==> (CHOICE p) IN p` by metis_tac[CHOICE_DEF] >>
   `!f. f IN (IMAGE CHOICE s//e) ==> DEG f <= i` by
   (fs[IMAGE_DEF] >> rw[] >> `(CHOICE x) IN x` by metis_tac[] >>
   `x SUBSET s` by fs[partition_def,SUBSET_DEF] >>
   `(CHOICE x) IN s` by metis_tac[SUBSET_DEF] >>
   fs[Abbr`s`]) >>
   `âˆƒff.
        DEG ff â‰¤ i âˆ§
        âˆ€w M.
           w âˆˆ M.frame.world â‡’ (satis M w ff â‡” âˆ€f. f âˆˆ (IMAGE CHOICE s//e) â‡’ satis M w f)` by fs[BIGCONJ_EXISTS_DEG] >>
   `âˆ€f. f âˆˆ IMAGE CHOICE s//e â‡’ satis M' u' f` by
   (rw[IMAGE_DEF] >>
   `x <> {}` by metis_tac[EMPTY_NOT_IN_partition] >>
   `(CHOICE x) IN x` by metis_tac[CHOICE_DEF] >> fs[partition_def,Abbr`s`] >> rw[] >> fs[]) >>
   `satis M' u' ff` by metis_tac[] >>
   `satis M' v' (DIAM ff)` by metis_tac[satis_def] >>
   `DEG (DIAM ff) <= i + 1` by fs[DEG_def] >>
   `Â¬satis M v (DIAM ff)` suffices_by metis_tac[] >> simp[satis_def] >>
   `!v''. M.frame.rel v v'' /\ v'' IN M.frame.world ==> Â¬satis M v'' ff` suffices_by metis_tac[satis_def] >> rw[] >>
   simp[PULL_EXISTS] >>
   `âˆƒform. DEG form â‰¤ i âˆ§ satis M' u' form âˆ§ Â¬satis M v'' form` by metis_tac[] >>
   rw[partition_def,PULL_EXISTS] >>
   `form IN s` by (fs[Abbr`s`] >> qexists_tac `v''` >> rw[]) >>
   qexists_tac `form` >> rw[] >>
   `equiv0 form form` by metis_tac[equiv0_REFL] >> `form IN {y | y âˆˆ s âˆ§ equiv0 form y}` by fs[] >>
   `{y | y âˆˆ s âˆ§ equiv0 form y} <> {}` by metis_tac[MEMBER_NOT_EMPTY] >>
   `(CHOICE {y | y âˆˆ s âˆ§ equiv0 form y}) IN {y | y âˆˆ s âˆ§ equiv0 form y}` by metis_tac[CHOICE_DEF] >>
   fs[] >> 
   metis_tac[equiv0_SYM,equiv0_def]));
                          `

val equiv0_INFINITE_UNIV = store_thm(
  "equiv0_INFINITE_UNIV",
  ``INFINITE univ(:'a) ==> (equiv0 (:num) f1 f2 <=> equiv0 (:'a) f1 f2)``,
  `INFINITE ð•Œ(:Î±) â‡’ (Â¬equiv0 (:num) f1 f2 â‡” Â¬equiv0 (:Î±) f1 f2)` suffices_by metis_tac[] >>
  strip_tac >> eq_tac
  >- (rw[] >>
     `?M w:num. (satis M w f1 /\ Â¬satis M w f2) \/ (Â¬satis M w f1 /\ satis M w f2)` by metis_tac[equiv0_def] (* 2 *)
     >- (`satis M w (NOT f2)` by metis_tac[satis_def,satis_in_world] >>
        `satis M w (AND f1 (NOT f2))` by metis_tac[satis_AND] >>
	`âˆƒf. INJ f ð•Œ(:num) univ(:'a)` by metis_tac[infinite_num_inj] >>
        qabbrev_tac `N = <| frame := <| world := {f n| n IN M.frame.world};
	                                  rel := (\a1 a2. ?n1 n2. n1 IN M.frame.world /\
					                          n2 IN M.frame.world /\
								  f n1 = a1 /\ f n2 = a2 /\
								  M.frame.rel n1 n2) |>;
			     valt := (\(p:'b) a:'a. (?n. n IN M.frame.world /\ f n = a /\ M.valt p n)) |>` >>
	`bounded_mor f M N`
	    by (rw[bounded_mor_def] (* 4 *)
	       >- (fs[Abbr`N`] >>  qexists_tac `w'` >> rw[])
	       >- (rw[satis_def] >> eq_tac >> rw[] >- (fs[Abbr`N`] >> qexists_tac `w'` >> rw[])
	                                           >- (fs[Abbr`N`] >> metis_tac[IN_DEF])
						   >- (fs[Abbr`N`] >>
						      `n' = w'` by fs[INJ_DEF] >> fs[IN_DEF]))
	       >- (fs[Abbr`N`] >> map_every qexists_tac [`w'`,`v`] >> fs[])
	       >- (fs[Abbr`N`] >> qexists_tac `n` >> rw[] >>
	          `n2 = n /\ n1 = w'` by fs[INJ_DEF] >> fs[])) >>
        `w IN M.frame.world` by metis_tac[satis_in_world] >>
	`satis N (f w) (AND f1 (NOT f2))` by metis_tac[prop_2_14] >>
	`satis N (f w) f1 /\ satis N (f w) (NOT f2)` by metis_tac[satis_AND] >>
	`Â¬satis N (f w) f2` by metis_tac[satis_def] >>
	rw[equiv0_def] >> map_every qexists_tac [`N`,`f w`] >> metis_tac[])
     >- (`satis M w (NOT f1)` by metis_tac[satis_def,satis_in_world] >>
        `satis M w (AND f2 (NOT f1))` by metis_tac[satis_AND] >>
	`âˆƒf. INJ f ð•Œ(:num) univ(:'a)` by metis_tac[infinite_num_inj] >>
        qabbrev_tac `N = <| frame := <| world := {f n| n IN M.frame.world};
	                                  rel := (\a1 a2. ?n1 n2. n1 IN M.frame.world /\
					                          n2 IN M.frame.world /\
								  f n1 = a1 /\ f n2 = a2 /\
								  M.frame.rel n1 n2) |>;
			     valt := (\(p:'b) a:'a. (?n. n IN M.frame.world /\ f n = a /\ M.valt p n)) |>` >>
	`bounded_mor f M N`
	    by (rw[bounded_mor_def] (* 4 *)
	       >- (fs[Abbr`N`] >>  qexists_tac `w'` >> rw[])
	       >- (rw[satis_def] >> eq_tac >> rw[] >- (fs[Abbr`N`] >> qexists_tac `w'` >> rw[])
	                                           >- (fs[Abbr`N`] >> metis_tac[IN_DEF])
						   >- (fs[Abbr`N`] >>
						      `n' = w'` by fs[INJ_DEF] >> fs[IN_DEF]))
	       >- (fs[Abbr`N`] >> map_every qexists_tac [`w'`,`v`] >> fs[])
	       >- (fs[Abbr`N`] >> qexists_tac `n` >> rw[] >>
	          `n2 = n /\ n1 = w'` by fs[INJ_DEF] >> fs[]))>>
        `w IN M.frame.world` by metis_tac[satis_in_world] >>
	`satis N (f w) (AND f2 (NOT f1))` by metis_tac[prop_2_14] >>
	`satis N (f w) f2 /\ satis N (f w) (NOT f1)` by metis_tac[satis_AND] >>
	`Â¬satis N (f w) f1` by metis_tac[satis_def] >>
	rw[equiv0_def] >> map_every qexists_tac [`N`,`f w`] >> metis_tac[]))
  >- (rw[] >>
     `?M w:'a. (satis M w f1 /\ Â¬satis M w f2) \/ (Â¬satis M w f1 /\ satis M w f2)` by metis_tac[equiv0_def] (* 2 *)
     >- (`satis M w (NOT f2)` by metis_tac[satis_def,satis_in_world] >>
        `satis M w (AND f1 (NOT f2))` by metis_tac[satis_AND] >>
	`?M' w':'a. w' IN M'.frame.world /\ satis M' w' (AND f1 (NOT f2)) /\ FINITE M'.frame.world`
	    by metis_tac[thm_2_41] >>
	`âˆƒf. INJ f M'.frame.world univ(:num)`
	    by metis_tac[finite_countable,countable_def] >>
        qabbrev_tac `N = <| frame := <| world := {f a| a IN M'.frame.world};
	                                  rel := (\n1 n2. ?a1 a2. a1 IN M'.frame.world /\
					                          a2 IN M'.frame.world /\
								  f a1 = n1 /\ f a2 = n2 /\
								  M'.frame.rel a1 a2) |>;
			     valt := (\(p:'b) n:num. (?a. a IN M'.frame.world /\ f a = n /\ M'.valt p a)) |>` >>
	`bounded_mor f M' N`
	    by (rw[bounded_mor_def] (* 4 *)
	       >- (fs[Abbr`N`] >> qexists_tac `w''` >> rw[])
	       >- (rw[satis_def] >> eq_tac >> rw[] >- (fs[Abbr`N`] >> qexists_tac `w''` >> rw[])
	                                           >- (fs[Abbr`N`] >> qexists_tac `w''` >> fs[IN_DEF])
						   >- (fs[Abbr`N`] >> `a'' = w''` by metis_tac[INJ_DEF] >> metis_tac[IN_DEF]))
	       >- (fs[Abbr`N`] >> map_every qexists_tac [`w''`,`v`] >> fs[])
	       >- (fs[Abbr`N`] >> qexists_tac `a` >> rw[] >>
	          `a2 = a /\ a1 = w''` by fs[INJ_DEF] >> fs[])) >>
	`satis N (f w') (AND f1 (NOT f2))` by metis_tac[prop_2_14] >>
	`satis N (f w') f1 /\ satis N (f w') (NOT f2)` by metis_tac[satis_AND] >>
	`Â¬satis N (f w') f2` by metis_tac[satis_def] >>
	rw[equiv0_def] >> map_every qexists_tac [`N`,`f w'`] >> metis_tac[])
     >- (`satis M w (NOT f1)` by metis_tac[satis_def,satis_in_world] >>
        `satis M w (AND f2 (NOT f1))` by metis_tac[satis_AND] >>
	`?M' w':'a. w' IN M'.frame.world /\ satis M' w' (AND f2 (NOT f1)) /\ FINITE M'.frame.world`
	    by metis_tac[thm_2_41] >>
	`âˆƒf. INJ f M'.frame.world univ(:num)`
	    by metis_tac[finite_countable,countable_def] >>
        qabbrev_tac `N = <| frame := <| world := {f a| a IN M'.frame.world};
	                                  rel := (\n1 n2. ?a1 a2. a1 IN M'.frame.world /\
					                          a2 IN M'.frame.world /\
								  f a1 = n1 /\ f a2 = n2 /\
								  M'.frame.rel a1 a2) |>;
			     valt := (\(p:'b) n:num. (?a. a IN M'.frame.world /\ f a = n /\ M'.valt p a)) |>` >>
	`bounded_mor f M' N`
	    by (rw[bounded_mor_def] (* 4 *)
	       >- (fs[Abbr`N`] >> qexists_tac `w''` >> rw[])
	       >- (rw[satis_def] >> eq_tac >> rw[] >- (fs[Abbr`N`] >> qexists_tac `w''` >> rw[])
	                                           >- (fs[Abbr`N`] >> qexists_tac `w''` >> fs[IN_DEF])
						   >- (fs[Abbr`N`] >> `a'' = w''` by metis_tac[INJ_DEF] >> metis_tac[IN_DEF]))
	       >- (fs[Abbr`N`] >> map_every qexists_tac [`w''`,`v`] >> fs[])
	       >- (fs[Abbr`N`] >> qexists_tac `a` >> rw[] >>
	          `a2 = a /\ a1 = w''` by fs[INJ_DEF] >> fs[])) >>
	`satis N (f w') (AND f2 (NOT f1))` by metis_tac[prop_2_14] >>
	`satis N (f w') f2 /\ satis N (f w') (NOT f1)` by metis_tac[satis_AND] >>
	`Â¬satis N (f w') f1` by metis_tac[satis_def] >>
	rw[equiv0_def] >> map_every qexists_tac [`N`,`f w'`] >> metis_tac[])));

val equiv0_equal_for_INFINITE_UNIV = store_thm(
  "equiv0_equal_for_INFINITE_UNIV",
  ``INFINITE univ(:'a) /\ INFINITE univ(:'b)
    ==> (equiv0 (:'a) = equiv0 (:'b))``,
  simp[FUN_EQ_THM] >> rw[] >>
  `(equiv0 (:num) x x' â‡” equiv0 (:Î±) x x')` by metis_tac[equiv0_INFINITE_UNIV] >>
  `(equiv0 (:num) x x' â‡” equiv0 (:'b) x x')` by metis_tac[equiv0_INFINITE_UNIV] >>
  metis_tac[]);





val prop_2_31_half2 = store_thm(
  "prop_2_31_half2",
  ``!M M' n w:'b w':'c.
  (INFINITE univ(:'b) /\ INFINITE univ(:'c) /\ FINITE univ (:'a) /\
  w IN M.frame.world /\ w' IN M'.frame.world)
  ==> (!(phi: 'a form). DEG phi <= n ==> (satis M w phi <=> satis M' w' phi))
      ==> ?f. nbisim M M' f n w w'``,
  rpt strip_tac >>
  `(equiv0 (:num) f1 f2 â‡” equiv0 (:'b) f1 f2)` by metis_tac[equiv0_INFINITE_UNIV] >>
  `(equiv0 (:num) f1 f2 â‡” equiv0 (:'c) f1 f2)` by metis_tac[equiv0_INFINITE_UNIV] >>
  `(equiv0 (:'b) f1 f2 â‡” equiv0 (:'c) f1 f2)` by metis_tac[] >> 
  rw[nbisim_def] >>
  qexists_tac `Î»n n1 n2. (!(phi: 'a form). DEG phi <= n ==> (satis M n1 phi <=> satis M' n2 phi))` >> rw[]
  >- metis_tac[DEG_def]
  >- (SPOSE_NOT_THEN ASSUME_TAC >>
    `âˆ€u'.
          u' âˆˆ M'.frame.world /\ M'.frame.rel v' u' ==>
          (?form. DEG form <= i /\ satis M u form /\ Â¬satis M' u' form)`
        by (rw[satis_def] >>
	   `âˆƒphi. DEG phi â‰¤ i âˆ§ (satis M u phi â‡Ž satis M' u' phi)` by metis_tac[] >>
	   Cases_on `satis M u phi` >- (qexists_tac `phi` >> metis_tac[])
	                            >- (qexists_tac `NOT phi` >> rw[]
				                                >- metis_tac[DEG_def]
								>> metis_tac[satis_def])) >>
								
    qabbrev_tac `
      s = {f | DEG f <= i /\ ?u'. u' IN M'.frame.world /\
               M'.frame.rel v' u' /\ satis M u f /\ Â¬satis M' u' f}` >>
   `s âŠ† {f| DEG f <= i}` by (fs[Abbr`s`,SUBSET_DEF]) >>
   `(equiv0 (Î¼:'c itself)) equiv_on {f | DEG f â‰¤ i}` by metis_tac[equiv0_equiv_on] >>
   `FINITE (partition (equiv0 Î¼) s)`
       by (`FINITE {f | DEG f <= i}//e` by metis_tac[prop_2_29] >>
          `(equiv0 Î¼) equiv_on {f | DEG f â‰¤ i}` by metis_tac[equiv0_equiv_on] >>
	  `equiv0 (:'c) = equiv0 (:'b)` by metis_tac[equiv0_equal_for_INFINITE_UNIV] >>
	  metis_tac[prop_2_29,FINITE_partition_SUBSET]) >>
   `FINITE (IMAGE CHOICE (s//E Î¼))` by metis_tac[IMAGE_FINITE] >>
   `(equiv0 Î¼) equiv_on s` by metis_tac[equiv0_equiv_on] >> 
   `!p. p IN (s//E Î¼) ==> p <> {}` by metis_tac[EMPTY_NOT_IN_partition] >>
   `!p. p IN (s//E Î¼) ==> (CHOICE p) IN p` by metis_tac[CHOICE_DEF] >>
   `!f. f IN (IMAGE CHOICE (s//E Î¼)) ==> DEG f <= i`
     by (dsimp[] >> rw[] >> `(CHOICE x) IN x` by metis_tac[] >>
         `x SUBSET s` by fs[partition_def,SUBSET_DEF] >>
         `(CHOICE x) IN s` by metis_tac[SUBSET_DEF, partition_def] >>
         fs[Abbr`s`]) >>
   `âˆƒff.
        DEG ff â‰¤ i âˆ§
        âˆ€w:'c M.
           w âˆˆ M.frame.world â‡’ (satis M w ff â‡” (âˆ€f. f âˆˆ (IMAGE CHOICE (s//E Î¼)) â‡’ satis M w f))` by fs[BIGCONJ_EXISTS_DEG] >>
   `âˆ€f. f âˆˆ IMAGE CHOICE (s//E Î¼) â‡’ satis M u f`
     by (rw[] >>
        `(CHOICE x) IN x` by metis_tac[] >>
	fs[partition_def,Abbr`s`] >> rw[] >> fs[]) >>
   `satis M u ff` by metis_tac[] >> (*???????????????????????????????????????????? *)
   `satis M v (DIAM ff)` by metis_tac[satis_def] >>
   `DEG (DIAM ff) <= i + 1` by fs[DEG_def] >>
   `Â¬satis M' v' (DIAM ff)` suffices_by metis_tac[] >>
   `âˆ€u'. M'.frame.rel v' u' /\ u' âˆˆ M'.frame.world ==> Â¬satis M' u' ff`
      suffices_by metis_tac[satis_def] >>
   rw[partition_def,PULL_EXISTS] >>
   `âˆƒform. DEG form â‰¤ i âˆ§ satis M u form âˆ§ Â¬satis M' u' form` by metis_tac[] >>
   `form IN s` by (fs[Abbr`s`] >> qexists_tac `u'` >> rw[]) >>
   rw[] >>
   `equiv0 Î¼ form form` by metis_tac[equiv0_REFL] >> `form IN {y | y âˆˆ s âˆ§ equiv0 Î¼ form y}` by fs[] >>
   `{y | y âˆˆ s âˆ§ equiv0 Î¼ form y} <> {}` by metis_tac[MEMBER_NOT_EMPTY] >>
   `(CHOICE {y | y âˆˆ s âˆ§ equiv0 Î¼ form y}) IN {y | y âˆˆ s âˆ§ equiv0 Î¼ form y}` by metis_tac[CHOICE_DEF] >>
   fs[] >>
   `?f. (âˆƒx. f = CHOICE x âˆ§ x âˆˆ s//e) /\ satis M' u' f)` suffices_by metis_tac
   metis_tac[equiv0_SYM,equiv0_def])
>- (SPOSE_NOT_THEN ASSUME_TAC >>
   `?u. u IN M.frame.world /\ M.frame.rel v u` by 
   (`Â¬(!u. u IN M.frame.world ==> Â¬M.frame.rel v u)` suffices_by metis_tac[] >>
   rpt strip_tac >>
   `satis M v (BOX FALSE)` by metis_tac[box_vac_true] >>
   `satis M v (NOT (DIAM TRUE))` by metis_tac[BOX_def,TRUE_def,satis_def] >>
   `Â¬(satis M v (DIAM TRUE))` by metis_tac[satis_def] >>
   `satis M' v' (DIAM TRUE)` by metis_tac[diam_exist_true] >>
   `DEG (DIAM TRUE) <= i + 1` by fs[TRUE_def,DEG_def] >>
   metis_tac[]) >> 
   `u IN {u | u âˆˆ M.frame.world âˆ§ M.frame.rel v u}` by simp[] >>
   `âˆ€u.
          u âˆˆ M.frame.world â‡’ M.frame.rel v u ==>
          Â¬(âˆ€form. DEG form <= i ==> (satis M' u' form â‡” satis M u form))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          Â¬(âˆ€form. DEG form <= i ==> (satis M' u' form â‡” satis M u form))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          Â¬(âˆ€form. DEG form <= i ==> (Â¬(Â¬(satis M' u' form â‡” satis M u form))))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          (?form. DEG form <= i /\ Â¬(satis M' u' form â‡” satis M u form))` by metis_tac[] >>
   `âˆ€u.
          u âˆˆ M.frame.world /\ M.frame.rel v u ==>
          (?form. DEG form <= i /\ satis M' u' form /\ Â¬satis M u form)` by
       (rw[] >>
       last_x_assum drule >> rw[] >> 
       Cases_on `satis M u'' phi`
       >- (`Â¬satis M' u' phi` by metis_tac[] >> qexists_tac `Â¬phi` >> rw[satis_def,DEG_def])
       >- (`satis M' u' phi` by metis_tac[] >> qexists_tac `phi` >> rw[])) >> 
   qabbrev_tac `s = {f | DEG f <= i /\ ?u. u IN M.frame.world /\ M.frame.rel v u /\ satis M' u' f /\ Â¬satis M u f}` >>
   `s âŠ† {f| DEG f <= i}` by (fs[Abbr`s`,SUBSET_DEF]) >>
   `equiv0 equiv_on {f | DEG f â‰¤ i}` by metis_tac[equiv0_equiv_on] >>
   `FINITE s//e` by metis_tac[prop_2_29,FINITE_partition_SUBSET] >>
   `FINITE (IMAGE CHOICE s//e)` by
   (`equiv0 equiv_on s` by metis_tac[equiv0_equiv_on] >>
   `BIJ CHOICE s//e (IMAGE CHOICE s//e)` by metis_tac[CHOICE_BIJ_partition] >>
   metis_tac[FINITE_BIJ]) >>
   `equiv0 equiv_on s` by metis_tac[equiv0_equiv_on] >> 
   `!p. p IN s//e ==> p <> {}` by metis_tac[EMPTY_NOT_IN_partition] >>
   `!p. p IN s//e ==> (CHOICE p) IN p` by metis_tac[CHOICE_DEF] >>
   `!f. f IN (IMAGE CHOICE s//e) ==> DEG f <= i` by
   (fs[IMAGE_DEF] >> rw[] >> `(CHOICE x) IN x` by metis_tac[] >>
   `x SUBSET s` by fs[partition_def,SUBSET_DEF] >>
   `(CHOICE x) IN s` by metis_tac[SUBSET_DEF] >>
   fs[Abbr`s`]) >>
   `âˆƒff.
        DEG ff â‰¤ i âˆ§
        âˆ€w M.
           w âˆˆ M.frame.world â‡’ (satis M w ff â‡” âˆ€f. f âˆˆ (IMAGE CHOICE s//e) â‡’ satis M w f)` by fs[BIGCONJ_EXISTS_DEG] >>
   `âˆ€f. f âˆˆ IMAGE CHOICE s//e â‡’ satis M' u' f` by
   (rw[IMAGE_DEF] >>
   `x <> {}` by metis_tac[EMPTY_NOT_IN_partition] >>
   `(CHOICE x) IN x` by metis_tac[CHOICE_DEF] >> fs[partition_def,Abbr`s`] >> rw[] >> fs[]) >>
   `satis M' u' ff` by metis_tac[] >>
   `satis M' v' (DIAM ff)` by metis_tac[satis_def] >>
   `DEG (DIAM ff) <= i + 1` by fs[DEG_def] >>
   `Â¬satis M v (DIAM ff)` suffices_by metis_tac[] >> simp[satis_def] >>
   `!v''. M.frame.rel v v'' /\ v'' IN M.frame.world ==> Â¬satis M v'' ff` suffices_by metis_tac[satis_def] >> rw[] >>
   simp[PULL_EXISTS] >>
   `âˆƒform. DEG form â‰¤ i âˆ§ satis M' u' form âˆ§ Â¬satis M v'' form` by metis_tac[] >>
   rw[partition_def,PULL_EXISTS] >>
   `form IN s` by (fs[Abbr`s`] >> qexists_tac `v''` >> rw[]) >>
   qexists_tac `form` >> rw[] >>
   `equiv0 form form` by metis_tac[equiv0_REFL] >> `form IN {y | y âˆˆ s âˆ§ equiv0 form y}` by fs[] >>
   `{y | y âˆˆ s âˆ§ equiv0 form y} <> {}` by metis_tac[MEMBER_NOT_EMPTY] >>
   `(CHOICE {y | y âˆˆ s âˆ§ equiv0 form y}) IN {y | y âˆˆ s âˆ§ equiv0 form y}` by metis_tac[CHOICE_DEF] >>
   fs[] >> 
   metis_tac[equiv0_SYM,equiv0_def]));

*)


val (heightLE_rules, heightLE_ind, heightLE_cases) = Hol_reln`
  (!n. heightLE (M:('a,'b) model) x (M':('a,'b) model) x n) /\
  (!v. v IN M.frame.world /\ (?w. w IN M.frame.world /\ M.frame.rel w v /\ heightLE M x M' w n) ==>
       heightLE M x M' v (n + 1))
`;


val height_def = Define`height M x M' w = MIN_SET {n | heightLE M x M' w n}`;
                        
val model_height_def = Define`
model_height (M:('a,'b) model) x (M':('a,'b) model) = MAX_SET {n | ?w. w IN M.frame.world /\ height M x M' w = n}`;


val hrestriction_def = Define`
hrestriction M x M' n =
  <| frame := <| world := {w | w IN M.frame.world /\ height M x M' w <= n};
                 rel := Î»n1 n2. M.frame.rel n1 n2 |>;
     valt := Î»phi n. M.valt phi n |>`;

val heightLE_rel = store_thm(
  "heightLE_rel",
  ``!w n. heightLE M x M' w n ==> w IN M.frame.world /\ rooted_model M x M' ==> (!w'. M.frame.rel w w' /\ w' IN M.frame.world ==> heightLE M x M' w' (n + 1))``,
  Induct_on `heightLE` >> rw[]
  >- (rw[Once heightLE_cases] >>
     `âˆƒw. w âˆˆ M.frame.world âˆ§ M.frame.rel w w' âˆ§ heightLE M x M' w n` suffices_by metis_tac[] >>
     qexists_tac `x` >> rw[] >> metis_tac[heightLE_cases])
  >- (`heightLE M x M' w (n + 1)` by metis_tac[] >>
     rw[Once heightLE_cases] >>
     `âˆƒn'.
     n + 2 = n' + 1 âˆ§
     âˆƒw. w âˆˆ M.frame.world âˆ§ M.frame.rel w w'' âˆ§ heightLE M x M' w n'` suffices_by metis_tac[] >>
     qexists_tac `n + 1` >> rw[] >> qexists_tac `w` >> rw[]));

val heightLE_RTC = store_thm(
  "heightLE_RTC",
  ``!w n. heightLE M x M' w n ==>
  rooted_model M x M' ==> (RESTRICT M'.frame.rel M'.frame.world)^* x w``,
  Induct_on `heightLE` >> rw[] >>
  `(RESTRICT M'.frame.rel M'.frame.world)^* x w'` by metis_tac[] >>
  `RESTRICT M'.frame.rel M'.frame.world w' w` suffices_by metis_tac[RTC_CASES2] >>
  metis_tac[RESTRICT_def,rooted_model_def]);



val rooted_have_height = store_thm(
  "rooted_have_height",
  ``!x w. (RESTRICT M'.frame.rel M'.frame.world)^* x w ==> rooted_model M x M' /\ w IN M'.frame.world ==>
    ?n. heightLE M x M' w n``,
  ho_match_mp_tac RTC_INDUCT_RIGHT1 >> rw[]
  >- (qexists_tac `0` >> rw[Once heightLE_cases])
  >- (`w IN M'.frame.world` by metis_tac[RESTRICT_def] >>
     `âˆƒn. heightLE M x M' w n` by metis_tac[] >>
     qexists_tac `n + 1` >> rw[Once heightLE_cases] >>
     `w' IN M.frame.world`
         by (`(RESTRICT M'.frame.rel M'.frame.world)^* x w` by metis_tac[heightLE_RTC] >>
	     `(RESTRICT M'.frame.rel M'.frame.world)^* x w'` by metis_tac[RTC_CASES2] >>
	     metis_tac[rooted_model_def]) >>
     `âˆƒw. w âˆˆ M.frame.world âˆ§ M.frame.rel w w' âˆ§ heightLE M x M' w n` suffices_by metis_tac[] >>
     qexists_tac `w` >> rw[]
     >- (`(RESTRICT M'.frame.rel M'.frame.world)^* x w` by
        metis_tac[heightLE_RTC] >>
        metis_tac[rooted_model_def])
     >- (`w IN M.frame.world` suffices_by metis_tac[rooted_model_def] >>
	`(RESTRICT M'.frame.rel M'.frame.world)^* x w` suffices_by metis_tac[rooted_model_def] >>
	metis_tac[heightLE_RTC])));

val rooted_have_height_applied = store_thm(
  "rooted_have_height_applied",
  ``!x w. rooted_model M x M' /\ w IN M.frame.world ==>
  {n| heightLE M x M' w n} <> {}``,
  rw[] >>
  `(RESTRICT M'.frame.rel M'.frame.world)^* x w /\ w IN M'.frame.world` by
  metis_tac[rooted_model_def] >>
  `?n. heightLE M x M' w n` by metis_tac[rooted_have_height] >>
  `n IN {n | heightLE M x M' w n}` by fs[] >>
  metis_tac[MEMBER_NOT_EMPTY]);

val heightLE_MIN_SET_IN = store_thm(
  "heightLE_MIN_SET_IN",
  ``!x w. rooted_model M x M' /\ w IN M.frame.world ==>
  MIN_SET {n| heightLE M x M' w n} IN {n| heightLE M x M' w n}``,
  rpt strip_tac >>
  `{n| heightLE M x M' w n} <> {}` by metis_tac[rooted_have_height_applied] >> 
  metis_tac[MIN_SET_LEM]);
  


val height_heightLE = store_thm(
  "height_heightLE",
  ``!M x M' w n. rooted_model M x M' ==> 
  w IN M.frame.world ==> height M x M' w = n ==> heightLE M x M' w n``,
  rpt strip_tac >>
  fs[height_def] >>
  `w âˆˆ M'.frame.world âˆ§
  (RESTRICT M'.frame.rel M'.frame.world)^* x w` by metis_tac[rooted_model_def] >>
  `?n. heightLE M x M' w n` by metis_tac[rooted_have_height] >>
  `n' IN {n | heightLE M x M' w n}` by fs[] >>
  `{n | heightLE M x M' w n} <> {}` by metis_tac[MEMBER_NOT_EMPTY] >>
  `(MIN_SET {n | heightLE M x M' w n}) IN {n | heightLE M x M' w n}` by metis_tac[MIN_SET_LEM] >>
  fs[] >> rw[]);

val lemma_2_33 = store_thm(
  "lemma_2_33",
  ``!M x M' k. rooted_model M x M' ==>
  !w. w IN (hrestriction M x M' k).frame.world ==> ?f. nbisim (hrestriction M x M' k) M f (k - height M x M' w) w w``,
rw[] >> qexists_tac `Î»n w1 w2. w1 = w2 /\ height M x M' w1 <= k - n` >> rw[nbisim_def] (* 9 *)
>- fs[hrestriction_def]
>- (`height M x M' w <= k` by fs[hrestriction_def] >>
   `k - (k âˆ’ height M x M' w) = height M x M' w` by fs[] >>
   fs[])
>- fs[satis_def,hrestriction_def,IN_DEF]
>- fs[hrestriction_def]
>- fs[hrestriction_def]
>- (fs[hrestriction_def,height_def] >>
   `(RESTRICT M'.frame.rel M'.frame.world)^* x w1'` by metis_tac[rooted_model_def] >>
   `w1' IN M'.frame.world` by metis_tac[rooted_model_def] >>
   `{n | heightLE M x M' w1' n} <> {}`
       by (`?n. heightLE M x M' w1' n` by metis_tac[rooted_have_height] >>
          `n' IN {n | heightLE M x M' w1' n}` by fs[] >>
	  metis_tac[MEMBER_NOT_EMPTY]) >>
   `{n | heightLE M x M' w2 n} <> {}`
       by (`w2 IN M'.frame.world` by metis_tac[rooted_model_def] >>
          `(RESTRICT M'.frame.rel M'.frame.world)^* x w2` by metis_tac[rooted_model_def] >>
          `?n. heightLE M x M' w2 n` by metis_tac[rooted_have_height] >>
          `n' IN {n | heightLE M x M' w2 n}` by fs[] >>
	  metis_tac[MEMBER_NOT_EMPTY]) >>
   `(MIN_SET {n | heightLE M x M' w2 n}) IN {n | heightLE M x M' w2 n}` by metis_tac[MIN_SET_LEM] >>
   fs[] >>
   `heightLE M x M' w1' ((MIN_SET {n | heightLE M x M' w2 n}) + 1)`
       by (rw[Once heightLE_cases] >> metis_tac[]) >>
   `(MIN_SET {n | heightLE M x M' w2 n} + 1) IN
   {n | heightLE M x M' w1' n}` by fs[] >>
   `(MIN_SET {n | heightLE M x M' w1' n}) <=
   (MIN_SET {n | heightLE M x M' w2 n} + 1)` by metis_tac[MIN_SET_LEM] >>
   qabbrev_tac `a = MIN_SET {n | heightLE M x M' w2 n}` >>
   qabbrev_tac `b = MIN_SET {n | heightLE M x M' w1' n}` >>
   `b <= k âˆ’ (n + 1) + 1` by fs[] >>
   `k > n` suffices_by rw[] >>
   `k - n >= 1` suffices_by fs[] >>
   fs[])
>- (fs[hrestriction_def] >>
   `k > n`
       by (`k - n >= 1` suffices_by fs[] >> fs[]) >>
   `k - (n + 1) + 1 = k - n` by fs[] >>
   `height M x M' w2' <= k - n` suffices_by fs[] >>
   fs[height_def] >>
   qabbrev_tac `a = MIN_SET {n | heightLE M x M' w2 n}` >>
   qabbrev_tac `b = MIN_SET {n | heightLE M x M' w2' n}` >>
   `a IN {n | heightLE M x M' w2 n}` by metis_tac[Abbr`a`,heightLE_MIN_SET_IN] >>
   fs[] >>
   `heightLE M x M' w2' (a + 1)` by metis_tac[heightLE_rel] >>
   `(a + 1) IN {n | heightLE M x M' w2' n}` by fs[] >>
   `{n | heightLE M x M' w2' n} <> {}` by metis_tac[rooted_have_height_applied] >> 
   `b <= a + 1` by metis_tac[Abbr`b`,MIN_SET_LEM] >>
   fs[])
>- fs[hrestriction_def]
>- (fs[hrestriction_def,height_def] >>
   qabbrev_tac `a = MIN_SET {n | heightLE M x M' w2 n}` >>
   qabbrev_tac `b = MIN_SET {n | heightLE M x M' w2' n}` >>
   `b <= a + 1`
       by (`{n | heightLE M x M' w2 n} <> {}` by metis_tac[rooted_have_height_applied] >>
          `a IN {n | heightLE M x M' w2 n}` by metis_tac[Abbr`b`,MIN_SET_LEM] >>
	  fs[] >>
	  `heightLE M x M' w2' (a + 1)` by metis_tac[heightLE_rel] >>
	  `{n | heightLE M x M' w2' n} <> {}` by metis_tac[rooted_have_height_applied] >>
	  `(a + 1) IN {n | heightLE M x M' w2' n}` by fs[] >>
	  metis_tac[Abbr`b`,MIN_SET_LEM]) >>
   `k > n`
       by (`k - n >= 1` suffices_by fs[] >> fs[]) >> fs[]));



(* incompleted construction of thm 2.34


val point_GENSUBMODEL_def = Define`
  point_GENSUBMODEL M w =
   <| frame := <| world := {v | v IN M.frame.world /\ (RESTRICT M.frame.rel M.frame.world)^* w v };
rel := Î»w1 w2. w1 IN M.frame.world /\ w2 IN M.frame.world /\ M.frame.rel w1 w2|>;
          valt := M.valt |>`;

val point_GENSUBMODEL_GENSUBMODEL = store_thm(
  "point_GENSUBMODEL_GENSUBMODEL",
  ``!M w. w IN M.frame.world ==> GENSUBMODEL (point_GENSUBMODEL M w) M``,
  rw[GENSUBMODEL_def,point_GENSUBMODEL_def] (* 2 *)
  >- (rw[SUBMODEL_def] >> fs[SUBSET_DEF])
  >- (simp[Once RTC_CASES2] >>
     `âˆƒu. (RESTRICT M.frame.rel M.frame.world)^* w u âˆ§ RESTRICT M.frame.rel M.frame.world u w2` suffices_by metis_tac[] >>
     qexists_tac `w1` >> simp[Once RESTRICT_def]));


val point_GENSUBMODEL_rooted = store_thm(
  "point_GENSUBMODEL_rooted",
  ``!M w. w IN M.frame.world ==> rooted_model (point_GENSUBMODEL M w) w M``,
  rw[rooted_model_def] >> eq_tac >> rw[] (* 7 *)
  >- fs[point_GENSUBMODEL_def]
  >- fs[point_GENSUBMODEL_def]
  >- fs[point_GENSUBMODEL_def]
  >- (fs[point_GENSUBMODEL_def] >> metis_tac[RESTRICT_def])
  >- (fs[point_GENSUBMODEL_def] >> metis_tac[RESTRICT_def])
  >- fs[point_GENSUBMODEL_def]
  >- fs[point_GENSUBMODEL_def]);

val point_GENSUBMODEL_satis = store_thm(
  "point_GENSUBMODEL_satis",
  ``!M w f. satis M w f ==> satis (point_GENSUBMODEL M w) w f``,
  rw[] >>
  `w IN M.frame.world` by metis_tac[satis_in_world] >>
  `GENSUBMODEL (point_GENSUBMODEL M w) M` by metis_tac[point_GENSUBMODEL_GENSUBMODEL] >>
  `(RESTRICT M.frame.rel M.frame.world)^* w w` by metis_tac[RTC_CASES2] >>
  `w IN (point_GENSUBMODEL M w).frame.world` by fs[point_GENSUBMODEL_def] >>
  metis_tac[prop_2_6]);


val root_height_0 = store_thm(
  "root_height_0",
  ``!M x M'. rooted_model M x M' ==> height M x M' x = 0``,
  rw[Once heightLE_cases,height_def] >>
  `0 IN ð•Œ(:num)` by fs[] >>
  `ð•Œ(:num) <> {}` by fs[] >>
  `MIN_SET ð•Œ(:num) <= 0` by metis_tac[MIN_SET_LEM] >> fs[]);


 

val thm_2_34 = store_thm( 
  "thm_2_34",
  ``!M w phi. satis M w phi ==> ?FM v. FINITE (FM.frame.world) /\ v IN FM.frame.world /\ satis FM v phi``,
  rw[] >>
  qabbrev_tac `k = DEG phi` >>
  `satis (point_GENSUBMODEL M w) w phi` by metis_tac[point_GENSUBMODEL_satis] >>
  qabbrev_tac `M2 = (point_GENSUBMODEL M w)` >>
  qabbrev_tac `M3 = hrestriction M2 w M k` >>
  `w IN M.frame.world` by metis_tac[satis_in_world] >>
  `rooted_model M2 w M` by metis_tac[point_GENSUBMODEL_rooted,Abbr`M2`] >>
  `w IN M3.frame.world`
      by (fs[Abbr`M3`,hrestriction_def] >> fs[point_GENSUBMODEL_def,Abbr`M2`] >>
          `height
            <|frame :=
                     <|world :=
                      {v |
                          v âˆˆ M.frame.world âˆ§
                          (RESTRICT M.frame.rel M.frame.world)^* w v};
              rel :=
                   (Î»w1 w2.
                    w1 âˆˆ M.frame.world âˆ§ w2 âˆˆ M.frame.world âˆ§
                     M.frame.rel w1 w2)|>; valt := M.valt|> w M w = 0` by metis_tac[root_height_0] >> fs[]) >>
   `âˆƒf. nbisim M3 M2 f (k âˆ’ height M2 w M w) w w`
       by (fs[Abbr`M3`] >> irule lemma_2_33 >> (* 2 *) rw[] >>
          `height M2 w M w = 0` by metis_tac[root_height_0] >> fs[] >>
          `DEG phi <= k` by fs[] >>
          `satis M3 w phi` by metis_tac[prop_2_31_half1]) >>
   qabbrev_tac `s = {a | (VAR a) IN subforms phi}` >>
   `FINITE s`
       by (fs[Abbr`s`] >>
          `FINITE (subforms phi)` by metis_tac[subforms_FINITE] >>
	  `INJ VAR {a | VAR a âˆˆ subforms phi} (subforms phi)` suffices_by metis_tac[FINITE_INJ] >>
	  rw[INJ_DEF]) >>
   drule prop_2_29_strengthen >> rw[] >>
   `satis M3 w phi`
       by (`height M2 w M w = 0` by metis_tac[root_height_0] >> fs[Abbr`k`] >>
           `DEG phi <= DEG phi` by fs[] >> metis_tac[prop_2_31_half1]) >>
   `FINITE {f | DEG f â‰¤ k âˆ§ âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s}//e` by metis_tac[] >>
   `FINITE (IMAGE CHOICE {f | DEG f â‰¤ k âˆ§ âˆ€a. VAR a âˆˆ subforms f â‡’ a âˆˆ s}//e)` by metis_tac[FINITE_BIJ,CHOICE_BIJ_partition,equiv0_equiv_on] >>
   
   `qabbrev_tac `ss = PRIM_REC_FUN {w} \s n. `
   
   
                 
   
   
  



*)

*)

*)



(* finite model property via filtration *)

val CUS_def = Define`
CUS Î£ <=> !f f'. ((DISJ f f') IN Î£ ==> f IN Î£ /\ f' IN Î£) /\
                 ((NOT f) IN Î£ ==> f IN Î£) /\
                 ((DIAM f) IN Î£ ==> f IN Î£)`;


val REL_CUS_def = Define`
REL_CUS Î£ M = Î»w v. w IN M.frame.world /\
                    v IN M.frame.world /\
                    (!phi. phi IN Î£ ==> (satis M w phi <=> satis M v phi))`;

val EC_CUS_def = Define`
EC_CUS Î£ M w = {v | (REL_CUS Î£ M) w v}`;

val EC_REP_def = Define`
EC_REP Î£ M w = CHOICE (EC_CUS Î£ M w)`;

val EC_REP_SET_def = Define`
EC_REP_SET Î£ M = {n | ?w. w IN M.frame.world /\ n = EC_REP Î£ M w}`;

val IN_EC_CUS_IN_world = store_thm(
"IN_EC_CUS_IN_world",
``!x. x IN EC_CUS Î£ M w ==> x IN M.frame.world``,
rpt strip_tac >> fs[EC_CUS_def,REL_CUS_def]);

val SAME_EC_SAME_tau = store_thm(
"SAME_EC_SAME_tau",
``!a b w. a IN EC_CUS Î£ M w /\ b IN EC_CUS Î£ M w ==> (!phi. phi IN Î£ ==> (satis M a phi <=> satis M b phi))``,
rpt strip_tac >> fs[EC_CUS_def,REL_CUS_def]);



val REL_CUS_SYMM = store_thm(
"REL_CUS_SYMM",
``!w v. REL_CUS Î£ M w v <=> REL_CUS Î£ M v w``,
rpt strip_tac >> eq_tac >> strip_tac
>> fs[REL_CUS_def]);

val REL_CUS_REFL = store_thm(
"REL_CUS_REFL",
``!w. w IN M.frame.world ==> REL_CUS Î£ M w w``,
gen_tac >> fs[REL_CUS_def]);

val REL_CUS_TRANS = store_thm(
"REL_CUS_TRANS",
``!u v w. u IN M.frame.world /\ v IN M.frame.world /\ w IN M.frame.world /\ REL_CUS Î£ M u v /\ REL_CUS Î£ M u w ==> REL_CUS Î£ M v w``,
rpt strip_tac >> rw[REL_CUS_def] >>
`satis M u phi <=> satis M v phi` by metis_tac[REL_CUS_def] >>
`satis M u phi <=> satis M w phi` by metis_tac[REL_CUS_def] >> metis_tac[]);

val REL_EC = store_thm(
"REL_EC",
``!w v. w IN M.frame.world /\ v IN M.frame.world ==> (REL_CUS Î£ M) w v ==> (EC_CUS Î£ M w = EC_CUS Î£ M v)``,
rpt strip_tac >> simp[SET_EQ_SUBSET,SUBSET_DEF] >> rpt strip_tac
>- (`REL_CUS Î£ M v x` suffices_by fs[EC_CUS_def] >>
`REL_CUS Î£ M w x` by fs[EC_CUS_def] >>
`x IN M.frame.world` by fs[REL_CUS_def] >>
metis_tac[REL_CUS_TRANS])
>- (`REL_CUS Î£ M w x` suffices_by fs[EC_CUS_def] >>
`REL_CUS Î£ M v x` by fs[EC_CUS_def] >>
`x IN M.frame.world` by fs[REL_CUS_def] >> metis_tac[REL_CUS_SYMM,REL_CUS_TRANS]));

val EC_NOT_EMPTY = store_thm(
"EC_NOT_EMPTY",
``!w. w IN M.frame.world ==> EC_CUS Î£ M w <> {}``,
rpt strip_tac >>
`w IN EC_CUS Î£ M w` suffices_by metis_tac[MEMBER_NOT_EMPTY,EC_CUS_def] >>
`(REL_CUS Î£ M) w w` by metis_tac[REL_CUS_REFL] >>
`w IN {v | (REL_CUS Î£ M) w v}` by simp[] >> metis_tac[EC_CUS_def]);

val REP_IN_world = store_thm(
  "REP_IN_world",
  ``w IN M.frame.world ==> EC_REP Î£ M w IN M.frame.world``,
  rpt strip_tac >>
  fs[EC_REP_def,EC_CUS_def,REL_CUS_def] >>
  `(CHOICE {v | v âˆˆ M.frame.world âˆ§ âˆ€phi. phi âˆˆ Î£ â‡’ (satis M w phi â‡” satis M v phi)}) IN
  {v | v âˆˆ M.frame.world âˆ§ âˆ€phi. phi âˆˆ Î£ â‡’ (satis M w phi â‡” satis M v phi)}`
    by (`{v | v âˆˆ M.frame.world âˆ§ âˆ€phi. phi âˆˆ Î£ â‡’ (satis M w phi â‡” satis M v phi)} <> {}`
            suffices_by metis_tac[CHOICE_DEF] >>
        `w IN {v | v âˆˆ M.frame.world âˆ§ âˆ€phi. phi âˆˆ Î£ â‡’ (satis M w phi â‡” satis M v phi)}`
	    suffices_by metis_tac[MEMBER_NOT_EMPTY] >> fs[]) >>
  fs[]);


val REP_IN_EC = store_thm(
  "REP_IN_EC",
  ``!w. w IN M.frame.world ==> (EC_REP Î£ M w) IN (EC_CUS Î£ M w)``,
  rw[] >> `EC_CUS Î£ M w <> {}` by metis_tac[EC_NOT_EMPTY] >> metis_tac[EC_REP_def,CHOICE_DEF]);


val RESTRICT_tau_theory = Define`
RESTRICT_tau_theory Î£ M w = {phi | phi IN Î£ /\ satis M w phi}`;

val ELEM_IN_EC = store_thm(
"ELEM_IN_EC",
``!n. n IN M.frame.world ==> n IN EC_CUS Î£ M n``,
rpt strip_tac >>
`(REL_CUS Î£ M) n n` by metis_tac[REL_CUS_REFL] >>
`n IN {v | (REL_CUS Î£ M) n v}` by simp[] >> metis_tac[EC_CUS_def]);

val REP_W_SAME_tau = store_thm(
"REP_W_SAME_tau",
``!phi w. (phi IN Î£ /\ w IN M.frame.world) ==> (satis M (EC_REP Î£ M w) phi <=> satis M w phi)``,
rpt strip_tac >>
`(EC_REP Î£ M w) IN (EC_CUS Î£ M w) /\ w IN (EC_CUS Î£ M w)` suffices_by metis_tac[SAME_EC_SAME_tau] >> metis_tac[REP_IN_EC,ELEM_IN_EC]);

val EC_tau = store_thm(
"EC_tau",
``!n1 n2. n1 IN M.frame.world /\ n2 IN M.frame.world ==> (EC_CUS Î£ M n1 = EC_CUS Î£ M n2 ==>
RESTRICT_tau_theory Î£ M n1 = RESTRICT_tau_theory Î£ M n2)``,
rpt strip_tac >> simp[SET_EQ_SUBSET] >> simp[SUBSET_DEF] >> rpt strip_tac
>> simp[RESTRICT_tau_theory] >>
fs[RESTRICT_tau_theory] >>
`EC_CUS Î£ M n1 âŠ† EC_CUS Î£ M n2` by simp[SET_EQ_SUBSET] >> fs[SUBSET_DEF] >>
`n1 IN EC_CUS Î£ M n1` by metis_tac[ELEM_IN_EC] >>
`n1 âˆˆ EC_CUS Î£ M n2` by metis_tac[] >>
`REL_CUS Î£ M n2 n1` by fs[EC_CUS_def] >>
metis_tac[REL_CUS_def]);

val tau_EC = store_thm(
"tau_EC",
``!n1 n2. n1 IN M.frame.world /\ n2 IN M.frame.world ==> (RESTRICT_tau_theory Î£ M n1 = RESTRICT_tau_theory Î£ M n2 ==> EC_CUS Î£ M n1 = EC_CUS Î£ M n2)``,
rpt strip_tac >> simp[SET_EQ_SUBSET] >> simp[SUBSET_DEF] >> rpt strip_tac
>- (simp[EC_CUS_def] >> simp[REL_CUS_def] >>
`x IN M.frame.world` by fs[EC_CUS_def,REL_CUS_def] >> rw[] >> eq_tac >> strip_tac
  >- (`RESTRICT_tau_theory Î£ M n2  âŠ† RESTRICT_tau_theory Î£ M n1` by simp[SET_EQ_SUBSET] >>
     `phi IN RESTRICT_tau_theory Î£ M n2` by fs[RESTRICT_tau_theory] >>
     `phi IN RESTRICT_tau_theory Î£ M n1` by metis_tac[SUBSET_DEF] >>
     `satis M n1 phi` by fs[RESTRICT_tau_theory] >>
     `REL_CUS Î£ M n1 x` by fs[EC_CUS_def] >>
     metis_tac[REL_CUS_def])
  >- (`RESTRICT_tau_theory Î£ M n1  âŠ† RESTRICT_tau_theory Î£ M n2` by simp[SET_EQ_SUBSET] >> 
     `REL_CUS Î£ M n1 x` by fs[EC_CUS_def] >>
     `satis M n1 phi` by metis_tac[REL_CUS_def] >>
     fs[SUBSET_DEF] >> fs[RESTRICT_tau_theory]))
>- (simp[EC_CUS_def] >> simp[REL_CUS_def] >>
`x IN M.frame.world` by fs[EC_CUS_def,REL_CUS_def] >> rw[] >> eq_tac >> strip_tac
  >- (`REL_CUS Î£ M n2 x` by fs[EC_CUS_def] >>
     `RESTRICT_tau_theory Î£ M n1 âŠ† RESTRICT_tau_theory Î£ M n2` by metis_tac[SET_EQ_SUBSET] >> fs[SUBSET_DEF,RESTRICT_tau_theory] >>
     `satis M n2 phi` by metis_tac[] >>
     metis_tac[REL_CUS_def])
  >- (`REL_CUS Î£ M n2 x` by fs[EC_CUS_def] >>
     `RESTRICT_tau_theory Î£ M n2 âŠ† RESTRICT_tau_theory Î£ M n1` by metis_tac[SET_EQ_SUBSET] >> fs[SUBSET_DEF,RESTRICT_tau_theory] >>
     `satis M n2 phi` by metis_tac[REL_CUS_def] >>
     metis_tac[]))
);

val SAME_REP_SAME_tau = store_thm(
"SAME_REP_SAME_tau",
``w IN M.frame.world /\ w' IN M.frame.world /\ EC_REP Î£ M w = EC_REP Î£ M w' ==>
(!phi. phi IN Î£ ==> (satis M w phi <=> satis M w' phi))``,
rw[] >>
`EC_REP Î£ M w IN EC_CUS Î£ M w` by metis_tac[REP_IN_EC] >>
`w IN EC_CUS Î£ M w` by metis_tac[ELEM_IN_EC] >>
`(satis M w phi <=> satis M (EC_REP Î£ M w) phi)` by metis_tac[SAME_EC_SAME_tau] >>
`EC_REP Î£ M w' IN EC_CUS Î£ M w'` by metis_tac[REP_IN_EC] >>
`w' IN EC_CUS Î£ M w'` by metis_tac[ELEM_IN_EC] >>
`(satis M w' phi <=> satis M (EC_REP Î£ M w') phi)` by metis_tac[SAME_EC_SAME_tau] >>
metis_tac[]);

val SAME_REP_SAME_EC = store_thm(
"SAME_REP_SAME_EC",
``w IN M.frame.world /\ w' IN M.frame.world /\ EC_REP Î£ M w = EC_REP Î£ M w' ==> EC_CUS Î£ M w = EC_CUS Î£ M w'``,
rw[] >>
`(!phi. phi IN Î£ ==> (satis M w phi <=> satis M w' phi))` by metis_tac[SAME_REP_SAME_tau] >>
`RESTRICT_tau_theory Î£ M w = RESTRICT_tau_theory Î£ M w'` by
(fs[RESTRICT_tau_theory] >> simp[EXTENSION] >> rw[] >> eq_tac >> rw[] >> metis_tac[]) >>
metis_tac[tau_EC]);

val filtration_def = Define`
filtration M Î£ FLT <=>
CUS Î£ /\
(FLT.frame.world = EC_REP_SET Î£ M) /\
(!w v. w IN M.frame.world /\ v IN M.frame.world /\ M.frame.rel w v ==> FLT.frame.rel (EC_REP Î£ M w) (EC_REP Î£ M v)) /\
(!w v. w IN M.frame.world /\ v IN M.frame.world /\ FLT.frame.rel (EC_REP Î£ M w) (EC_REP Î£ M v) ==> (!phi psi. (phi IN Î£ /\ phi = DIAM psi) ==> (satis M v psi ==> satis M w phi))) /\
(!p s. FLT.valt p s <=> (?w. s = EC_REP Î£ M w /\ satis M w (VAR p)))`;

val FLT_M_world = store_thm(
"FLT_M_world",
``!w. filtration M Î£ FLT /\ w IN FLT.frame.world ==> w IN M.frame.world``,
rpt strip_tac >>
`w IN EC_REP_SET Î£ M` by metis_tac[filtration_def] >>
fs[EC_REP_SET_def] >> fs[EC_REP_def] >>
`EC_CUS Î£ M w' <> {}` by metis_tac[EC_NOT_EMPTY] >>
`(CHOICE (EC_CUS Î£ M w')) IN (EC_CUS Î£ M w')` by metis_tac[CHOICE_DEF] >>
`(EC_CUS Î£ M w') SUBSET M.frame.world` suffices_by fs[SUBSET_DEF] >>
rw[EC_CUS_def,REL_CUS_def] >> fs[SUBSET_DEF]);


val EC_CUS_SUBSET_W = store_thm(
"EC_CUS_SUBSET_W",
``!w. w IN M.frame.world ==> EC_CUS Î£ M w âŠ† M.frame.world``,
rpt strip_tac >> simp[SUBSET_DEF] >> rpt strip_tac >>
`REL_CUS Î£ M w x` by fs[EC_CUS_def] >> metis_tac[REL_CUS_def]);

val filtration_REP_REFL = store_thm(
"filtration_REP_REFL",
``filtration M Î£ FLT ==> (!w. w IN FLT.frame.world ==> w = CHOICE (EC_CUS Î£ M w))``,
rpt strip_tac >>
`w IN EC_REP_SET Î£ M` by metis_tac[filtration_def] >> fs[EC_REP_SET_def] >>
fs[EC_REP_def] >>
`EC_CUS Î£ M w' = EC_CUS Î£ M (CHOICE (EC_CUS Î£ M w'))` suffices_by metis_tac[] >>
`EC_CUS Î£ M w' <> {}` by metis_tac[EC_NOT_EMPTY] >>
`w IN (EC_CUS Î£ M w')` by metis_tac[CHOICE_DEF] >>
`w IN M.frame.world` by metis_tac[EC_CUS_SUBSET_W,SUBSET_DEF] >>
`REL_CUS Î£ M w' (CHOICE (EC_CUS Î£ M w'))` suffices_by metis_tac[REL_EC] >>
`!a. a IN (EC_CUS Î£ M w') ==> REL_CUS Î£ M w' a` by
(rpt strip_tac >> fs[EC_CUS_def]) >> metis_tac[]);

val prop_2_38_lemma = store_thm(
"prop_2_38_lemma",
``!Î£ M. FINITE Î£ /\ filtration M Î£ FLT ==> ?f. INJ f (FLT.frame.world) (POW Î£)``,
rpt strip_tac >>
qexists_tac `Î»w. RESTRICT_tau_theory Î£ M w` >> rw[INJ_DEF]
>- (rw[POW_DEF] >> rw[RESTRICT_tau_theory] >> simp[SUBSET_DEF])
>- (`w = CHOICE (EC_CUS Î£ M w)` by metis_tac[filtration_REP_REFL] >>
`w' = CHOICE (EC_CUS Î£ M w')` by metis_tac[filtration_REP_REFL] >>
`w IN M.frame.world` by metis_tac[FLT_M_world] >>
`w' IN M.frame.world` by metis_tac[FLT_M_world] >>
`EC_CUS Î£ M w = EC_CUS Î£ M w'` by metis_tac[tau_EC] >> metis_tac[]));


val prop_2_38 = store_thm(
"prop_2_38",
``!Î£ M FLT. FINITE Î£ /\ filtration M Î£ FLT ==> CARD (FLT.frame.world) <= 2 ** (CARD (Î£))``,
rpt strip_tac >>
`CARD (POW Î£) = 2 ** CARD Î£` by simp[CARD_POW] >>
`CARD FLT.frame.world â‰¤ CARD (POW Î£)` suffices_by rw[] >>
irule INJ_CARD
>- metis_tac[FINITE_POW]
>- metis_tac[prop_2_38_lemma]);

val thm_2_39 = store_thm(
"thm_2_39",
``!phi. phi IN Î£ ==> (!w. w IN M.frame.world /\ filtration M Î£ FLT ==> (satis M w phi <=> satis FLT (EC_REP Î£ M w) phi))``,
gen_tac >> strip_tac >> Induct_on `phi`
>- (rw[satis_def] >> eq_tac >> rpt strip_tac
  >- (`EC_REP Î£ M w âˆˆ EC_REP_SET Î£ M ` suffices_by metis_tac[filtration_def] >>
     fs[EC_REP_SET_def] >> qexists_tac `w` >> metis_tac[])
  >- (`FLT.valt a (EC_REP Î£ M w)` suffices_by fs[IN_DEF] >>
     `âˆƒw'. (EC_REP Î£ M w) = EC_REP Î£ M w' âˆ§ satis M w' (VAR a)` suffices_by fs[filtration_def] >>
     qexists_tac `w` >>
     metis_tac[satis_def,IN_DEF])
  >- (`FLT.valt a (EC_REP Î£ M w)` by fs[IN_DEF] >>
     `âˆƒw'. (EC_REP Î£ M w) = EC_REP Î£ M w' âˆ§ satis M w' (VAR a)` by metis_tac[filtration_def] >>
     `w' IN M.frame.world` by metis_tac[satis_def] >>
     `EC_CUS Î£ M w = EC_CUS Î£ M w'` by metis_tac[SAME_REP_SAME_EC] >>
     `w IN EC_CUS Î£ M w` by metis_tac[ELEM_IN_EC] >>
     `w' IN EC_CUS Î£ M w'` by metis_tac[ELEM_IN_EC] >>
     `w' IN EC_CUS Î£ M w` by metis_tac[] >>
     `satis M w (VAR a)` by metis_tac[SAME_EC_SAME_tau] >> metis_tac[satis_def,IN_DEF]))
>- (rw[satis_def] >> eq_tac >> rw[]
  >> `CUS Î£` by metis_tac[filtration_def] >> fs[CUS_def] >>
     `phi IN Î£ /\ phi' IN Î£` by metis_tac[] >> metis_tac[])
>- rw[satis_def]
>- (rw[satis_def] >> eq_tac >> rw[]
  >> `CUS Î£` by metis_tac[filtration_def] >> fs[CUS_def] >>
  `EC_REP Î£ M w IN EC_REP_SET Î£ M` by (fs[EC_REP_SET_def] >> qexists_tac `w` >> metis_tac[]) >>
  metis_tac[filtration_def])
>- (rw[satis_def] >> eq_tac >> rw[]
  >- (`EC_REP Î£ M w IN EC_REP_SET Î£ M` by (fs[EC_REP_SET_def] >> qexists_tac `w` >> metis_tac[]) >>
  metis_tac[filtration_def])
  >- (`M.frame.rel w v` by fs[IN_DEF] >>
     `FLT.frame.rel (EC_REP Î£ M w) (EC_REP Î£ M v)` by metis_tac[filtration_def] >>
     `EC_REP Î£ M v IN EC_REP_SET Î£ M` by (fs[EC_REP_SET_def] >> qexists_tac `v` >> metis_tac[]) >>
     `EC_REP Î£ M v IN FLT.frame.world` by metis_tac[filtration_def] >>
     qexists_tac `EC_REP Î£ M v` >> rw[] 
     >> (`CUS Î£` by metis_tac[filtration_def] >>
        `phi IN Î£` by metis_tac[CUS_def] >> metis_tac[]))
  >- (`CUS Î£` by metis_tac[filtration_def] >>
     `phi IN Î£` by metis_tac[CUS_def] >>
     `v IN EC_REP_SET Î£ M` by metis_tac[filtration_def] >>
     fs[EC_REP_SET_def] >>
     `satis M w' phi` by metis_tac[] >>
     `satis M w (DIAM phi)` suffices_by metis_tac[satis_def] >>
     `FLT.frame.rel (EC_REP Î£ M w) (EC_REP Î£ M w')` by fs[IN_DEF] >> metis_tac[filtration_def])));

val FLT_def = Define`
FLT M Î£ = <| frame := <| world := EC_REP_SET Î£ M ;
                         rel := Î»n1 n2.
                         ?w1 w2.
                         (w1 IN M.frame.world /\ w2 IN M.frame.world /\
                         n1 = EC_REP Î£ M w1 /\ n2 = EC_REP Î£ M w2 /\
                         ?w' v'. w' IN M.frame.world /\ v' IN M.frame.world /\
                         w' IN EC_CUS Î£ M w1 /\ v' IN EC_CUS Î£ M w2 /\ M.frame.rel w' v') |>;
             valt := Î»p s. âˆƒw. s = EC_REP Î£ M w âˆ§ satis M w (VAR p) |>`;
     
     
val FLT_EXISTS = store_thm(
"FLT_EXISTS",
``!M Î£. CUS Î£ ==> filtration M Î£ (FLT M Î£)``,
rw[filtration_def] >- fs[FLT_def]
>- (fs[FLT_def] >> map_every qexists_tac [`w`,`v`] >> rw[] >> map_every qexists_tac [`w`,`v`] >> rw[] >> metis_tac[ELEM_IN_EC])
>- (fs[FLT_def] >>
   `psi IN Î£` by fs[CUS_def] >>
   `satis M v psi â‡” satis M w2 psi` by metis_tac[SAME_REP_SAME_tau] >>
   `satis M v' psi â‡” satis M w2 psi` by (`w2 IN EC_CUS Î£ M w2` by metis_tac[ELEM_IN_EC] >> metis_tac[SAME_EC_SAME_tau]) >>
   `satis M v' psi` by metis_tac[] >>
   `satis M w' (DIAM psi)` by (rw[satis_def] >> qexists_tac `v'` >> fs[IN_DEF]) >>
   `satis M w (DIAM psi) â‡” satis M w1 (DIAM psi)` by metis_tac[SAME_REP_SAME_tau] >>
   `satis M w' (DIAM psi) â‡” satis M w1 (DIAM psi)` by (`w1 IN EC_CUS Î£ M w1` by metis_tac[ELEM_IN_EC] >> metis_tac[SAME_EC_SAME_tau]) >> metis_tac[])
>- fs[FLT_def]);





val subforms_phi_CUS = store_thm(
"subforms_phi_CUS",
``!phi. CUS (subforms phi)``,
rw[CUS_def] >> fs[subforms_def,UNION_DEF]
>- (`f IN (subforms (DISJ f f'))` by (fs[subforms_def] >> metis_tac[subforms_phi_phi]) >> metis_tac[subforms_trans])
>- (`f' IN (subforms (DISJ f f'))` by (fs[subforms_def] >> metis_tac[subforms_phi_phi]) >> metis_tac[subforms_trans])
>- (`f IN (subforms (NOT f))` by (fs[subforms_def] >> metis_tac[subforms_phi_phi]) >> metis_tac[subforms_trans])
>- (`f IN (subforms (DIAM f))` by (fs[subforms_def] >> metis_tac[subforms_phi_phi]) >> metis_tac[subforms_trans]));



val thm_2_41 = store_thm(
  "thm_2_41",
``!phi M w. satis M (w:'b) phi ==> ?M' w':'b. w' IN M'.frame.world /\ satis M' w' phi /\ FINITE (M'.frame.world)``,
rw[] >> qexists_tac `FLT M (subforms phi)` >> qexists_tac `EC_REP (subforms phi) M w` >> rw[]
>- (`w IN M.frame.world` by metis_tac[satis_in_world] >> fs[FLT_def,EC_REP_SET_def] >> qexists_tac `w` >> fs[])
>- (`CUS (subforms phi)` by metis_tac[subforms_phi_CUS] >>
   `filtration M (subforms phi) (FLT M (subforms phi))` by metis_tac[FLT_EXISTS] >>
   `phi IN (subforms phi)` by metis_tac[subforms_phi_phi] >>
   `w IN M.frame.world` by metis_tac[satis_in_world] >>
   metis_tac[thm_2_39])
>- (`CUS (subforms phi)` by metis_tac[subforms_phi_CUS] >>
   `filtration M (subforms phi) (FLT M (subforms phi))` by metis_tac[FLT_EXISTS] >>
   `FINITE (subforms phi)` by metis_tac[subforms_FINITE] >> 
   `CARD (FLT M (subforms phi)).frame.world â‰¤ 2 ** CARD (subforms phi)` by metis_tac[prop_2_38] >>
   drule_all (GEN_ALL prop_2_38_lemma) >> strip_tac >>
   imp_res_tac FINITE_INJ >> rfs[FINITE_POW]));
  

val _ = export_theory();