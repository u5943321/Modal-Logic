open HolKernel Parse boolLib bossLib;
open combinTheory;
open chap1Theory;
open pred_setTheory;
open relationTheory;
open arithmeticTheory;
open set_relationTheory;
open finite_mapTheory;
open chap1Theory;
open chap2_5Theory;

val _ = ParseExtras.tight_equality()

val _ = new_theory "chap2_4";

val _ = Datatype`
        folmodel = <| domain : 'a set ;
	              consts : num |-> 'a;
	              fnsyms : num -> 'a list -> 'a;
		      predsyms : 'p -> 'a -> bool;
		      relsyms : 'r -> 'a -> 'a -> bool;
		      |>`;

val mm2folm_def = Define`
  mm2folm M = <| domain := M.frame.world ;
                 consts := FEMPTY;
                 fnsyms := \x y. ARB;
		 predsyms := \p w. (w IN M.frame.world /\ M.valt p w);
		 relsyms := \ (u:unit) w1 w2. (M.frame.rel w1 w2 /\ w1 IN M.frame.world /\ w2 IN M.frame.world) |>`;

val expansion_def = Define`
  expansion M0 A M <=> A SUBSET M0.domain /\
                       ?ns f. ns INTER (FDOM M0.consts) = {} /\
		       BIJ f ns A /\
		       FINITE A /\
		       M = M0 with consts := FUNION M0.consts (FUN_FMAP f ns)`;
                       

val _ = Datatype`
        fterm = fVar num
	       | fConst num ;
	fform = fRrel 'r fterm fterm
	       | fPrel 'p fterm
	       | fDISJ fform fform
	       | fNOT fform
	       | fEXISTS num fform
	       | fEQ fterm fterm`; 

val fAND_def = Define`
  fAND ff1 ff2 = fNOT (fDISJ (fNOT ff1) (fNOT ff2))`;


val ST_def = Define`
  (ST x (u:unit) (VAR p) <=> fPrel p (fVar x)) /\
  (ST x u (FALSE) <=> fNOT (fEQ (fVar x) (fVar x))) /\
  (ST x u (NOT phi) <=> fNOT (ST x u phi)) /\
  (ST x u (DISJ phi psi) <=> fDISJ (ST x u phi) (ST x u psi)) /\
  (ST x u (DIAM phi) <=> fEXISTS (x + 1) (fAND (fRrel u (fVar x) (fVar (x + 1))) (ST (x + 1) u phi)))`;


val interpret_def = Define`
  interpret M Ïƒ (fVar n) = Ïƒ n /\
  interpret M Ïƒ (fConst n) = M.consts ' n`;


val feval_def = Define`
  feval M Ïƒ (fPrel p t) = M.predsyms p (interpret M Ïƒ t) /\
  feval M Ïƒ (fRrel (u:unit) t1 t2) = M.relsyms u (interpret M Ïƒ t1) (interpret M Ïƒ t2) /\
  feval M Ïƒ (fDISJ f1 f2) = (feval M Ïƒ f1 \/ feval M Ïƒ f2) /\
  feval M Ïƒ (fNOT f) = Â¬(feval M Ïƒ f) /\
  feval M Ïƒ (fEXISTS n f) = (?x. x IN M.domain /\ feval M ((n=+x)Ïƒ) f) /\
  feval M Ïƒ (fEQ t1 t2) = (interpret M Ïƒ t1 = interpret M Ïƒ t2)`;



val fsatis_def = Define`
  fsatis M Ïƒ fform <=> (IMAGE Ïƒ univ(:num)) SUBSET M.domain /\
                       feval M Ïƒ fform`;


val prop_2_47_i = store_thm(
  "prop_2_47_i",
  ``!M w:'b phi Ïƒ x. (IMAGE Ïƒ univ(:num)) SUBSET M.frame.world
                       ==> (satis M (Ïƒ x) phi <=> fsatis (mm2folm M) Ïƒ (ST x (u:unit) phi))``,
  Induct_on `phi` >> rw[] (* 5 *)
  >- (rw[feval_def,ST_def,fsatis_def] >> eq_tac >> rw[] (* 3 *)
     >- fs[mm2folm_def]
     >- (fs[satis_def] >> rw[interpret_def] >> fs[mm2folm_def,IN_DEF])
     >- (rw[satis_def] >- (fs[IMAGE_DEF,SUBSET_DEF] >> metis_tac[])
                      >- (fs[interpret_def] >> fs[mm2folm_def,IN_DEF])))
  >- (rw[satis_def,feval_def,ST_def,fsatis_def] >> metis_tac[])
  >- (rw[satis_def,feval_def,ST_def,fsatis_def])
  >- (rw[satis_def,feval_def,ST_def,fsatis_def] >> eq_tac >> rw[] (* 5 *)
     >- fs[mm2folm_def]
     >- fs[mm2folm_def]
     >- fs[mm2folm_def]
     >- rw[]
     >- (fs[IMAGE_DEF,SUBSET_DEF] >> metis_tac[]))
  >- (rw[satis_def,feval_def,ST_def,fsatis_def] >> eq_tac >> rw[] (* 4 *)
     >- fs[mm2folm_def]
     >- (qexists_tac `v` >> rw[fAND_def,feval_def,APPLY_UPDATE_THM] (* 3 *)
        >- fs[mm2folm_def]
	>- (fs[interpret_def,APPLY_UPDATE_THM] >> rw[mm2folm_def])
	>- (`((x + 1 =+ v) Ïƒ) (x + 1) = v` by rw[APPLY_UPDATE_THM] >>
           `IMAGE ((x + 1 =+ v) Ïƒ) ð•Œ(:num) âŠ† M.frame.world`
	   by (rw[IMAGE_DEF,SUBSET_DEF] >> Cases_on `x'' = x + 1` (* 2 *)
	      >> rw[APPLY_UPDATE_THM] >> fs[IMAGE_DEF,SUBSET_DEF] >> metis_tac[]) >>
	   `() = u` by fs[] >>
           metis_tac[fsatis_def]))
     >- (fs[SUBSET_DEF,IMAGE_DEF,mm2folm_def] >> metis_tac[])
     >- (qexists_tac `x'` >> rw[] (* 3 *)
        >- fs[feval_def,fAND_def,fsatis_def,interpret_def,APPLY_UPDATE_THM,mm2folm_def]
	>- fs[mm2folm_def]
	>- (fs[feval_def,fAND_def,fsatis_def] >>
	   `IMAGE ((x + 1 =+ x') Ïƒ) ð•Œ(:num) âŠ† M.frame.world`
	   by (rw[IMAGE_DEF,SUBSET_DEF] >> Cases_on `x''' = x + 1` (* 2 *)
	      >- (rw[APPLY_UPDATE_THM] >> fs[mm2folm_def])
	      >- (rw[APPLY_UPDATE_THM] >> fs[IMAGE_DEF,SUBSET_DEF] >> metis_tac[])) >>
	   `((x + 1 =+ x') Ïƒ) (x + 1) = x'` by fs[APPLY_UPDATE_THM] >>
	   `(mm2folm M).domain = M.frame.world` by fs[mm2folm_def] >>
	   metis_tac[]))));





val tvars_def = Define`
  tvars (fVar a) = {a} /\
  tvars (fConst a) = {}`;

val fvars_def = Define`
  fvars (fRrel a t1 t2) = tvars t1 âˆª tvars t2 /\
  fvars (fPrel a t) = tvars t /\
  fvars (fDISJ ff1 ff2) = (fvars ff1) âˆª (fvars ff2) /\
  fvars (fNOT ff) = fvars ff /\
  fvars (fEXISTS n ff) = n INSERT (fvars ff) /\
  fvars (fEQ t1 t2) = tvars t1 âˆª tvars t2`;


val tconsts_def = Define`
  tconsts (fVar a) = {} /\
  tconsts (fConst a) = {a}`;

val fconsts_def = Define`
  fconsts (fRrel a t1 t2) = tconsts t1 âˆª tconsts t2 /\
  fconsts (fPrel a t) = tconsts t /\
  fconsts (fDISJ ff1 ff2) = (fconsts ff1) âˆª (fconsts ff2) /\
  fconsts (fNOT ff) = fconsts ff /\
  fconsts (fEXISTS n ff) = n INSERT (fconsts ff) /\
  fconsts (fEQ t1 t2) = tconsts t1 âˆª tconsts t2`;


val freevars_def = Define`
  freevars (fRrel a t1 t2) = tvars t1 âˆª tvars t2 /\
  freevars (fPrel a t) = tvars t /\
  freevars (fDISJ ff1 ff2) = freevars ff1 âˆª freevars ff2 /\
  freevars (fNOT ff) = freevars ff /\
  freevars (fEXISTS n ff) = freevars ff DELETE n /\
  freevars (fEQ t1 t2) = tvars t1 âˆª tvars t2`;


val ftype_def = Define`
  ftype x G <=> G âŠ† {phi | freevars phi SUBSET {x}}`;

val frealizes_def = Define`
  frealizes M x G <=> ?w. ftype x G /\ w IN M.domain /\
                          !Ïƒ phi. (IMAGE Ïƒ univ(:num)) SUBSET M.domain /\ phi IN G ==> fsatis M ((x=+w)Ïƒ) phi`;



(* 			    
val isLang_def = Define`
  isLang cset phiset <=> !phi. phi IN phiset ==> fconsts phi âŠ† cset`;
*)

val ok_form_def = Define`ok_form M phi <=> fconsts phi âŠ† FDOM M.consts`

(* { phi | ok_form M phi} *)

val consistent_def = Define`
  consistent M G <=>
      !G0. FINITE G0 /\ G0 âŠ† G ==> ?Ïƒ. !phi. phi âˆˆ G0 ==> fsatis M Ïƒ phi `;
  
val n_saturated_def = Define`
  n_saturated M n <=>
     !A M' G x.
        FINITE A /\ CARD A <= n /\ A SUBSET M.domain /\
        expansion M A M' /\ G SUBSET { phi | ok_form M' phi} /\
        ftype x G /\ consistent M' G 
         ==>
        frealizes M' x G`;

val countably_saturated_def = Define`
  countably_saturated M <=> !n. n_saturated M n`;
			     
                      


val thm_2_65 = store_thm(
  "thm_2_65",
  ``!M. countably_saturated (mm2folm M) ==> M_sat M``,
  rw[countably_saturated_def,n_saturated_def,M_sat_def] >>
  qabbrev_tac `Î£' = {fRrel u (fConst 0) (fVar x)} UNION (IMAGE (ST x u) Î£)` >>
  qabbrev_tac `MA = <| domain := M.frame.world ;
                       consts := FEMPTY |+ (0,w);
                       fnsyms := \x y. ARB;
		       predsyms := \p w. (w IN M.frame.world /\ M.valt p w);
		       relsyms := \ (u:unit) w1 w2. (M.frame.rel w1 w2 /\ w1 IN M.frame.world /\ w2 IN M.frame.world) |>` >>
  `consistent MA Î£'`
      by rw[consistent_def] >> fs[fin_satisfiable_in_def] >>
         Cases_on `(fRrel () (fConst 0) (fVar x)) IN G0` (* 2 *)
	 >- `G0 =  (fRrel () (fConst 0) (fVar x)) INSERT (G0 DELETE (fRrel () (fConst 0) (fVar x)))` by metis_tac[INSERT_DELETE] >>
	    `!f. f IN G0 ==> f = fRrel () (fConst 0) (fVar x) \/ f IN (IMAGE (ST x ()) Î£)`
	       by (rpt strip_tac >>
	          `f <> fRrel () (fConst 0) (fVar x) ==> f âˆˆ IMAGE (ST x ()) Î£` suffices_by metis_tac[] >>
		  strip_tac >>
	          `f IN Î£'` by fs[SUBSET_DEF] >> fs[Abbr`Î£'`] (* 2 *)
	          >- fs[] >- metis_tac[]) >>
            fs[satisfiable_in_def] >>
	    qabbrev_tac `ps = {x' | x' IN Î£ /\ ?f. f IN G0 /\ f = ST x () x'}` >>
	    `FINITE ps`
	        by (cheat) >>
            `ps SUBSET Î£` by cheat >>
	    `âˆƒx. (x âˆˆ M.frame.world âˆ§ M.frame.rel w x) âˆ§ âˆ€form. form âˆˆ ps â‡’ satis M x form` by metis_tac[] >>
	    qexists_tac `\n. x'` >> rw[fsatis_def] (* 2 *)
	    >- (rw[Abbr`MA`] >> rw[IMAGE_DEF,SUBSET_DEF])
	    >- `IMAGE (Î»n. x') ð•Œ(:num) âŠ† MA.domain` by (rw[Abbr`MA`] >> rw[IMAGE_DEF,SUBSET_DEF]) >>
	       Cases_on `phi = fRrel () (fConst 0) (fVar x)` (* 2 *)
	       >- (fs[] >> rw[feval_def,interpret_def,Abbr`MA`])
	       >- `âˆƒt. phi = ST x () t âˆ§ t âˆˆ ps` by cheat >>
	          `satis M x' t` by metis_tac[] >>
		  `(Î»n. x') x = x'` by fs[] >>
		  `() = u` by fs[] >>
		  `IMAGE (Î»n. x') ð•Œ(:num) âŠ† M.frame.world` by fs[Abbr`MA`] >>
		  imp_res_tac prop_2_47_i >>
		  `satis M ((Î»n. x') x) t` by metis_tac[] >>
                  `fsatis (mm2folm M) (Î»n. x') (ST x u t)` by fs[] >>
		  fs[fsatis_def] >>
		  Induct_on `t
	       
	          
	    
	 
