\documentclass[a4paper,12pt]{book}

\renewcommand{\baselinestretch}{1.2}
\newcommand{\blanknonumber}{\newpage\thispagestyle{empty}}
\usepackage{graphics}
%--------

%\setlength{\voffset}{-0.5in}
%\setlength{\textheight}{710pt} old setting


%\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{holtexbasic}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{proof}
\usepackage{tikz}
\usetikzlibrary{arrows,calc,positioning,shapes,fit}
\newtheorem{defn}{Definition}
\newtheorem{lm}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{coro}{Corollary}
\newtheorem{prop}{Proposition}
\renewcommand{\HOLConst}[1]{{\textsf{\upshape\small #1}}}
\renewcommand{\HOLinline}[1]{\ensuremath{#1}}
\newcommand{\holthmenv}[1]{\begin{array}[t]{l}#1\end{array}}
\renewcommand{\HOLKeyword}[1]{\texttt{#1}}
\renewcommand{\HOLTokenBar}{\mbox{$|$}}

\setlength{\voffset}{-1in}
\setlength{\hoffset}{-1in}
\setlength{\oddsidemargin}{4cm}
\setlength{\evensidemargin}{2.5cm}
\setlength{\textwidth}{14.5cm}
\setlength{\textheight}{22.5cm}
\setlength{\topmargin}{2.5cm}


%\newcommand{\holref}[3]{\href{Https://github.com/u5943321/Modal-Logic/blob/e0eb742bd0e2f65489f8829233a829e0b060d531/#2Script.sml\#L#3}{#1}}
\newcommand{\holref}[3]{\href{Https://github.com/u5943321/Modal-Logic/blob/5b0350b067222d3b8b435bde496518bb30744c32/#2Script.sml\#L#3}{#1}}
\newcommand{\holreff}[3]{\href{Https://github.com/u5943321/Modal-Logic/blob/dbfbba74de0af276f982867714fcd6eee221196e/#2Script.sml\#L#3}{#1}}

\newenvironment{holmath}{\begin{displaymath}\begin{array}{l}}{\end{array}\end{displaymath}\ignorespacesafterend}
\newenvironment{solution}{\begin{proof}[Solution]}{\end{proof}}
%\renewcommand{\baselinestretch}{1.4}
%\setcounter{section}{-1}
\title{Modal Logic Mechanisation in HOL4}
\author{Yiming Xu}
\date{15/6/2018}


\begin{document}
\frontmatter


\mainmatter
%\maketitle old 


%talk about bars when introduct formulas
%need a very short intro to type theory // talk about phi!!
%define function on entuire type explanation.
%relational structure definition.
%satisfaction English def
%explain choice we made along the way.
%inductive relation bars // tell reader use standard notation in CS
%something like Coqdoc Link the word to particular theorem and definition.
\chapter{Introduction}
\label{chapter1}


There are four questions to answer in order to make sense of our title:
\section{What is modal logic?}

It is hard to find a concise answer to this question. As stated in the textbook `Modal Logic' by Blackburn et al, if you ask three modal logicians, you are likely to get at least three different answers. Therefore, we will begin by asking what is modality. Let us consider first order logic for a moment. Suppose $x$ is a person. When we say `$x$ is happy', we are applying the predicate `is happy' to the person $x$. But also in our daily conversation, we may also say something like `perhaps $x$ is happy' or `$x$ must be happy'. Here, `perhaps' and `must' are used to describe the `mode' of the predicate `is happy', and they are examples of  \emph{modalities}. The modalities `perhaps' and `must', which are canonically called `possibly' and `necessarily' in formal modal logic, are denoted as `$\Diamond$' and `$\Box$' respectively. Let $P$ denote the predicate `is happy'. In formal language, we can then write `perhaps $x$ is happy' as `$\Diamond Px$', and write `$x$ must be happy' as `$\Box Px$'. 

In the above discussion, we introduced modalities by considering their semantic meanings. But historically, when logicians start thinking about capture modalities using formal logic, they enriched propositional logic by adding a collection of extra symbols, called modal operators, together with some axioms describing their behavior, but there was no satisfactory way of defining a formal semantics of those modal operators. Before they realized the usefulness of the semantic tools, modal logicians had a hard time attempting to solve problems of distinguishing different systems of axioms. But more than 40 years after the concept of modal logic was established, the usage of Kripke models brought many interesting result to this subject. The results on modal logic using Kripke models are conventionally called `modal model theory'. The work on modal model theory is exactly what we are formalizing in this project. 

Nowadays, modal logic is widely adopted in many disciplines, including, but not limited to, mathematics, philosophy, linguistics, and economics. In particular, the development of modal logic and computer science support each other. With the topics taken from computer science and everywhere else, modal logic is growing rapidly, and we have great chance to see more and more interesting application of this subject to both theoretical research and daily life.


\section{What is HOL4?}

For a short answer, HOL4 is a theorem prover which is used to prove theorems interactively on a computer. Here we stress the fact that we need to interact with the machine rather then let it prove theorems automatically. In fact, for a decidable system, where there exists an algorithm that decides if the given statement is true, theorems can be proved automatically in the sense that we can give a statement to a machine and let the machine give the answer that whether the given statement holds. However, according to the Godel's incompleteness theorem, it is no algorithm that can determine the truth value of every mathematical statement. Hence in order to prove mathematical theorem, we do need to interact with the machine. Interactive theorem provers can use automatic techniques. For instance, as first-order logic and Peano arithmetic are both decidable, there is an automatic first-order solver implemented in HOL4, and simplifiers in HOL4 can automatically prove theorems about basic arithmetic. 

There are many theorem provers based on various foundation systems: HOL4 is based on simple type theory, and there exist other theorem proves based on dependent type theory (e.g. Lean, Coq) and set theory (Mizar, metamath). Each of these systems has their own advantages, but there is a trade-off: Simple type theory is widely considered as less expressive but rather easy to understand and to be implemented, whereas for more expressive systems, it takes longer for the machine to execute a proof step. 

%HOL4 is on the sweet spot of the trade-off, We will identify where the lack of expressiveness cause problems. 

\section{Why is the combining of the two interesting?}

As discussed above, modal model theory has a long history and many theorems in modal model theory have been proved since the usage of Kriple model became popular. Nevertheless, none of these theorems have been machine checked. By formalizing modal model theory in a computer, we will make sure that we have really understand every detail of the formalized theorems, find out hidden assumptions, and correct minor errors in the statements. And by formalizing it in HOL4, we will demonstrate that although simple type theory is a rather weak foundation system and does lack on express, it is still capable of capturing most of the theorems we are interested in. We will identify where the lack of expressiveness causes problems.


\section{What have we done?}

Our project is to formalize some theorems of modal model theory, based on the first two chapters of the textbook `Modal Logic' Blackburn et al. In the beginning of the textbook, the authors gives three slogans of this subject:

\begin{description}
\item [Slogan 1:] Modal languages are simple yet expressive languages for talking about relational structures.
\item [Slogan 2:] Modal languages provide an internal, local perspective on relational structures.
\item [Slogan 3:] Modal languages are not isolated formal systems.
\end{description}

A reader will see evidence of the three slogans consecutively in this thesis. The first chapter is about formalization of basic properties of modal formulas and their semantical behaviour on models of propositional modal logic. In the second chapter, we prove the locality of a modal language by proving the finite model property of modal formulas. After that, in our third chapter, we talk about the relation between modal logic and first order logic, and from then, we will begin borrowing tools from first order logic to prove results of modal logic. 


%We hope that the above is enough to convince the reader that we are doing something useful and worthwhile.


%\holref{My Theorem}{chap2_2}{103}


\chapter{Getting Started}

In our formalisation, we only consider the most standard modal language, called the basic modal language. There is only one primitive modal operator, namely the `$\Diamond$', in the basic modal language. For a type $\alpha$, an $\alpha$-modal formula is either of form \HOLtm{VAR p}, where $p$ is of type $\alpha$, or a disjunction $\phi\lor \psi$ of two $\alpha$-modal formulas, or the falsity $\bot$, or a negation $\lnot \phi$ of an $\alpha$-modal formula $\phi$, or else in the form $\Diamond \phi$ where $\phi$ is an $\alpha$-modal formula.


In HOL4, we create a datatype called `form' of the formulas of this modal language. To define a new type, we give a list of ways to construct terms of the type, separated with the symbol `$\mid$'. 



%The whole line below reads `an $\alpha$-modal formula is either in the form \HOLtm{VAR p} for a term $p$ of type $\alpha$, or in the form \HOLtm{DISJ f1 f2}, where both \HOLtm{f1} and \HOLtm{f2} are $\alpha$-modal formulas, or is \HOLtm{FALSE}, or in the form \HOLtm{NOT f} where $f$ is an $\alpha$-modal formula, or in the form \HOLtm{DIAM f} where $f$ is an $\alpha$-modal formula'. 

%Note that \HOLtm{DISJ} is of type $\alpha \ form \to (\alpha \ form \to \alpha\ form)$,  means that itself can be regarded as a function that takes two $\alpha$-modal formulas and gives an $\alpha$-modal formula. In particular, once \HOLtm{DISJ} appears, the two arguments after it are always $\alpha$-modal formula, otherwise it does not make sense. Similarly, \HOLtm{VAR}, $\lnot$, and $\Diamond$ can also be regarded as functions of type $\alpha \ form\to \alpha \ form$. \HOLtm{VAR}, \HOLtm{DISJ}, \HOLtm{NOT}, \HOLtm{DIAM} together with \HOLtm{FALSE}, which can be regarded as a nullary function to the type of $\alpha$-modal formulas, are called the \emph{constructors} of the type of $\alpha$-modal formulas. From now on, when we talk about $\alpha$-modal formula, we will say $\alpha$ is the type of \emph{propositional letters}, and call a term of type $\alpha$ a propositional letter. Also we will just call an $\alpha$-modal formula an $\alpha$-formula, if there is no confusion arise. 


\begin{defn}[\holref{Modal formulas as a type}{chap1}{13}]
An $\alpha$-modal formula is either in the form \HOLtm{VAR p} for a term $p$ of type $\alpha$, or in the form \HOLtm{DISJ f1 f2}, where both \HOLtm{f1} and \HOLtm{f2} are $\alpha$-modal formulas, or is \HOLtm{FALSE}, or in the form \HOLtm{NOT f} where $f$ is an $\alpha$-modal formula, or in the form \HOLtm{DIAM f} where $f$ is an $\alpha$-modal formula.
\begin{holmath}
  \HOLthm{chap1.datatype_form}
\end{holmath}
\end{defn}

Note that \HOLtm{DISJ} is of type $\alpha \ form \to (\alpha \ form \to \alpha\ form)$,  means that itself can be regarded as a function that takes two $\alpha$-modal formulas and gives an $\alpha$-modal formula. In particular, once \HOLtm{DISJ} appears, the two arguments after it are always $\alpha$-modal formula, otherwise it does not make sense. Similarly, \HOLtm{VAR}, $\lnot$, and $\Diamond$ can also be regarded as functions of type $\alpha \ form\to \alpha \ form$. \HOLtm{VAR}, \HOLtm{DISJ}, \HOLtm{NOT}, \HOLtm{DIAM} together with \HOLtm{FALSE}, which can be regarded as a nullary function to the type of $\alpha$-modal formulas, are called the \emph{constructors} of the type of $\alpha$-modal formulas. From now on, when we talk about $\alpha$-modal formula, we will say $\alpha$ is the type of \emph{propositional letters}, and call a term of type $\alpha$ a propositional letter. Also we will just call an $\alpha$-modal formula an $\alpha$-formula, if there is no confusion arise. 

For the non-primitive connectives: the conjunction `$\land$', the implication $\to$, and the truth `$\top$', they are defined in a standard way. 

%In standard logical notation, the first two lines of definitions below are just $\phi_1\land \phi_2:=\lnot (\lnot \phi_1\lor \phi_2)$ and $\phi_1\to \phi_2 := \lnot \phi_1\lor \phi_2$ respectively. And we use $\top$ to denote `truth', which is the negation of the falsity. 

\begin{defn}[\holref{Non-primitive connectives}{chap1}{34}]
In standard logical notation, the first two lines are just $\phi_1\land \phi_2:=\lnot (\lnot \phi_1\lor \phi f_2)$ and $\phi_1\to \phi_2 := \lnot \phi_1\lor \phi_2$ respectively. And we use $\top$ to denote `truth', which is the negation of the falsity. 
\begin{holmath}
  \HOLthm[def]{chap1.AND_def}\\
  \HOLthm[def]{chap1.IMP_def}\\
  \HOLthm[def]{chap1.TRUE_def}
\end{holmath}
\end{defn}

As an analogue of the duality between the universal quantifier and the existential quantifier, in the sense that $\exists$ is defined to be $\lnot\forall\lnot$ in classical logic, we have a modal operator that is dual to the diamond, that is the box $\Box \phi:= \lnot\Diamond \lnot \phi$. 

Any modal formula without diamond is a propositional formula. As the type of modal formulas are constructed inductively, to define a function on modal formulas, it suffices to specify the values on the constructors of this type, and this is what we do to define \HOLtm{propform}. 

\begin{defn}[\holref{Propositional formulas}{chap1}{175}]
\HOLtm{propform} is a predicate applied to modal formulas, which is a function of type $\alpha\ form \to bool$ where $bool$ is the type of the two truth values, with its two terms \HOLtm{T} and \HOLtm{F} representing `true' or `false' respectively. 
\begin{holmath}
  \HOLthm[phi/f,def]{chap1.propform_def}
\end{holmath}
The first line in the above definition reads `the predicate that `\HOLtm{VAR p} is a propositional formula' is true', or in more natural language, it just means `\HOLtm{VAR p} is a propositional formula'. The second line reads `if \HOLtm{form1} and \HOLtm{form2} are both $\alpha$-modal formulas, then their disjunction is a propositional formula if an only if both \HOLtm{form1} and \HOLtm{form2} are propositional formulas', and the remaining three lines are read similarly.
\end{defn}

%Here \HOLtm{propform} is a predicate applied to modal formulas, which is a function of type $\alpha\ form \to bool$ where $bool$ is the type of the two truth values, with its two terms \HOLtm{T} and \HOLtm{F} representing `true' or `false' respectively. 

%As the type of modal formulas are constructed inductively, to define a function on modal formulas, it suffices to specify the values on the constructors of this type, and this is what we do to define \HOLtm{propform}. In HOL4, we identify a statement and its truth value. 

%The first line in the above definition reads `the predicate that `\HOLtm{VAR p} is a propositional formula' is true', or in more natural language, it just means `\HOLtm{VAR p} is a propositional formula'. The second line reads `if \HOLtm{form1} and \HOLtm{form2} are both $\alpha$-modal formulas, then their disjunction is a propositional formula if an only if both \HOLtm{form1} and \HOLtm{form2} are propositional formulas', and the remaining three lines are read similarly.


Having defined the syntax of formulas, we can now define their \emph{semantics}. However, we will start by defining the semantics of propositional formulas. For a propositional formula, it is no more than a combination of propositional letters and the falsity `$\bot$' using $\lor$ and $\lnot$, so its truth value depends entirely on the truth value of the propositional letters. It follows that we can define the function that evaluates a propositional formula as taking an assignment of truth values of propositional letters and a propositional formula, and gives us the truth value of the formula under the current assignment. An assignment of truth value on propositional letters of type $\alpha$ is just a function that sends a propositional letter $p$ to a boolean value, which is either \HOLtm{T} or \HOLtm{F}. We can say `$p$ is true under $\sigma$' where $\sigma$ is such an assignment and $\sigma \ p = \sf T$. Our function is defined as follows:

\begin{defn}[\holref{Propositional evaluation}{chap1}{190}]
The function \HOLtm{pvalue} has type $(\alpha\to bool)\to (\alpha \ form) \to bool$, since the assignment of truth value, which is our $\sigma$ here, has type $\alpha \to bool$, whereas the second argument is an $\alpha$-form.
\begin{holmath}
  \HOLthm[phi/f,def]{chap1.peval_def}
\end{holmath}
 The first line means that `the truth value of the propositional formula \HOLtm{VAR p} is equal to the truth value of the propositional letter $p$ under the assignment $\sigma$'. In more natural language, it can be read as `\HOLtm{VAR p} is true under $\sigma$ if and only if the propositional letter $p$ is true under $\sigma$'.
\end{defn}

%The function \HOLtm{pvalue} has type $(\alpha\to bool)\to (\alpha \ form) \to bool$, since the assignment of truth value, which is our $\sigma$ here, has type $\alpha \to bool$, whereas the second argument is an $\alpha$-form. The first line means that `the truth value of the propositional formula \HOLtm{VAR p} is equal to the truth value of the propositional letter $p$ under the assignment $\sigma$'. In more natural language, it can be read as `\HOLtm{VAR p} is true under $\sigma$ if and only if the propositional letter $p$ is true under $\sigma$'.

To interpret a modal formula that involves diamonds, we need to assign an `actual meaning' to the syntactical notation `$\Diamond$'. The canonical way to interpret it is to use a relational structure. A relational structure consists of a set and and a binary relation on it, such a relational structure is called a \emph{frame} in the rest of the thesis. If in addition, for each element of the underlying set of the relational structure, it is equipped with an assignment of truth value of propositional letters, then we will have enough information to interpret any modal formula by interpreting $\Diamond \phi$, where $\phi$ is a modal formula, as `there exists a point which is related to the current state such that $\phi$ is true there'. Accordingly, `\HOLtm{BOX phi}' will be interpreted as `for any point that is related to the current state, \HOLtm{phi} is true'. For instance, consider two point set $\{a,b\}$, and let the relation be $\{(a,b)\}$. And also, let the propositional $p$ to be true on both $a$ and $b$. Now consider the modal formula \HOLtm{DIAM (VAR p)}, it is true at $a$: $b$ is a point that is related to $a$, where the formula \HOLtm{VAR p} holds there, whereas the same formula does not hold at $b$ since there is no world related to $b$. Obviously, if a world $a$ is related to any point, then we must have \HOLtm{BOX TRUE} holds on $a$. And $a$ is not related to any point, then the statement `for all worlds $b$ that related to $a$, the formula \HOLtm{FALSE} is true at $b$' is vacuously true, hence \HOLtm{BOX FALSE} holds at $a$. 

Return to our formalization, we call a frame together with an assignment of truth value of propositional letters at each point a \emph{model}, or a \emph{Kripke model} of modal formulas. The underlying set of a model is called the `set of worlds' of the model.  

\begin{defn}[\holref{Modal model as a type}{chap1}{76}]
An $\alpha$-frame consists of a world and a relation, where the world has type $\alpha\to bool$ and the relation has type $\alpha\to \alpha\to bool$. 
A model for modal logic is a frame together with a function called \HOLtm{valt}, which assign truth values of of propositional letters at each world. 
\begin{holmath}
  \HOLthm{chap1.datatype_frame}\\
  \HOLthm{chap1.datatype_model}
\end{holmath}
\end{defn}
Here the $<| \ |>$ is the notation for defining a structure. When we say an $(\alpha,\beta)$-model, we mean a model for $\alpha$-formulas with a $\beta$-set as its underlying set.
HOL4 identifies a set with elements of type $\alpha$ and their characteristic function as the subset of the set of all the terms of type $\alpha$, denoted as \HOLtm{univ(:α)} in HOL4. So an $\alpha$-set is the same as the function that takes an term $a$ of $\alpha$ and give the truth value $\sf T$ if and only if $a$ is in the set, and hence is of type $\alpha\to bool$. 
Note that in an $(\alpha,\beta)$-model \HOLtm{M}, \HOLtm{M.valt} is a function takes a propositional letter $p$ of type $\alpha$ and $w$ of type $\beta$, and give a truth value. It can be regarded as assigning each propositional letter $p$ an assignment of truth value on terms of type $\beta$, where a term $w$ of type $\beta$ is assigned to \HOLtm{T} if and only if \HOLtm{M.valt p w}. Alternatively, it can be regarded as assigning each term $w$ of type $\beta$ an assignment of truth value on terms of type $\alpha$, where a term $p$ of type \HOLtm{α} is assigned to \HOLtm{T} if and only if \HOLtm{M.valt p w}. But as we will see soon, we will always only care about the values we are assign to the terms of type $\beta$ which is in the world set. For a model \HOLtm{M}, \HOLtm{M.valt} will be called \emph{valuation} in the discussion afterwards.  
In the rest of the thesis, we use the notation \HOLtm{M.frame.world}, \HOLtm{M.frame.rel} and \HOLtm{M.valt} to denote the world set, the relation, and the valuation of the model. 

%As for the interpretation of modal formulas, it is again an inductively-defined predicate, which takes a model, a world in the model, a modal formula, and give the truth value of the formula interpreted in the model \HOLtm{M} at the world $w$. We say a formula $\phi$ is satisfied at the world $w$ in a model \HOLtm{M} when the formula is true under our semantical interpretation. Here `\HOLtm{satis M w phi}' reads `$\phi$ is satisfied at the world $w$ in \HOLtm{M}'.
We interpret modal formulas using the function called `satisfaction'. 
\begin{defn}[\holref{Satisfaction}{chap1}{94}]
Satisfaction is an inductively-defined predicate on modal formulas, which takes a model, a world in the model, a modal formula, and give the truth value of the formula interpreted in the model \HOLtm{M} at the world $w$. `\HOLtm{satis M w phi}' reads `$\phi$ is satisfied at the world $w$ in \HOLtm{M}'. For \HOLtm{w IN M.frame.world}, a propositional letter $p$ is satisfied at $w$ if \HOLtm{M.valt p w} is the boolean value $\sf T$, falsity is never satisfied, a negation of a formula $\phi$ is satisfied if $\phi$ is not satisfied, a disjunction is satisfied if at least one of its disjuncts are satisfied, and a $\Diamond \phi$ is satisfied if there exists a world in the model that $w$ is related to where $\phi$ is satisfied. 
\begin{holmath}
  \HOLthm[def,phi/form]{chap1.satis_def}
\end{holmath}
\end{defn}

Observe that instead of define the satisfaction of \HOLtm{VAR p} at $w$ to be \HOLtm{w IN M.valt p}, we include the extra condition that $w$ must lives in the underlying set of \HOLtm{M}. It is because HOL4 allows us to write \HOLtm{satis M w phi}, for any $w$ of the correct type, even if it does not belong to the underlying set of \HOLtm{M}. A reader may think that we can define our satisfaction predicate as a function that takes a model \HOLtm{M}, and make sure that `satisfaction on the model \HOLtm{M}' is a function from the worlds set of \HOLtm{M} and the set of modal formulas to the set \HOLtm{{T;F\}}. But actually it is not allowed in HOL4: we cannot make the domain and the codomain an intrinsic property of a function. The notion of a function from an $\alpha$-set $A$ to a $\beta$-set $B$ is not primitive. Such a function is a term $f$ of type $\alpha\to \beta$, which the additional property that \HOLtm{!a. a IN A ==> (f a) IN B}. So to specify such a function, we must define the function on all the terms of $\alpha$. 

%Q1. Notation here for satis M?
Just as in first order logic and propositional logic, we can define the notion of logical equivalence of modal formulas. Note that we can only talk about equivalence between modal formulas of the same type, and for each type $\alpha$, the equivalence between modal formulas gives an equivalence relation on the set \HOLtm{univ(:α form)} of all the $\alpha$-formulas.

\begin{defn}[\holref{Equivalence}{IBCDNFrevised}{17}]
If \HOLtm{phi1}, \HOLtm{phi2} are \HOLtm{β} formulas, \HOLtm{equiv0 (:α) phi1 phi2} means for any $(\beta,\alpha)$-model \HOLtm{M} and any world \HOLtm{w} in it, we have \HOLtm{satis  M w phi1 <=> satis M w phi2}.
\begin{holmath}
  \HOLthm[def,showtypes]{prettyPrinting.ppequiv0_def}\\[3mm]
\end{holmath}
\end{defn}
%\begin{prop}[\texttt{equiv0_equiv_on}]
%\begin{holmath}
  %\HOLthm{IBCDNFrevised.equiv0_equiv_on}
%\end{holmath}
%\end{prop}

A notable thing is that \HOLtm{equiv0} need to take a type as an argument. We are not allowed to omit the type parameter \HOLtm{(:α)} in the definition, since then there will be a type, namely the type of the underlying set of the models we are talking about, that only appears on the right hand side but not on the left hand side of the definition, which is not allowed in the HOL4. Also we are not allowed to quantify over types, so it is also impossible to define the equivalence to be \HOLtm{!μ. equiv μ phi1 phi2}, where $\mu$ denotes a type. Hence this definition is not encoding the equivalence in mathematical sense precisely, since when we mention equivalence of formulas in usual mathematical language, we are implicitly talking about the class of all models, but the constraint here bans us from talking about all models of all possible types at once. Such a constraint give arise to some problems in our formalization, as we will see in later chapters. 

We can immediately prove that for any type $\alpha$, if \HOLtm{equiv0 (:α) phi1 phi2} then \HOLtm{equiv0 (:α) (DIAM phi1) (DIAM phi2)}. If we use set theory as our foundation, then the converse can proved very easily: If two diamond formulas \HOLtm{DIAM phi1} and \HOLtm{DIAM phi2} are equivalent, then for a contradiction, suppose that $\phi_1$ and $\phi_2$ are not equivalent, then there exists a model \HOLtm{M} and a world $w$ such that $w$ satisfies $f$ but not $g$. We can add a world $v$ to the world set of \HOLtm{M} that is only related to $w$, then $v$ will be a witness of the fact that \HOLtm{DIAM (phi1)} and \HOLtm{DIAM (phi2)} are not equivalent. But under our definition in the HOL4, if the \HOLtm{(:α)} is a finite type, the proof is blocked: since we cannot make sure that we can come up with a world $v$ which is not already being used by \HOLtm{M}, and add a fresh world to add to \HOLtm{M} which is only related to $w$. However, for any model, regardless its world set is of a finite type or not, we can always create a copy of the model in an infinite type. So it is harmless to only play with equivalence of formulas for models whose underlying set is of an infinite type. 

%and we will just add the infiniteness of the type universe as an assumption. 

%For infinite type universes, we do have a double implication:

% For a finite type $\mu$, it is possible that we have \HOLtm{equiv0 μ (DIAM f) (DIAM g)} but \HOLtm{¬equiv0 μ f g}. For example, consider the type $\mu$ that has only two inhabitants $a,b$, and consider such a model: The underlying set is \HOLtm{{a;b\}}, the relation is \HOLtm{{(a,b)\}}, and let $p,q$ be propositional letters such that both $p,q$ are true at $a$, but only $p$ is true at $b$. Then we have \HOLtm{equiv μ (DIAM (VAR p)) (DIAM (VAR q))}, since both 


%then in the model below, we have \HOLtm{equiv0 μ (DIAM (VAR p)) (DIAM (VAR q))} but \HOLtm{¬equiv0 μ (VAR p) (VAR q)}.

%(add the picture of example, how to draw it?)%!!!!!2

%As the situition above is only because of our special definition, such case is uninteresting.

\begin{prop}[\holref{\texttt{equiv0_DIAM}}{chap2_3}{980}]
For two modal formulas \HOLtm{phi1} and \HOLtm{phi2}, \HOLtm{phi1} and \HOLtm{phi2} are equivalent on models with $\alpha$-world sets where $\alpha$ is an infinite type if and only if $\Diamond \phi_1$ and $\Diamond \phi_2$ are equivalent on models with $\alpha$-world sets. 
\begin{holmath}
  \HOLthm[phi1/f,phi2/g]{prettyPrinting.ppequiv0_DIAM}
\end{holmath}
\end{prop}


Up to now, we have two ways to determine the truth value of a propositional formula. The first one is to use \HOLtm{pvalue}, and also, as propositional formulas are modal formulas, we can also determine their truth value on models. These two methods of calculating truth value of propositional symbols always give the same result. 

\begin{prop}[\holref{\texttt{peval_satis_strengthen'}}{chap2_3}{2403}]
If $\phi$ is a propositional formula, and the propositional letters it contains is a subset of a set $s$, then for a world $w$ in a model \HOLtm{M}, $\phi$ is satisfied at the world $w$ if and only if when we use the assignment of truth value on propositional letters at $w$ to evaluate $\phi$ as a propositional formula, the truth value we get is $\sf T$. 
\begin{holmath}
  \HOLthm[phi/f]{prettyPrinting.pppeval_satis_strengthen'}
\end{holmath}
Here we use the $\lambda$-abstraction to define the function that \HOLtm{peval} takes. \HOLtm{\a. w IN M.valt a /\ a IN s} assigns a propositional letter $a$ in the set $s$ to $\sf T$ if and only if $a$ is true at $w$ according to the valuation defined on \HOLtm{M}. \HOLtm{prop_letters} is the function that takes a modal formula and gives the set of propositional letters that appear in the formula. 
\end{prop}

In the above proposition, let \HOLtm{s = prop_letters phi}, we conclude that the truth value of a propositional formula depends only on the truth values of propositional letters that appear in it. More generally, on any model, the truth value of any modal formula is completely determined by the truth values of the propositional letters appear in it. 

\begin{prop}[\holref{\texttt{exercise_1_3_1}}{chap1}{621}]
If two models \HOLtm{M1} and \HOLtm{M2} has the same frame and agrees on the valuation on all the propositional letters in \HOLtm{phi}, then \HOLtm{phi} is satisfied at a world $w$ in \HOLtm{M1} if and only if $\phi$ is satisfied at $w$ in \HOLtm{M2}.
\begin{holmath}
  \HOLthm{prettyPrinting.ppexercise_1_3_1}
\end{holmath}
\end{prop}




\chapter{Invariant results and bisimulations}


The key concept we are interested in this chapter is called `modal equivalence'.

\begin{prop}[\holref{\texttt{modal_eq_tau}}{chap2_5}{54}]
Two worlds in two models are called to be `modal equivalent' if they satisfy the same set of modal formulas. 
\begin{holmath}
  \HOLthm[phi/form,M'/Mp]{chap2_5.modal_eq_tau}
\end{holmath}
\end{prop}
%!!!!!3 This is not a definition, I do not want to talk about tau theory. fixed

In this chapter, we investigate when can we get modal equivalence. In the first section, we talk about how can we get new models from old models without affecting modal satisfaction. Then in the second section, we introduce morphisms between models and find out under which condition we can map a point of a model to another model preserving satisfaction. In the last section, we unify all the modal operations and morphisms we have mentioned which give modal equivalence using a relation between models, called bisimulation, by proving all these constructions are cases of bisimulation.


\section{Operations on models}

Here we introduce two operations on models, called disjoint union and generated submodels respectively. 

The operation on models that leads to invariance of satisfaction most straightforwardly is the disjoint union:
\begin{defn}[\holref{Disjoint union}{chap2_1}{23}]
Disjoint union is denoted as \HOLtm{DU}, it is a function that takes a pair $(f,J)$, where \HOLtm{J} is a $\gamma$-set indexing the family of models which we want to take their disjoint union and $f$ is of type $\gamma\to (\alpha,\beta)$-model, where $\alpha$ and $\beta$ are allowed to be any type.
\begin{holmath}
   \HOLthm[def,j/i,J/dom]{prettyPrinting.ppDU_def}
\end{holmath} 
Here \HOLtm{J} is a set indexing the family of models which we want to take their disjoint union. And the role of $f$ is to assign each element of $J$ an actual model. Hence the usage of the pair $(f,J)$ is to capture the mathematical notion of an indexed family.
The world set of the disjoint union of such a family has elements of form $(j,w)$ where $j\in J$ and \HOLtm{w IN (f j).frame.world}. The valuation on \HOLtm{DU (f,J)} is given by \HOLtm{(DU (f,J)).valt p (j,w)} iff \HOLtm{(f j).valt p w}, for any propositonal letter $p$ and any world $(j,w)$. Relation is defined by \HOLtm{(DU (f,J)).frame.rel (j,w) (j',w')} iff \HOLtm{j=j'} and \HOLtm{(f j).frame.rel w w'}. It means that two worlds $(j,w)$ and $(j',w')$ in the disjoint union are related if and only if they come from the same model and are related by the relation in that model. 

\end{defn}
%Disjoint union is denoted as \HOLtm{DU}, it is a function that takes a pair $(f,J)$. Here \HOLtm{J} is a set indexing the family of models which we want to take their disjoint union. And the role of $f$ is to assign each element of $J$ an actual model. Hence the role of the pair $(f,J)$ is just used to capture the mathematical notion of an indexed family. 

As HOL4 is based on simple type theory rather than dependent type theory, we do not allow the type of model that $f$ assign to each element of $J$ to vary. So we can only take disjoint unions of families of models of the same type. 

%The world set of the disjoint union of such a family has elements of form $(j,w)$ where $j\in J$ and \HOLtm{w IN (f j).frame.world}. The valuation on \HOLtm{DU (f,J)} is given by \HOLtm{(DU (f,J)).valt p (j,w)} iff \HOLtm{(f j).valt p w}, for any propositonal letter $p$ and any world $(j,w)$. Relation is defined by \HOLtm{(DU (f,J)).frame.rel (j,w) (j',w')} iff \HOLtm{j=j'} and \HOLtm{(f j).frame.rel w w'}. It means that two worlds $(j,w)$ and $(j',w')$ in the disjoint union are related if and only if they come from the same model and are related by the relation in that model. 

The disjoint union operation does nothing except for collecting a set of models together, so the following result is unsurprising. 

%that if we have \HOLtm{satis M w phi} for a modal formula $\phi$, a model \HOLtm{M} and a world $w$, then for any indexed family $(f,J)$ where \HOLtm{M = f j} for some \HOLtm{j IN J}, $\phi$ is also satisfied at the point \HOLtm{(j,w)} in the disjoint union of the family, where \HOLtm{(j,w)} is just the copy of $w$ embedded in the model obtained by taking disjoint union, and vice versa.

\begin{prop}[\holref{\texttt{prop_2_3}}{chap2_1}{30}]
If we have \HOLtm{satis M w phi} for a modal formula $\phi$, a model \HOLtm{M} and a world $w$, then for any indexed family $(f,J)$ where \HOLtm{M = f j} for some \HOLtm{j IN J}, $\phi$ is also satisfied at the point \HOLtm{(j,w)} in the disjoint union of the family, where \HOLtm{(j,w)} is the copy of $w$ embedded in the model obtained by taking disjoint union, and vice versa.
\begin{holmath}
  \HOLthm[j/i,J/dom]{prettyPrinting.ppprop_2_3}
\end{holmath}
\end{prop}

Disjoint union is the operation we use when we want to expand our scope from a small model to a larger model. Accordingly, we have an operation that allows us to restrict our scope to a smaller model, this is called the `generated submodel' construction. When we say `\HOLtm{M1} is a submodel of \HOLtm{M2}', we mean all the information of \HOLtm{M1} is inherited from that of \HOLtm{M2}. 
%More specifically, we mean the world set of \HOLtm{M1} is a subset of the world set of \HOLtm{M2}, and for two worlds $w_1,w_2$ in \HOLtm{M1}, we have \HOLtm{M1.frame.rel w1 w2} iff \HOLtm{M2.frame.rel w1 w2}. Also we require for any world of \HOLtm{M1}, its valuation of propositional letters is exactly the same as that in \HOLtm{M2}. The formal definition is given as follows:
\begin{defn}[\holref{Submodel}{chap2_1}{60}]
By \HOLtm{SUBMODEL M1 M2}, we mean the world set of \HOLtm{M1} is a subset of the world set of \HOLtm{M2}, and for two worlds $w_1,w_2$ in \HOLtm{M1}, we have \HOLtm{M1.frame.rel w1 w2} iff \HOLtm{M2.frame.rel w1 w2}. Also we require for any world of \HOLtm{M1}, its valuation of propositional letters is exactly the same as that in \HOLtm{M2}.
\begin{holmath}
  \HOLthm[def]{prettyPrinting.ppSUBMODEL_def}
\end{holmath}
\end{defn}

It is not necessary that submodel construction preserves modal satisfaction. Although the clause about relation says that for any worlds $w_1,w_2$ in \HOLtm{M1}, they are related in \HOLtm{M1} iff they are related in \HOLtm{M2}, it can be the case that $w_1,w_2$ are worlds in \HOLtm{M2} such that \HOLtm{M2.frame.rel w1 w2}, where $w_2$ is the only world that $w_1$ is related to, but \HOLtm{w1 IN M1.frame.world} whereas \HOLtm{w2 NOTIN M1.frame.world}. As a consequence, if we have \HOLtm{satis M2 w2 phi}, then we will have \HOLtm{satis M2 w1 (DIAM phi)} but not \HOLtm{satis M1 w1 (DIAM phi)}, since there is no world in \HOLtm{M1} which has a relation from \HOLtm{w1}. To avoid such situation, we can add an extra constraint on the world set of \HOLtm{M1}, and make sure that for any world $w$ in \HOLtm{M2}, if it is included in the world set of \HOLtm{M1}, then every world \HOLtm{w' IN M2.frame.world} such that \HOLtm{M2.frame.rel w w'} must also be included to the world set of \HOLtm{M1}. A submodel which satisfies this extra condition is called a generated submodel:

%(Give an easy example?)!!!!!4

\begin{defn}[\holref{Generated submodel}{chap2_1}{68}]
\begin{holmath}
  \HOLthm{prettyPrinting.ppGENSUBMODEL_def}
\end{holmath}
\end{defn}

Note that for a model \HOLtm{M1} to be a generated submodel of \HOLtm{M2}, we only require all the worlds $w'$ which have a link from a world $w$ in \HOLtm{M2} to be also included in the world set of \HOLtm{M1}, and if $w_1,w_2$ are in \HOLtm{M2} and \HOLtm{w2 IN M1.frame.world} we are allowed not to include \HOLtm{w1} into \HOLtm{M1}. This is because the `$\Diamond$' operator in modal formulas cannot `look back', in the sense that adding extra connections or discard connections \emph{towards} a world $w$ does not change the satisfaction of modal formulas at $w$.
 
Generated submodels do preserve modal satisfaction:
\begin{prop}[\holref{\texttt{prop_2_6}}{chap2_1}{75}]
\begin{holmath}
  \HOLthm{chap2_1.prop_2_6}
\end{holmath}
\end{prop} 

%A rooted model is a submodel generated by a point. We will talk rooted models more frequently later, so they deserve a separate definition. As a special kind of generated model, a rooted model needs to be sitting in an ambient model. This make it reasonable to define rooted model as a predicate that takes three parameters: The model itself, the point that generates it, and the ambient model that it is sitting in:
%\begin{defn}[Rooted model]
%\begin{holmath}
 % \HOL thm[def]{chap2_1.rooted_model_def}
%\end{holmath}
%\end{defn}
%Here the superscript $*$ is used to take the reflexive and transitive closure of a relation,\HOLtm{RESTRICT} is a function that takes a relation $R$ and a set $s$ and return the relation such that \HOLtm{RESTRICT R s x y} iff \HOLtm{x IN s}, \HOLtm{y IN s} and \HOLtm{R x y}:
%\begin{defn}[Restriction of relation]
%\begin{holmath}
  %\HOL thm[def]{chap2_1.RESTRICT_def}
%\end{holmath}
%\end{defn}

%(prove a little proposition about it?)

%if talk about existence here, should define functions give gensubmodel but not only rooted ones !!!!!6


\section{Morphisms between models}

In this section, we talk about various kinds of `morphisms' between models. Similar as in mathematics, the notion of `morphism' here is used to describe maps that preserves structures. For instance, `homomorphism' is the weakest notion of `structure-preserving map':
\begin{defn}[\holref{Homomorphism}{chap2_1}{120}]
A homomorphism from a model \HOLtm{M1} to a model \HOLtm{M2} is a function from the world set of \HOLtm{M1} to the world set of \HOLtm{M2} that preserves relation and valuation of propositional letters.
\begin{holmath}
  \HOLthm[def]{prettyPrinting.pphom_def}
\end{holmath}
\end{defn}

We should point out that the last clause only says `relations in the source model is preserved by a homomorphism', and we are allowed to have relations in the target model which is not from a relation in the source model. Because of this, we cannot guarantee any world and its image in the target to satisfy exactly the same set of modal formulas. As an attempt to obtain an equivalence, we can try strongthening the last clause into a `two-sided' correspondence between relational links in the source and target. A homomorphism satisfies this strengthened condition is called a strong homomorphism:
\begin{defn}[\holref{Strong homomorphism}{chap2_1}{126}]
\begin{holmath}
  \HOLthm[def]{prettyPrinting.ppstrong_hom_def}
\end{holmath}
\end{defn}

A strong homomorphism that is a bijection on the world set is called an isomorphism. It is trivial to see an isomorphism preserves everything. But actually, we do not need such a strong condition: as shown in the following proposition, it is enough to require a strong morphism to be surjective:
\begin{prop}[\holref{\texttt{prop_2_9}}{chap2_1}{182}]
\begin{holmath}
   \HOLthm[M1/M,M2/M']{prettyPrinting.ppprop_2_9}
\end{holmath}
\end{prop}

Now we have a desired modal equivalence from strong homomorphism. The problem is that the condition of being a strong homomorphism is still too strong.  There are many morphisms which preserves modal satisfaction which fail to satisfy the conditions required by a surjective strong homomorphism, so it is still not the minimum. An easy example can be taken as follows: Let the world set of both \HOLtm{M1} and \HOLtm{M2} be the two point set $\{w,v\}$ and let the singleton set $\{p\}$ be our set of propositional letters. For \HOLtm{M1}, define the relation as \HOLtm{M1.frame.rel w w}, \HOLtm{M1.frame.rel v v} and \HOLtm{M1.frame.rel w v}, and define the valuation as $p$ is satisfied on both $w$ and $v$. And for \HOLtm{M2}, define the only relation to be \HOLtm{M2.frame.rel w w}, and the valuation is the same as in \HOLtm{M1}. Then the function sending both $w$ and $v$ in \HOLtm{M} to $w$ in \HOLtm{M2} preserves satisfaction, but is clearly not surjective. 

Hence we still want something weaker. Finally, we find a satisfactory answer-the bounded morphism.
\begin{defn}[\holref{Bounded morphism}{chap2_1}{213}]
A bounded morphism between two models \HOLtm{M1} and \HOLtm{M2} is a function $f$ between their world sets such that $w$ and $f(w)$ satisfies the same propositional letters. In addition, it need to satisfy the `back and forward' conditions for relations on these two models: if $w,v$ are worlds in \HOLtm{M} such that \HOLtm{M1.frame.rel w v}, then we require \HOLtm{f w} and \HOLtm{f v} to be worlds in \HOLtm{M2} such that \HOLtm{M2.frame.rel (f w) (f v)}. And moreover, if a world in \HOLtm{M2} is the image of some world $w$ in \HOLtm{M1} under $f$, then if it is related to a world \HOLtm{v'} in \HOLtm{M2}, it must be the case that we can find a world \HOLtm{v} in \HOLtm{M1} such that \HOLtm{M1.frame.rel w v} and $v$ is mapped to $v'$ by $f$. 
\begin{holmath}
   \HOLthm[def,M1/M,M2/M']{chap2_1.bounded_mor_def}
\end{holmath}
\end{defn}

From the definition, it is easy to see that any surjective strong morphism is a bounded morphism. The invariance result that bounded morphism gives is stated as:

%(the book says many invarient map are not strong homomorphism, but do not say every map that give arise to equivalence is bounded morphism, strongthen into a characterisation?)!!!!!5

\begin{prop}[\holref{\texttt{prop_2_14}}{chap2_1}{227}]
\begin{holmath}
  \HOLthm[M1/M,M2/M']{chap2_1.prop_2_14}
\end{holmath}
\end{prop}


The above result is very useful. As an application, now we use it to prove the \emph{tree-like property} of the basic modal language. The tree-like property says that for any formula $\phi$ satisfied on any point in any model, there exists a tree-like model such that $\phi$ is satisfied at the root of the tree. As the name indicates, a tree-like model is a model such that its underlying frame is a tree. 
\begin{defn}[\holref{Tree}{chap2_1}{319}]
The predicate \HOLtm{tree} takes a frame $S$ and a point $r$, and \HOLtm{tree} $S\ r$ means that $S$ is a tree with root $r$. 
\begin{holmath}
   \HOLthm[def]{chap2_1.tree_def}
\end{holmath}
For the notations: the superscript $*$ denote the operation of taking the reflexive and transitive closure of a relation. \HOLtm{RESTRICT} is a function that takes a relation $R$ and a set $s$ and return the relation such that \HOLtm{RESTRICT R s x y} iff \HOLtm{x IN s}, \HOLtm{y IN s} and \HOLtm{R x y}.
\end{defn}
%!!!!!hide the S


In fact, for any tree-like model, it is a rooted model. Rooted models are special cases of generated submodels, as introduced before. In particular, rooted models are just submodel generated by a singleton set. As an instance of generated model, a rooted model needs to be sitting in an ambient model. 
%This make it reasonable to define rooted model as a predicate that takes three parameters: The model itself, the point that generates it, and the ambient model that it is sitting in:
\begin{defn}[\holref{Rooted model}{chap2_1}{380}]
Rooted model is defined as a predicate that takes three parameters: The model itself, the point that generates it, and the ambient model that it is sitting in. 
\begin{holmath}
  \HOLthm[def,M1/M,M2/M']{prettyPrinting.pprooted_model_def}
\end{holmath}
\end{defn}


We expect a tree cannot have any loop. More formally, it means that:
% any point in a tree cannot be linked back to itself via the transitive closure of the relation defined on the tree. In the statement below, the superscript `$+$' is used to denote the operation that takes the transitive closure of a relation. 
\begin{lm}[\holref{\texttt{tree_no_loop}}{chap2_1}{346}]
Any world in a tree cannot be linked back to itself via the transitive closure of the relation defined on the tree.
\begin{holmath}
  \HOLthm{chap2_1.tree_no_loop}
\end{holmath}
The superscript `$+$' here is used to denote the operation that takes the transitive closure of a relation. 
\end{lm}
\begin{proof}
It is straightforward to reduce the goal into \HOLtm{!t1 t2. R^* t1 t2 ==> (t1 = r) ==> ¬R^+ t2 t2}. The rest of the proof is done by induction on reflexive and transitive closure using the induction principle \texttt{RTC_STRONG_INDUCTION_RIGHT1}.
\end{proof}

We now prove the tree-like property of modal formulas:
\begin{prop}[\holref{\texttt{prop_2_15_corollary}}{chap2_1}{818}]
\begin{holmath}
  \HOLthm[M1/M,M2/M']{prettyPrinting.ppprop_2_15_corollary}
\end{holmath}
\end{prop}
\begin{proof}
Suppose \HOLtm{satis M1 w phi}. By the invariance result of rooted model, we have \HOLtm{satis M2 w phi} where \HOLtm{M2} is the rooted model generated by \HOLtm{w}. More precisely, the model \HOLtm{M2} is given by \HOLtm{point_GENSUBMODEL M w}, where \HOLtm{point_GENSUBMODEL} is a function is the function that taking a model and a world $w$ in the model, and gives the model that generates by $w$, defined as:

\begin{holmath}
  \HOLthm[def]{chap2_1.point_GENSUBMODEL_def}
\end{holmath}

 By the \texttt{prop_2_14}, it suffices to prove \HOLtm{M2} is the image of some bounded morphism from some tree-like model \HOLtm{M3} where the root of the tree is mapped to $w$. We construct \HOLtm{M3} as follows: Take the set of worlds to be the finite sequences [$w=u_0;u_1;\cdots ;u_n$] such that \HOLtm{M1.frame.rel} $u_i\ u_{i+1}$ for all $i$. Define \HOLtm{M3.frame.rel} $[w;u_1;\cdots ;u_n]\ [w;v_1;\cdots ;v_m]$ iff $m=n+1$, $m_i=v_i$ for $i\le n$, and \HOLtm{M1.frame.rel} $u_n\ v_m$. The valuation is given by $[w;u_1;\cdots;u_n]\in$ \HOLtm{M3.valt p} iff $u_n\in$ \HOLtm{M1.valt p}. Such a model is given by \HOLtm{bounded_preimage_rooted M2 w}, where \HOLtm{bounded_preimage_rooted} is the following function:

\begin{holmath}
  \HOLthm[def]{chap2_1.bounded_preimage_rooted_def}
\end{holmath}  

It is straightforward to check the map \HOLtm{LAST} that sends a list in \HOLtm{l IN (bounded_preimage_rooted M2 w).frame.world} to its last member is a bounded morphism, and $[w]$ in \HOLtm{M3} is sent to $w$ in \HOLtm{M2}, as desired.

\end{proof}

\section{Bisimulation}

The three approaches to obtain modal equivalence has a common feature: all of them leads to a relation between models such that related states satisfies exactly the same set of propositional letters, and once we are able to make a transition in one model, we can make a corresponding transition in the other. This observation leads us to the concept of bisimulation: 
\begin{defn}[\holref{Bisimulation}{chap2_2}{19}]
A bisimulation $Z$ between models \HOLtm{M1} and \HOLtm{M2} is a relation between their world sets, such that for worlds \HOLtm{w1 IN M.frame.world} and \HOLtm{w2 IN M2.frame.world} which are related by $Z$, for every propositional letter $p$, $p$ is satisfied at $w_1$ if and only if it is satisfied at $w_2$, and we require that once we have a world \HOLtm{v1 IN M1.frame.world} such that $w_1$ is related to $v_1$ by the relation in \HOLtm{M1}, we can find a world $v_2$ in \HOLtm{M2} such that $v_1$ and $v_2$ is related by $Z$ where $w_2$ is related to $v_2$ in \HOLtm{M2}. Also we require a `backward condition', saying that once we have a world \HOLtm{v2 IN M2.frame.world} such that $w_2$ is related to $v_2$ by the relation in \HOLtm{M2}, we can find a world $v_1$ in \HOLtm{M1} such that $v_1$ and $v_2$ is related by $Z$ where $w_1$ is related to $v_1$ in \HOLtm{M1}.
\begin{holmath}
  \HOLthm[def,M1/M,M2/M',w1/w,w2/w',v1/v,v2/v']{chap2_2.bisim_def}
\end{holmath}
\HOLtm{bisim Z M1 M2} reads `\HOLtm{Z} is a bisimulation relation between worlds in \HOLtm{M1} and \HOLtm{M2}'. 
\end{defn}
%If we have \HOLtm{bisim Z M1 M2}, it means that \HOLtm{Z} is a bisimulation relation between worlds in \HOLtm{M1} and \HOLtm{M2}. We require any two worlds related by a bisimulation to have same atomic information and matching transition possibilities.
 We can see all of the three constructions we introduced before give arise to bisimulations:
\begin{prop}[\holref{\texttt{prop_2_19_ii}}{chap2_2}{37}]
\begin{holmath}
  \HOLthm[j/i,J/dom]{chap2_2.prop_2_19_ii}
\end{holmath}
\end{prop}

\begin{prop}[\holref{\texttt{prop_2_19_iii}}{chap2_2}{63}]
\begin{holmath}
  \HOLthm[M1/M,M2/M']{chap2_2.prop_2_19_iii}
\end{holmath}
\end{prop}

\begin{prop}[\holref{\texttt{prop_2_19_iv}}{chap2_2}{81}]
\begin{holmath}
  \HOLthm[M1/M,M2/M']{chap2_2.prop_2_19_iv}
\end{holmath}
\end{prop}

Proof: For (i), the bisimulation relation is \HOLtm{λa b. (b = (j, a))}, which is relating a world to its copy in the disjoint union. For (ii), the bisimulation relation is \HOLtm{λw1 w2. w1 = w2}. And for (iii), the bisimulation relation is \HOLtm{λw1 w2. (w2 = f w1)}.


With the clauses on forth and back condition for a bisimulation relation, it is routine to induct on modal formulas and prove the following result.

\begin{thm}[\holref{\texttt{thm_2_20}}{chap2_2}{124}]
\begin{holmath}
  \HOLthm[M1/M,M2/M',w1/w,w2/w']{chap2_2.thm_2_20}
\end{holmath}
\end{thm}

The theorem above provides alternative proofs to the invariance theorems for disjoint union, generated submodels, and bounded morphisms. We can firstly prove the constructions give arise to bisimulations, and then specialise \texttt{thm_2_20}. But it is not the end of the story. A natural question to ask is : is bisimulation and modal equivalence the `same thing'? More precisely, a bisimulation will always give a modal equivalence, conversely, is that the fact that a modal equivalence always give a bisimulation?

The answer is no. Nonetheless, we can prove the converse of the theorem above with an extra condition on the models. Namely, the converse of the theorem holds for \emph{image finite} models.
\begin{defn}[\holref{Image finite}{chap2_2}{158}]
 A model \HOLtm{M} is called image finite if for any world \HOLtm{w IN M.frame.world}, there are only finitely many worlds in \HOLtm{M} related to \HOLtm{w}.
\begin{holmath}
  \HOLthm[def]{chap2_2.image_finite_def}
\end{holmath}
\end{defn}

Our main theorem is called Hennessy-Milner theorem:
\begin{thm}[Hennessy-Milner Theorem, \holref{\texttt{thm_2_24}}{chap2_2}{328}]
For image finite models, modal equivalence and bisimulation are indeed the same thing.
\begin{holmath}
  \HOLthm[M1/M,M2/M',w1/w,w2/w']{chap2_2.thm_2_24}
\end{holmath}
\end{thm}

\begin{proof}
The implication from right to left is no more than \texttt{thm_2_20}. We prove the implication from left to right. Given \HOLtm{w1} and \HOLtm{w2} are worlds in \HOLtm{M1} and \HOLtm{M2} which are modal equivalent, we prove the relation \HOLtm{λn1 n2. (!form. satis M1 n1 form <=> satis M2 n2 form)} gives a bisimulation. The first clause is immediate to check. For the second one, assume \HOLtm{modal_eq M1 M2 n1 n2} and \HOLtm{M1.frame.rel n1 n1'} for some \HOLtm{n1' IN M1.frame.world}, we prove the existence of the world \HOLtm{n2' IN M2.frame.world} such that \HOLtm{M2.frame.rel n2 n2'} and \HOLtm{modal_eq M1 M2 n1' n2'}. Suppose such a \HOLtm{n2'} does not exist, we derive a contradiction. Consider the set \HOLtm{S0 = { u' | (u' IN M2.frame.world /\ M2.frame.rel n2 u') \}}
, the first claim is that $S_0$ is finite and nonempty. Finiteness comes from the fact that \HOLtm{M2} is image finite, and if the set is empty, then \HOLtm{BOX FALSE} will be a formula satisfied at \HOLtm{n2} but not at \HOLtm{n1}, contradicts the modal equivalence between \HOLtm{n1} and \HOLtm{n2}. By assumption, for each world in $S_0$, there is a formula \HOLtm{phi} such that \HOLtm{satis M1 n1' phi} but \HOLtm{¬satis M2 n2' phi}. As the set $S$ is finite, the set of such \HOLtm{phi}s is finite. Then we can take the conjunction of such \HOLtm{phi}s to obtain a formula \HOLtm{psi}. Then we will have \HOLtm{satis M1 n1 (DIAM psi)} but \HOLtm{¬satis M1 n2 (DIAM psi)}.

The trick is what to do to capture the conjunction of a finite set of formulas, which is called the `big conjunction' of the set. Certainly we can inductively define a function that takes a finite set and give us the formula that conjuncts them together, but even it is clear that we are using the big conjunction of a set, it can be convenient not having to define the details of constructing such a big formula, instead, we may directly obtain the formula with exactly the property we want for the proof here. With this idea in mind, we prove:

\begin{holmath}
  \HOLthm[ψ/psi,M1/M,M2/M']{prettyPrinting.ppFINITE_BIGCONJ}
\end{holmath}
 
Using this lemma, we obtain the \HOLtm{psi} we want by plugging in $S_0$ to be the $s$. The spirit how we capture the big conjunction will be used in our formalization for several times, as we will see later.
\end{proof}

%The requirement for the models to be image finite is necessary: 

\chapter{Finite model property}

In this chapter, we tell the story about the Slogan 2 as stated in the introduction: Modal formulas can only capture local information. It follows that there does not exist any modal formula which can capture information about points which are $n$-steps from the current state for every $n$. To see this, we will prove the \emph{finite model property} of modal formulas, which says if a modal formula is satisfied on an arbitary model, then it can be satisfied on a finite model, where finite model means a model whose world set is finite. We will discuss two methods of building finite models for satisfiable modal formulas, namely via filtration and selection, in the two sections of this chapter. 

\section{Finite model property via filtration}

One way to get finite model from an arbitary model is by filtration. Filtration is just another name of the rather familar terminology `quotient'. In this method, we start with a possibly infinite model and make its world set smaller by quotienting out by a equivalence relation defined using the concept of \emph{subformulas}. Intuitively, a subformula of a modal formula is a part of a modal formula which is itself a modal formula. For instance, consider the formula $\lnot (\lnot \phi_1 \lor \phi_2)$, then the set of its subformulas is $\{\lnot (\lnot \phi \lor \phi_2),\lnot \phi_1, \lnot \phi_1\lor \phi_2, \phi_1,\phi_2\}$. However, $\lor \phi_2$ is not a subformula since it is not a modal formula at all.

\begin{defn}[\holref{Subformula}{chap2_3}{41}]
The function \HOLtm{subforms} takes a modal formula and give the set of its subformulas:
\begin{holmath}
  \HOLthm[def,phi/f]{prettyPrinting.ppsubforms_def}
\end{holmath}
\end{defn}

Some basic properties of subformulas are immediate to prove. 
 %In particular, note that any formula is a subformula of itself. It is also immediate to prove that if $\varphi$ is a subformula of $\phi$ and $\phi$ is a subformula of $\psi$, then $\varphi$ is a subformula of $\psi$ as well. In other worlds, the relation `being a subformula of' between modal formulas is transitive. Also note that the set of subformulas of any modal formula is finite. 

\begin{prop}[\holref{\texttt{subforms_phi_phi}}{chap2_3}{49},\holref{\texttt{subforms_trans}}{chap2_3}{69}, \holref{\texttt{subforms_FINITE}}{chap2_3}{75}]
Any formula is a subformula of itself; If $\varphi$ is a subformula of $\phi$ and $\phi$ is a subformula of $\psi$, then $\varphi$ is a subformula of $\psi$ as well; The set of subformulas of any modal formula is finite.

\begin{holmath}
  \HOLthm{chap2_3.subforms_phi_phi}\\[3mm]
  \HOLthm[varphi/f]{chap2_3.subforms_trans}\\[3mm]
  \HOLthm{chap2_3.subforms_FINITE}
\end{holmath}
\end{prop}

Sets of modal formulas which are \emph{closed under subformulas} are interesting to us.
% It means that for a set \HOLtm{Σ} which is closed under subformulas, we have \HOLtm{!phi. phi IN Σ ==> subforms phi ⊆ Σ}. In particular, for any modal formula, \HOLtm{phi}, \HOLtm{subforms phi} is a set which is closed under subformulas.

\begin{defn}[\holref{Closed under subformulas}{chap2_3}{89}]
A set \HOLtm{Σ} of modal formulas is called `closed under subformula' if for any \HOLtm{phi IN Σ}, every subformula of \HOLtm{phi} is contained in \HOLtm{Σ} as well.
\begin{holmath}
  \HOLthm[def,phi/f,psi/f']{chap2_3.CUS_def}
\end{holmath}
\end{defn}

The above definition gives that for a set \HOLtm{Σ} which is closed under subformulas, we have \HOLtm{!phi. phi IN Σ ==> subforms phi ⊆ Σ}. In particular, for any modal formula, \HOLtm{phi}, \HOLtm{subforms phi} is a set which is closed under subformulas. Given a set \HOLtm{Σ} of modal formulas and a model \HOLtm{M}, we can define a relation between worlds in the model \HOLtm{M} by relating \HOLtm{w1} to \HOLtm{w2} if and only if for they agree on any formulas in \HOLtm{Σ}. This relation is expressed as follows:

\begin{defn}[\holref{Relation used to define filtration}{chap2_3}{95}]
\begin{holmath}
  \HOLthm[def]{prettyPrinting.ppREL_CUS_def}
\end{holmath}
\end{defn}

It is clear that for any set \HOLtm{Σ} of modal formulas and any model \HOLtm{M}, \HOLtm{REL_CUS Σ M} is an equivalence relation. Therefore, for any such \HOLtm{Σ} and \HOLtm{M}, we can taking quotient on the world set of \HOLtm{M} by \HOLtm{REL_CUS Σ M} to obtain a set of equivalence classes of worlds in \HOLtm{M}. 

\begin{defn}[\holref{Equivalence class under the relation}{chap2_3}{100}]
For a world \HOLtm{w IN M.frame.world}, \HOLtm{EC_CUS Σ M w} is the equivalence class it belongs to. 
\begin{holmath}
  \HOLthm[def]{chap2_3.EC_CUS_def}
\end{holmath}
\end{defn}

Of course, we can take the world set of our quotient model to be the set consists of elements of form \HOLtm{EC_CUS Σ M w}, for \HOLtm{w IN M.frame.world}, but then the model we get will have different type from the original model. It is very easy to stay in the same type: we can pick one representative from each equivalence class, and take the world set of our quotient model to be the set of such representatives. 

\begin{defn}[\holref{Representatives}{chap2_3}{103} and the \holref{set of representatives}{chap2_3}{106}]
For each equivalence class \HOLtm{EC_CUS Σ M w}, we denote its representative by \HOLtm{EC_REP Σ M w}, and the set of all these representatives is denoted as \HOLtm{EC_REP_SET Σ M}. 
\begin{holmath}
  \HOLthm[def]{chap2_3.EC_REP_def}\\[3mm]
  \HOLthm[def]{chap2_3.EC_REP_SET_def}
\end{holmath}
\end{defn}
 
Now we are ready to introduce the definition of filtration. 
%For a model \HOLtm{M}, and a set \HOLtm{Σ} which is closed under subformulas, a model \HOLtm{L} is called a filtration of \HOLtm{M} via \HOLtm{Σ} if the world set of \HOLtm{L} is \HOLtm{EC_REP_SET Σ M}, just as defined above, and moreover, we require extra conditions on the relation and valuation of \HOLtm{L} to be satisfied. For the relation on \HOLtm{L}, it needs to satisfy the following two properties: Firstly, if $w,v$ are worlds in \HOLtm{M} such that \HOLtm{M.frame.rel w v}, then the world \HOLtm{EC_REP Σ M w} must be related to the world \HOLtm{EC_REP Σ M v} in \HOLtm{L}. Secondly, if $w,v$ are worlds in \HOLtm{M} such that  \HOLtm{EC_REP Σ M w} is related to \HOLtm{EC_REP Σ M v} in \HOLtm{L}, then for any formula \HOLtm{psi}, if \HOLtm{psi} is satisfied at \HOLtm{v} in \HOLtm{M}, then \HOLtm{DIAM psi} must be satisfied at \HOLtm{w} in \HOLtm{M}. For the valuation on \HOLtm{L}, we require a propositional letter $p$ is true at a world $s$ of \HOLtm{L} if and only if \HOLtm{s} is the representative of an equivalence class of worlds satisfying the propositional letter $p$. We define filtration as a predicate below, where \HOLtm{filtration M Σ L} reads \HOLtm{L} is a filtration of \HOLtm{M} via \HOLtm{Σ}. 

\begin{defn}[\holref{Filtration}{chap2_3}{258}]
We define filtration as a predicate, where \HOLtm{filtration M Σ L} reads \HOLtm{L} is a filtration of \HOLtm{M} via \HOLtm{Σ}. For a model \HOLtm{M}, and a set \HOLtm{Σ} which is closed under subformulas, a model \HOLtm{L} is called a filtration of \HOLtm{M} via \HOLtm{Σ} if the world set of \HOLtm{L} is \HOLtm{EC_REP_SET Σ M} as defined above, and moreover, we require extra conditions on the relation and valuation of \HOLtm{L} to be satisfied. For the relation on \HOLtm{L}, it needs to satisfy the following two properties: Firstly, if $w,v$ are worlds in \HOLtm{M} such that \HOLtm{M.frame.rel w v}, then the world \HOLtm{EC_REP Σ M w} must be related to the world \HOLtm{EC_REP Σ M v} in \HOLtm{L}. Secondly, if $w,v$ are worlds in \HOLtm{M} such that  \HOLtm{EC_REP Σ M w} is related to \HOLtm{EC_REP Σ M v} in \HOLtm{L}, then for any formula \HOLtm{psi}, if \HOLtm{psi} is satisfied at \HOLtm{v} in \HOLtm{M}, then \HOLtm{DIAM psi} must be satisfied at \HOLtm{w} in \HOLtm{M}. For the valuation on \HOLtm{L}, we require a propositional letter $p$ is true at a world $s$ of \HOLtm{L} if and only if \HOLtm{s} is the representative of an equivalence class of worlds satisfying the propositional letter $p$.
\begin{holmath}
  \HOLthm[def]{prettyPrinting.ppfiltration_def}
\end{holmath}
\end{defn}

We observe that once \HOLtm{M} and \HOLtm{Σ} is fixed, then the world set and valuation of any filtrated model of \HOLtm{M} via \HOLtm{Σ} will both be fixed, so the only thing that may vary is the relation. Indeed, it is possible to get filtrated models of such an \HOLtm{M} and \HOLtm{Σ} with their relations defined differently. Sometimes the model \HOLtm{M} we start with has some interesting property about its relation. For instance, the relation on \HOLtm{M} may be transitive or symmetric. However, it is not the fact that every filtration will preserve these properties. Nevertheless, there exists good relations on \HOLtm{EC_REP_SET Σ M} which preserves these two properties respectively. 


If \HOLtm{M} is a model with transitive relation on its world set and \HOLtm{Σ} is subformula-closed, consider firstly the relation \HOLtm{REL_2_42 Σ M} defined on the set of equivalence classes:
\begin{defn}[\holref{\texttt{REL_2_42_def}}{chap2_3}{436}]
Two equivalence class $w_1,w_2$ are related if and only if there exists worlds $w,v$ of \HOLtm{M} such that \HOLtm{w1 = EC_CUS Σ M w} and \HOLtm{w2 = EC_CUS Σ M v}, where $w,v$ satisfies the condition that for any formula \HOLtm{(DIAM phi) IN Σ} such that $\phi\lor \Diamond \phi$ is satisfied at $v$, we have \HOLtm{satis M w (DIAM phi)}.
\begin{holmath}
  \HOLthm[def]{prettyPrinting.ppREL_2_42_def}
\end{holmath}
\end{defn}
% Two equivalence class $w_1,w_2$ are related if and only if there exists worlds $w,v$ of \HOLtm{M} such that \HOLtm{w1 = EC_CUS Σ M w} and \HOLtm{w2 = EC_CUS Σ M v}, where $w,v$ satisfies the condition that for any formula \HOLtm{(DIAM phi) IN Σ} such that $\phi\lor \Diamond \phi$ is satisfied at $v$, we have \HOLtm{satis M w (DIAM phi)}. 

Then define two elements of \HOLtm{EC_REP_SET} to be related if and only if they belongs to equivalence classes related by \HOLtm{REL_2_42 Σ M}. We can prove this is a relation that gives filtration and also preserves transitivity of the model \HOLtm{M}, as follows:

\begin{thm}[\holref{\texttt{thm_2_42_i}}{chap2_3}{471}]
\begin{holmath}
  \HOLthm{chap2_3.thm_2_42_i}
\end{holmath}
\end{thm}

\begin{thm}[\holref{\texttt{thm_2_42_ii}}{chap2_3}{442}]
\begin{holmath}
  \HOLthm{chap2_3.thm_2_42_ii}
\end{holmath}
\end{thm}

If we are given a model \HOLtm{M} whose relation is symmetric, and \HOLtm{Σ} is closed under subformulas. Then we can define the relation as two worlds $n_1,n_2$ in \HOLtm{EC_REP_SET} are related if and only if there exists worlds $w_1,w_2$ of \HOLtm{M} such that $n_1,n_2$ represents the equivalence classes of $w_1,w_2$ respectively, and moreover, there exists worlds $w',v'$ of \HOLtm{M} such that $w'$ is in the equivalence class of $w_1$, $v'$ is in the equivalence class of $w_2$, and there is a relation from $w'$ to $v'$ in \HOLtm{M}. We will use such a relation to construct the model which we will use to prove the finite model property in the rest of the section.

% For convenience, we define a function \HOLtm{FLT} which takes a model \HOLtm{M}, a set \HOLtm{Σ} of modal formulas, and give the a model constructed using the relation defined just in this paragraph. 

\begin{defn}[\holref{The filtration model we will use}{chap2_3}{366}]
The function \HOLtm{FLT} which takes a model \HOLtm{M}, a set \HOLtm{Σ} of modal formulas, and give the a model constructed using the relation defined above. 
\begin{holmath}
  \HOLthm[def]{chap2_3.FLT_def}
\end{holmath}
\end{defn}

\begin{prop}[\holref{\texttt{FLT_EXISTS}}{chap2_3}{377}]
If \HOLtm{Σ} is closed under subformula, then \HOLtm{FLT M Σ} is indeed a filtration. 

\begin{holmath}
  \HOLthm{chap2_3.FLT_EXISTS}
\end{holmath}
\end{prop}



There are two interesting properties of filtration of models that directly lead to the proof of finite model property.

\begin{prop}[\holref{\texttt{prop_2_38}}{chap2_3}{311}]
Firstly, filtrating a model using a finite set gives a finite model. 
\begin{holmath}
  \HOLthm{prettyPrinting.ppprop_2_38}
\end{holmath}
\end{prop}

\begin{proof}
As \HOLtm{Σ} is finite, it suffices to give an injection from the world set of $L$ to \HOLtm{POW Σ}. Such an injection is given by \HOLtm{λw. {phi | phi IN Σ /\ satis M w phi\}}. 
\end{proof}


\begin{thm}[\holref{\texttt{thm_2_39}}{chap2_3}{321}]
Secondly, the satisfaction of modal formula is preserved under filtration.
\begin{holmath}
  \HOLthm{prettyPrinting.ppthm_2_39}
\end{holmath}
\end{thm}
\begin{proof}
By induction on modal formula. 
\end{proof}

Putting the above two theorems together yields the finite model property via filtration:
\begin{thm}[\holref{\texttt{thm_2_41}}{chap2_3}{418}]
\begin{holmath}
  \HOLthm[N/M',v/w']{chap2_3.thm_2_41}
\end{holmath}
\end{thm}

\begin{proof}
By \texttt{prop_2_38} and \texttt{thm_2_39} above, we can take \HOLtm{M'} to be \HOLtm{FLT M (subforms phi)}. 
\end{proof}

\section{Finite model property via selection}

Another method to build finite models for an arbitary model is by selection. In this method, to build a finite model of a satisfiable modal formula \HOLtm{phi}, we start with a model that the formula $\phi$ is satisfied, delete worlds from the model and only leaves finitely many worlds in it. The intuition behind this approach is that any modal formula can only contain finitely many diamond, each can `see' one step from the current state. Therefore, any formula can only capture the information of finitely depth. To make the notion of `depth' precise, we define the degree of a modal formula, which counts the number of diamonds appear in a model formula, in the sense that a modal formula \HOLtm{phi} has degree $n$ means there are $n$ `$\Diamond$'s in \HOLtm{phi}. In particular, a modal formula of degree zero is a modal formula with no diamond. Such a formula is precisely a propositional formula. 
\begin{defn}[\holref{Degree of a modal formula}{chap2_3}{24}]
\begin{holmath}
  \HOLthm[def,phi/form]{chap2_3.DEG_def}
\end{holmath}
\end{defn}

For our proof of finite model property, the crucial fact we need about the degree of formulas is that for any finite $\alpha$-set $s$ and any natural number $n$, there are only finitely many non-equivalent modal formulas of $n$ which only use the propositional letters in $s$. In the textbook that we are following, the authors prove this fact basically `by observation'. However, the detailed proof is long and technical. We discuss it in the following interlude.



\subsection{Interlude I: Finiteness of non-equivalent modal formulas in each degree}

In this interlude, our goal is to give a formal proof of:

\begin{lm}[\holref{\texttt{prop_2_29_strengthen}}{chap2_3}{989}]
For a finite $\alpha$-set $s$, if $\beta$ is an infinite type, then for any natural number $n$, if we partition the set of $\alpha$-modal formulas using only propositional letters in $s$ of degree up to $n$ using the equivalence relation of `being equivalent on models with $\beta$-world sets', then we get finitely many equivalence class. 
\begin{holmath}
  \HOLthm[phi/f]{prettyPrinting.ppprop_2_29_strengthen}
\end{holmath}
\end{lm}

Here the `$// E\ \mu$' denotes the operation of taking the partition of the set \HOLtm[phi/f]{{f | DEG f <= n /\ prop_letters f ⊆ s\}} by the equivalence relation \HOLtm{equiv0 μ}, where $\mu$ denote the type $\beta$ itself. We require the assumption that $\beta$ is an infinite since we will need to use \texttt{equiv0_DIAM}. The proof of this lemma is by induction on the degree $n$. Throughout the discussion, any modal formula is an $\alpha$-formula, for a fixed type $\alpha$. 

\subsubsection{Base case}

For the base case, we need to prove if we only use propositional letters in $s$ where $s$ is a finite set, then up to equivalence, we can only obtain finitely many propositional formulas. To prove this, it suffices to find out an injection from the set of equivalence classes of propositional formulas that only uses propositional letters in $s$, which is the set \HOLtm[phi/f]{{f | propform f /\ prop_letters f ⊆ s\} //E μ}, to a finite set. Our claim that the target set can be taken as the iterated power set \HOLtm{(POW (POW (POW s)))}, which is finite because $s$ is, and the injection can be taken as sending a equivalence class to its image under the function \HOLtm{(λphi. {σ| peval σ phi\} INTER (POW s))}. 


%Our claim is that the function  \HOLtm{(\eqc. ((IMAGE (λf. {s| peval s f\} INTER (POW s)) eqc)))} is an injection from our set from \HOLtm{{f | propform f /\ prop_letters f ⊆ s\}//e} to the set \HOLtm{(POW (POW (POW s)))}, which is finite because $s$ is.

%We will prove the function that sends an equivalence class of formulas to its image under the function $\lambda f. \{\sigma \mid peval\ \sigma\ f\} \cap (POW \ s)$, which sends a formula $f$ to the set $\{\sigma \mid peval\ \sigma\ f\} \cap (POW \ s)$ of assignments of truth value on propositional letters in $s$ that makes $f$ holds, is an injection to the finite set \HOLtm{POW(POW(POW(s)))}. We can see the function we define has correct codomain: A formula $f$ is sent to a set of subsets of $s$, which is an element of \HOLtm{POW(POW(s))}, so a equivalence class has image as a set of elements in \HOLtm{POW(POW (s))}, which lies in \HOLtm{POW(POW(POW(s)))}.


It is easy to check the function has correct codomain. Let us make sense of what does the function \HOLtm{(λphi. {σ| peval σ phi\} INTER (POW s))} do by investigating it piece by piece. Firstly, consider the set \HOLtm{{σ| peval σ phi\}}, an element $\sigma$ of it is a term of type $\alpha \to bool$, in other words, is an assignment of truth values on all the terms of type $\alpha$, with the additional property that the propositional formula $\phi$ is true under this assignment. For two equivalent propositional formulas $\phi_1$ and $\phi_2$, the set of assignment of truth values on propositional symbols which makes them true are the same. This is the following proposition:

\begin{prop}[\holref{\texttt{peval_equiv0}}{chap2_3}{601}]
\begin{holmath}
  \HOLthm{prettyPrinting.pppeval_equiv0}
\end{holmath}
\end{prop}

\begin{proof}
Under the assumptions, if we have some $\sigma$ such that \HOLtm{peval σ f1 /\ ¬peval σ f2}, then we can construct a model with only one world $w$, no relation, and define the valuation at $w$ to be \HOLtm{M.valt w = σ}. Using \texttt{peval_satis_strengthen'} by taking the \HOLtm{s} there to be \HOLtm{univ (:α)}, we get \HOLtm{satis M w f1 /\ ¬satis M w f2}, a contradiction.
\end{proof}

As for any equivalence class in the set \HOLtm[phi/f]{{f | propform f /\ prop_letters f ⊆ s\}//E μ}, all the member of the equivalence class are equivalent. We obtain the following as a consequence of the statement above:

\begin{prop}[\holref{\texttt{IMAGE_peval_singlton_strengthen}}{chap2_3}{646}]
The image of each equivalence class under \HOLtm[phi/f]{(λf. {σ| peval σ f\} INTER (POW s))} is the singleton \HOLtm[phi/f]{{ {σ | peval σ f\} INTER (POW s)\}}.
\begin{holmath}
  \HOLthm[phi/f,psi/form]{prettyPrinting.ppIMAGE_peval_singlton_strengthen}
\end{holmath}
\end{prop} 

Let us look at what are the elements in the intersection \HOLtm{{ {σ | peval σ phi\} INTER (POW s)\}} for a modal formula $\phi$. For a set $s$, its power set \HOLtm{POW s} is the set of subsets of $s$. In HOL4, a set of type $\alpha$ is identified with its characteristic function, which is a term of type $\alpha\to bool$. Hence a subset of $s_0\subset s$ \emph{is} a function $f_{s_0}$ that assigns truth values to elements of $s$: for any element $a\in S$, $f_{s_0}$ assigns $a$ the boolean value \HOLtm{T} if and only if $a\in s_0$. Therefore, we can view \HOLtm{POW s} as the $\alpha\to bool$-set consists of assignments of truth value to the variables of type $\alpha$ such that only elements in $s$ are possible to be assigned to the boolean value \HOLtm{T}. It follows that in rather natural language, the intersection \HOLtm{{ {σ | peval σ phi\} INTER (POW s)\}} can be described as the set of `assignments of the truth value on elements of $s$ which makes $\phi$ true'. 

Having known that what does the function that sends a equivalence class to its image under \HOLtm{\phi.{ {σ | peval σ phi\} INTER (POW s)\}} do, let us prove its injectivity. 

\begin{prop}[\holref{\texttt{INJ_peval_partition_strengthen}}{chap2_3}{669}]
\begin{holmath}
  \HOLthm[phi/f]{prettyPrinting.ppINJ_peval_partition_strengthen}
\end{holmath}
\end{prop}
\begin{proof} 
If two equivalence classes represented by $\phi_1$ and $\phi_2$ respectively has identical image under the given function, by \texttt{IMAGE_peval_singlton_strengthen}, it gives \HOLtm{{s| peval s f1\} INTER (POW s) = {s| peval s f2\} INTER (POW s)}.This means \HOLtm{!σ. σ IN (POW s) ==> peval σ f1 <=> peval σ f2}.  Hence for any model \HOLtm{M} and any world \HOLtm{w IN M.frame.world}, we have \HOLtm{peval ((λa. w IN M.valt a) INTER s) f1 = peval ((λa. w IN M.valt a) INTER s) f2}. The result follows from \texttt{peval_satis_strengthen'}.
\end{proof}

This complete the proof of base case. 

\subsubsection{Step case}

The idea we use in the proof of the step case is completely different from that of base case. The key observation that any formulas which only uses propositional letters in a fixed finite set $s$ and of degree no more than $n+1$ is obtained by applying $\lnot$ and $\lor$ to combin the propositional letters in $s$ and formulas of form \HOLtm{DIAM phi} for \HOLtm{phi} of degree no more than $n$ which only uses propositional letters in $s$. Such a combination is called a \emph{boolean combination}. 

\begin{defn}[\holref{Rules of boolean combination}{IBCDNFrevised}{513}]
We define boolean combination as an inductive relation taking a modal formula and a set of modal formulas, where \HOLtm{IBC phi phis} reads `$\phi$ is a boolean combination of modal formulas in the set $\phi s$':
\[
\begin{array}{c}
  \HOLthm[rule,conj1,fs/s]{IBCDNFrevised.IBC_rules} \ \ \ \ \ 
  \HOLthm[rule,conj2,width=30,fs/s]{IBCDNFrevised.IBC_rules} \ \ \ \ \ 
  \HOLthm[rule,conj3,width=20,fs/s,phi/f]{IBCDNFrevised.IBC_rules} \ \ \ \ \
  \HOLthm[rule,conj4,width=80,fs/s,phi/f]{IBCDNFrevised.IBC_rules}
\end{array}
\]
For the syntax of the above, the antecedent is above the line, and the conclusion is below the line. For instance, the first rule is read as `if both $\phi_1$ and $\phi_2$ are a boolean combinations of the set $\phi s$, then the disjunction of $\phi_1$ and $\phi_2$ is again a boolean combination of $\phi s$'.
\end{defn}



We can easily observe:

\begin{lm}[\holref{\texttt{IBC_EMPTY_Lemma}}{chap2_3}{755}]
By boolean combination on an empty set, we can only get two non-equivalent formulas `$\top$' and `$\bot$'. 
\begin{holmath}
  \HOLthm[phi/f,fs/s]{chap2_3.IBC_EMPTY_lemma}
\end{holmath}
\end{lm}

As for our `key observation' claimed at the beginning of this subsection, it is stated as:
\begin{prop}[\holref{\texttt{DEG_IBC_strengthen}}{chap2_3}{704}]
\begin{holmath}
  \HOLthm[phi/x]{prettyPrinting.ppDEG_IBC_strengthen}
\end{holmath}
\end{prop}

\begin{proof}
By rule induction on boolean combination. 
\end{proof}

By the proposition above, to prove the induction step for the main theorem we are aiming to prove, it suffices to prove that the set of formulas obtained by boolean combinations from a set that contains only finitely non-equivalent formulas is again a set contains only finitely many non-equivalent formulas. By \texttt{IBC_EMPTY_lemma}, this statement trivially holds when the set that we are taking boolean combination is empty. Therefore, we have reduced our goal into proving the following lemma:

\begin{lm}[\holref{\texttt{FINITE_FINITE_IBC}}{chap2_3}{835}]
\begin{holmath}
  \HOLthm[phi/f]{prettyPrinting.ppFINITE_FINITE_IBC}
\end{holmath}
\end{lm}

The lemma above admits a further reduction: It suffices to prove that the boolean combination on a finite set yields a set with only finitely many non-equivalent formulas. To see why it suffices, suppose we get our last sentence proved, then to prove the lemma above, assume \HOLtm{fs} is a set of modal formulas where only finitely many of them are non-equivalent, then the set \HOLtm{IMAGE CHOICE (fs // E μ)} formed by pick one representative from each of these equivalence class is finite, so by assumption, \HOLtm[phi/f]{({f | IBC f (IMAGE CHOICE fs//e)\}//e)} is finite. It is straightforward to show that the function \HOLtm[psi/y,phi/f]{\eqc. {y | IBC y fs /\ !f. f IN eqc ==> equiv0 μ y f\}} from 
\HOLtm[phi/f]{({f | IBC f (IMAGE CHOICE fs//e)\}//e)} to \HOLtm[phi/f]{({f | IBC f fs\}//e)} is a surjection. Hence we can conclude the codomain is finite. 


The strategy we used to prove our further reduced goal is to prove two lemmas: Firstly, any formula obtained by a boolean combination on a set $\phi s$ is equivalent to a formula in \emph{disjunction normal form} on $\phi s$. Secondly, if $\phi s$ is finite, then formulas of disjunction normal form on $\phi s$ is finite. The disjunction normal form is defined by:
\begin{defn}[\holref{Disjunction normal form}{IBCDNFrevised}{690}]
\begin{holmath}
  \HOLthm[def,phi/f]{IBCDNFrevised.DNF_OF_def}
\end{holmath}
\end{defn}
The definition has two layers. Just as the boolean combination we defined before, the inner layer \HOLtm{CONJ_OF} is also an inductively defined predicate which takes a formula and a set. The rules of \HOLtm{CONJ_OF} is given as follows:
\begin{defn}[\holref{Rules of \HOLtm{CONJ_OF}}{IBCDNFrevised}{204}]
The only two \HOLtm{CONJ_OF} formulas on a singleton set \HOLtm{c0} where \HOLtm{c0} is a modal formula are \HOLtm{c0} itself and its negation. If \HOLtm{phi} is an element of a set \HOLtm{phis} of modal formulas, then if \HOLtm{phi1} is \HOLtm{phi} or its negation, then for any \HOLtm{phi2} such that \HOLtm{phi2} is a \HOLtm{CONJ_OF} formula on $\phi s \setminus \{\phi\}$, we have the conjunction of \HOLtm{phi1} and \HOLtm{phi2} is a \HOLtm{CONJ_OF} formula on \HOLtm{phis}. 
\[
\begin{array}{c}
  \HOLthm[rule,conj1]{IBCDNFrevised.CONJ_OF_rules}\\[3mm]
  \HOLthm[rule,conj2,width=80,phi/f0]{IBCDNFrevised.CONJ_OF_rules}\\
\end{array}
\]
Here $\sf DELETE$ is the function that deleting an element from a set.
\end{defn}

As an example, the four \HOLtm{CONJ_OF} formulas on the set $\{f_1,f_2\}$ are \HOLtm{AND f1 f2}, \HOLtm{AND (NOT f1) f2}, \HOLtm{AND f1 (NOT f2)} and \HOLtm{AND (NOT f1) (NOT f2)}. For another example, consider the set $\phi s:=\{\phi_1,\phi_2,\phi_3\}$ of three formulas, we can say \HOLtm{CONJ_OF (AND f3 (AND f1 f2)) fs}, \HOLtm{CONJ_OF (AND f2 (AND (NOT f1) f3)) fs}, \HOLtm{CONJ_OF (AND (NOT f3) (AND f2 f1)) fs} and so on. But it is not the fact that \HOLtm{CONJ_OF f1 fs}, since from the definition, any element of fs or its negation must appear exactly once in a \HOLtm{CONJ_OF} formula on $\phi s$.



For the inner layer, we say \HOLtm{DISJ_OF phi fs} when $\phi$ is either the `$\bot$' or a formula such that \HOLtm{DISJ_OF0 phi fs}, where the inductive relation of \HOLtm{DISJ_OF0} is given by:
\begin{defn}[\holref{Rules of \HOLtm{DISJ_OF0}}{IBCDNFrevised}{541}]
For a set \HOLtm{phis} of modal formulas, every element of \HOLtm{phis} is a \HOLtm{DISJ_OF0} formula on \HOLtm{phis}. If \HOLtm{phi1} is an element in \HOLtm{phis} and \HOLtm{phi2} is a \HOLtm{DISJ_OF0} formula on $\phi s\setminus \{\phi_1\}$, then the disjunction of \HOLtm{phi1} and \HOLtm{phi2} is a \HOLtm{DISJ_OF0} formula on \HOLtm{phis}. 
\[
\begin{array}{c}
  \HOLthm[rule,conj1,phi/f]{IBCDNFrevised.DISJ_OF0_rules}\\[3mm]
  \HOLthm[rule,conj2,width=80]{IBCDNFrevised.DISJ_OF0_rules}\\
\end{array}
\]
\end{defn}

There are some similarity between the definition of \HOLtm{CONJ_OF} and \HOLtm{DISJ_OF0}, since both of them requires the `non-repeatedness' of formulas which occurs in a conjunction and a disjunction, respectively. The main difference is that for a conjunction to be a \HOLtm{CONJ_OF} formula of $\phi s$, we require any element of $\phi s$ to appear exactly once in its either negated or unnegated form, whereas to be a \HOLtm{DISJ_OF0} formula of \HOLtm{DISJ_OF0} formula of \HOLtm{fs}, we allow some elements of $\phi s$ not to appear in the formula at all. Also observe that when $\phi\in \phi s$ and $\lnot \phi\notin \phi s$, we do not even allow $\lnot \phi$ to appear in the disjunction for a \HOLtm{DISJ_OF0} formula, whereas the counterpart for conjunction is allowed for a \HOLtm{CONJ_OF} formula. 

Continue with our example as for \HOLtm{CONJ_OF}, let \HOLtm[phi/f]{A = {f | CONJ_OF f fs\}}, then we can say \HOLtm{DISJ_OF (DISJ (AND f3 (AND f1 f2)) (AND f2 (AND (NOT f1) f3))) A}, \HOLtm{DISJ_OF (AND f2 (AND (NOT f1) f3)) A} and so on, so both these two formulas are disjunction normal form on $fs$, but it is neither the case that \[\HOLtm{DISJ_OF (DISJ (AND f2 (AND (NOT f1) f3)) (AND f2 (AND (NOT f1) f3))) A}\] nor \[\HOLtm{DISJ_OF (DISJ (AND f2 (AND (NOT f1) f3)) (NOT (AND f2 (AND (NOT f1) f3)))) A}\], since any formula in $K$ or its negation is only allowed to appear in a \HOLtm{DISJ_OF} formula on $K$ for at most once, so these two are not in disjunction normal form.

If we start with a finite set $\phi s$, by complete induction on finiteness, we can consecutively prove the set of \HOLtm{CONJ_OF} formulas on $\phi s$, the \HOLtm{DISJ_OF0} formulas on \HOLtm{{phi | CONJ_OF phi fs\}} and the \HOLtm{DNF_OF} formulas on $\phi s$ are all finite. 
\begin{prop}[\holref{\texttt{FINITE_CONJ_OF}}{IBCDNFrevised}{223},\holref{\texttt{FINITE_DISJ_OF0}}{IBCDNFrevised}{551},\holref{\texttt{FINITE_DNF}}{761}]
For a finite set $\phi s$, the set of \HOLtm{CONJ_OF} formulas on $\phi s$, the \HOLtm{DISJ_OF0} formulas on \HOLtm{{phi | CONJ_OF phi fs\}} and the \HOLtm{DNF_OF} formulas on $\phi s$ are all finite. 
\begin{holmath}
  \HOLthm[fs/s,phi/f]{IBCDNFrevised.FINITE_CONJ_OF}\\[3mm]
  \HOLthm[fs/s,phi/f]{IBCDNFrevised.FINITE_DISJ_OF0}\\[3mm]
  \HOLthm[phi/f]{chap2_3.FINITE_DNF}
\end{holmath}
\end{prop}

\begin{proof}
By complete induction on finiteness of \HOLtm{phis}. 
\end{proof}


By the finiteness of the set of \HOLtm{DNF_OF} formulas on a finite set, to prove the further reduction from \texttt{FINITE_FINITE_IBC}, it suffices to prove:
\begin{thm}[\holref{\texttt{IBC_DNF_EXISTS}}{IBCDNFrevised}{1813}]
For any finite, nonempty set \HOLtm{phis} of modal formulas, any formula which can be obtained from boolean combination on \HOLtm{phis} is equivalent to a \HOLtm{DNF_OF} formula on \HOLtm{phis}. 
\begin{holmath}
  \HOLthm[phi/f]{IBCDNFrevised.IBC_DNF_EXISTS}
\end{holmath}
\end{thm}

Therefore, it remains to give a proof of \texttt{IBC_DNF_EXISTS}. The inductive rule of boolean combination gives the following subgoals:

Base case:
\begin{itemize}
  \item The falsity $\bot$ is equivalent to a disjunction normal form on $\phi s$.
  \item For any element $\phi\in \phi s$, it is equivalent to a disjunction normal form on $\phi s$.
\end{itemize}

Step case:

\begin{itemize}
  \item Under the assumption that $\phi s$ is finite and non-empty, if $\phi_1,\phi_2$ are boolean combination of the set $\phi s$ which are equivalent to $\psi_1,\psi_2$ of disjunction normal form respectively, then \HOLtm{DISJ f1 f2} is equivalent to a formula in disjunction normal form.
  \item With the same assumption on $\phi s$, if $\phi$ is a boolean combination of $\phi s$ and equivalent to $\psi$ in disjunction normal form, then \HOLtm{NOT phi} is equivalent to a formula in disjunction normal form.
\end{itemize}


The first item of base case is trivial since $\bot$ itself is in disjunction normal form, we devote to prove the other three cases in the next three subsections. 

\subsubsection{Case for $\phi\in \phi s$}

We aim to prove:
\begin{lm}[\holref{\texttt{IBC_DNF_EXISTS_case4}}{IBCDNFrevised}{721}]
For finite and non-empty \HOLtm{phis}, every formula in \HOLtm{phis} is equivalent to a \HOLtm{DNF_OF} formula on \HOLtm{phis}. 
\begin{holmath}
  \HOLthm[phi/f,psi/p]{IBCDNFrevised.IBC_DNF_EXISTS_case4}
\end{holmath}
\end{lm}

Let us consider what does the \HOLtm{DNF_OF} formula $\psi$ on $\psi s$ that is equivalent to an element $\phi\in \phi s$ look like: We require $\psi$ to be satisfied if and only if $\phi$ is satisfied. As $\psi$ is in disjunction normal form, $psi$ is satisfied once some of its disjuncts is satisfied. Hence we require the satisfaction of each disjuncts of $\psi$ to imply the satisfaction of $\phi$, that is, $\phi$ is a conjunct of each disjunct of $\psi$. So up to rearrangement, $\psi$ is a disjunction of conjunctions $\phi\land \phi_1\cdots \phi_n$ where for each formula in $\phi s\setminus\{\phi\}$, either itself or its negation appears exactly once as some $\phi_i$. Therefore, the formula $\psi$ is equivalent to $\phi\land \varphi$, where $\varphi$ is the disjunction of the formulas obtained by taking $\phi$ out of each conjunct of $\psi$. As $\phi\land \varphi$ is equivalent to $\phi$ if and only if $\varphi$ is equivalent to $\top$, $\varphi$ must be the disjunction of all the \HOLtm{CONJ_OF} formulas on $\phi s \setminus \{\phi\}$. By conclusion, a disjunction normal form we need can be taken as the disjunction of conjunctions starting with $\phi$, with its tail ranging over all possible combination of negated and unnegated formulas in $\phi s \setminus \{\phi\}$. 

As an example, when $\phi s=\{\phi_1,\phi_2,\phi_3\}$, a formula in disjunction normal form on $\phi s$ which is equivalent to $\phi_1$ can be taken as $(\phi_1\land \phi_2\land \phi_3)\lor (\phi_1\land\lnot \phi_2\land \phi_3)\lor (\phi_1\land \phi_2\land \lnot \phi_3)\lor (\phi_1\land \lnot \phi_2\land\lnot \phi_3)$, note that such a formula is equivalent to $\phi_1\land ((\phi_2\land \phi_3)\lor (\lnot \phi_2\land \phi_3)\lor (\phi_2\land \lnot \phi_3)\lor (\lnot \phi_2\land \lnot \phi_3))$, where $(\phi_2\land \phi_3)\lor (\lnot \phi_2\land \phi_3)\lor (\phi_2\land \lnot \phi_3)\lor (\lnot \phi_2\land \lnot \phi_3)$ is equivalent to \HOLtm{TRUE}.

To formalise the idea above, we want to be able to build formulas in disjunction normal form piece by piece. Firstly, to construct \HOLtm{DISJ_OF} formula on $\phi s$, we can just take a list of elements in $\phi s$ and take their disjunction inductively by defining the function \HOLtm{lit_list_to_form2}, which is a shorthand of `list to formula', as below:


\begin{defn}[\holref{A list of formulas to a disjunction}{IBCDNFrevised}{579}]
\begin{holmath}
  \HOLthm[def,phi/fb,phil1/v2,phil2/v3]{IBCDNFrevised.lit_list_to_form2_def}
\end{holmath}
\end{defn}

For example, we have  \HOLtm{lit_list_to_form2 [phi1;phi2;phi3;phi4] = DISJ phi1 (DISJ phi2 (DISJ phi3 phi4))}.

Now let us consider how to build \HOLtm{CONJ_OF} formulas piece by piece. For each conjunct of a \HOLtm{CONJ_OF} formula, it consists of two pieces of information, namely the formula in $\phi$ and `either it is negated or not'. Hence we use a pair $(\phi,tv)$, where $\phi$ is a formula, and $tv$ is a boolean value, which is either \HOLtm{T} or \HOLtm{F}, to encode these two pieces of information at the same time, such a pair is called a \emph{literal}. Such a pair encodes a formula: $(\phi,\sf T)$ encodes the formula $\phi$, and $(\phi,\sf F)$ encodes the formula $\lnot f$. The function \HOLtm{negf} defined below is used to turn a literal into a formula. With help of the function \HOLtm{negf}, we can define a function that builds \HOLtm{CONJ_OF} formulas from list of literals. The name of our function is a shorthand of `literal list to formula':

\begin{defn}[\holref{A list of literals to a conjunctions}{IBCDNFrevised}{289}]
\begin{holmath}
  \HOLthm[def,phi/f]{IBCDNFrevised.negf_def}\\[3mm]
  \HOLthm[def,l/fb,ls1/v2,ls2/v3]{IBCDNFrevised.lit_list_to_form_def}
\end{holmath}
\end{defn}

For example, we have \HOLtm{lit_list_to_form [(phi1,T);(phi2,F);(phi3,T);(phi4,T)]= AND phi1 (AND (NOT phi2) (AND phi3 phi4))}. 

For both of \HOLtm{lit_list_to_form} and \HOLtm{lit_list_to_form2}, they are just functions from the universe of list of formulas or list of literals to the universe of formulas. To actually get \HOLtm{CONJ_OF} and \HOLtm{DISJ_OF0} formulas, we require extra condition on the lists that we feed to the functions. 


%To build a \HOLtm{CONJ_OF} formula on a finite set $fs$, we require a list $l$ of literals with the conditions \HOLtm{set (MAP FST l) =fs} and \HOLtm{ALL_DISTINCT (MAP FST l)}. Here \HOLtm{MAP} takes a function $f$ and a list $[a_1;\cdots,a_n]$, and return the list $[f(a_1);\cdots;f(a_n)]$. The function \HOLtm{set} takes a list and gives the set of its members, and \HOLtm{ALL_DISTINCT} is a predicate that takes a list, and return $\top$ iff all members of the list are distinct. These conditions precisely say that each member of $fs$ occurs exactly once as the first coordinate of some member of the list $l$. Conversely, each \HOLtm{CONJ_OF} formula can be obtained from such a list.
\begin{prop}[\holref{\texttt{list_to_CONJ_OF}}{IBCDNFrevised}{332}]
To build a \HOLtm{CONJ_OF} formula on a finite set $fs$, we require a list $l$ of literals with the conditions \HOLtm{set (MAP FST l) =fs} and \HOLtm{ALL_DISTINCT (MAP FST l)}. 
\begin{holmath}
  \HOLthm{IBCDNFrevised.list_to_CONJ_OF}
\end{holmath}
Here \HOLtm{MAP} takes a function $f$ and a list $[a_1;\cdots,a_n]$, and return the list $[f(a_1);\cdots;f(a_n)]$. The function \HOLtm{set} takes a list and gives the set of its members, and \HOLtm{ALL_DISTINCT} is a predicate that takes a list, and return $\top$ iff all members of the list are distinct.
\end{prop}

The conditions required by the proposition above precisely say that each member of $fs$ occurs exactly once as the first coordinate of some member of the list $l$. 
Conversely, each \HOLtm{CONJ_OF} formula can be obtained from a list with those conditions satisfied. 
\begin{prop}[\holref{\texttt{CONJ_OF_AND_lemma}}{IBCDNFrevised}{310}] 
For any \HOLtm{CONJ_OF} formula on a set \HOLtm{phis}, there exists a list $l$ of literals such that all the members of $l$ have distinct first coordinate, and if we collect the first coordinate of each member of \HOLtm{l} into a set, the set we get will be \HOLtm{phis} itself. 
\begin{holmath}
  \HOLthm[phi/f]{IBCDNFrevised.CONJ_OF_AND_lemma}
\end{holmath}
\end{prop}

We have a similar correspondence between \HOLtm{DISJ_OF0} formulas on a set $\phi s$ and list of formulas with certain conditions.  


\begin{prop}[\holref{\texttt{list_to_DISJ_OF0}}{IBCDNFrevised}{641}]
Any list of elements in $fs$ with all its member distinct gives arise to a \HOLtm{DISJ_OF0} formula. 
\begin{holmath}
  \HOLthm{IBCDNFrevised.list_to_DISJ_OF0}
\end{holmath}
\end{prop}

\begin{prop}[\holref{\texttt{DISJ_OF0_DISJ_lemma_EQ}}{IBCDNFrevised}{608}]
Conversely, any \HOLtm{DISJ_OF0} formula on \HOLtm{phis} can be built from a list of formulas in \HOLtm{phis} with all distinct members.
\begin{holmath}
  \HOLthm[phi/f]{IBCDNFrevised.DISJ_OF0_DISJ_lemma_EQ}
\end{holmath}
\end{prop}

Put the two things together, we can build \HOLtm{DNF_OF} formula on a finite $\phi s$ by using lists as follows: Consider a non-empty list $ld$ of modal formulas, if for any member $d$ of $ld$, there exists a non-empty list $lc$ of literals satisfies the condition that is required in \texttt{list_to_CONJ_OF} such that $d$ is obtained by turning $lc$ into a formula, then each member $d$ of $ld$ is a \HOLtm{CONJ_OF} formula on $\phi s$, and hence if in addition, we have all the members of $ld$ are distinct, then by \texttt{list_to_DISJ_OF0}, we will get a \HOLtm{DNF_OF} formula on $\phi s$ by turning the list $ld$ into a formula using both \HOLtm{lit_list_to_form2}. This statement is captured as follows:

\begin{prop}[\holref{\texttt{list_to_DNF_lemma}}{IBCDNFrevised}{972}]
\begin{holmath}
  \HOLthm{IBCDNFrevised.list_to_DNF_lemma}
\end{holmath}
\end{prop}


Most of expected property of the functions \HOLtm{lit_list_to_form} and \HOLtm{lit_list_to_form2} can be proved by induction on list. Among these properties, the following two are especially useful:
\begin{prop}[\holref{\texttt{list_demorgan}}{IBCDNFrevised}{818}, \holref{\texttt{lit_list_to_form2_SYM}}{IBCDNFrevised}{1052}]
\begin{holmath}
  \HOLthm{prettyPrinting.pplist_demorgan}\\[3mm]
  \HOLthm{IBCDNFrevised.lit_list_to_form2_SYM}
\end{holmath}
\end{prop}

The first one captures a point of discussion at the beginning of this subsection. It says that a disjunction of formulas starts with `$a\land \cdots$' is equivalent to the formula obtained by taking the conjunction $a$  and the disjunction of the formulas formed by taking the conjunction to $a$ off the formulas of the form `$a\land \cdots$'.  For the second, it says that two lists with same member give arise of equivalent modal formulas when taking the disjunction of the lists, which is just saying that the disjunction operation on modal fomulas is commutative. 

Use the lemmas above, by induction on finiteness, we can prove another result illustrated in an example before. 

\begin{prop}[\holref{\texttt{ALL_POSSIBLE_VALUE_TRUE}}{IBCDNFrevised}{1311}]
The disjunction of all  is equivalent to the \HOLtm{CONJ_OF} formulas on a finite non-empty set $fs$ is equivalent to truth. 
\begin{holmath}
  \HOLthm{IBCDNFrevised.ALL_POSSIBLE_VALUE_TRUE}
\end{holmath}
\end{prop}

Here \HOLtm{SET_TO_LIST} is a function that takes a set, and give a list with the elements of the set as all its member with each of them appears exactly once. 

Now we launch on the proof of \texttt{IBC_DNF_EXISTS_case4}:
\begin{proof}
Given an $\phi\in \phi s$, the desired $\psi$ is given by 
$\phi:=$
\HOLtm[phi/f]{lit_list_to_form2
 (SET_TO_LIST 
  ({AND f c | c | CONJ_OF c (fs DIFF {f\})\}))}.  There are two things to check: Using \texttt{CONJ_OF_AND_lemma} and \texttt{list_to_DNF_lemma}, it is immediate to prove $\phi$ is in disjunction normal form. To prove $\phi$ is equivalent to $\phi$, we have a sequence of equivalence:
\[
\begin{array}{cl}

& \begin{array}{l}\HOLtm[width=100,phi/f]{lit_list_to_form2 (SET_TO_LIST { AND f c | c | CONJ_OF c (fs DIFF {f\})\})}\end{array}\\

\equiv & \begin{array}[t]{l}\HOLtm[width=100,phi/f]{(lit_list_to_form2 (MAP (AND f) (SET_TO_LIST {c | CONJ_OF c (fs DIFF {f\})\})))}\end{array}\\

\equiv & \begin{array}{l}\HOLtm[phi/f]{(AND f (lit_list_to_form2 (SET_TO_LIST {c | CONJ_OF c (fs DIFF {f\})\})))}\end{array}\\

\equiv & \begin{array}{l}\HOLtm[phi/f]{(AND f TRUE)}\end{array}\\

\equiv & \begin{array}{l}\HOLtm[phi/f]{f}\end{array}
\end{array}
\]

The first equivalence is by \texttt{lit_list_to_form2_SYM}, the second equivalence is by \texttt{list_demorgan} and the third equivalence is by \texttt{ALL_POSSIBLE_VALUE_TRUE}. 
\end{proof}

By here, we are done with the base case of \texttt{IBC_DNF_EXISTS}.

\subsubsection{Case for disjunction}

The following lemma directly implies our goal by the fact that if $\phi_1$ is equivalent $\psi_1$ and $\phi_2$ is equivalent to $\psi_2$, then $\phi_1\lor \phi_2$ is equivalent to $\psi_1\lor \psi_2$ and the transitivity of being equivalent.
\begin{lm}[\holref{\texttt{DNF_OF_DISJ_equiv0}}{IBCDNFrevised}{765}]
If \HOLtm{psi1} and \HOLtm{psi2} are \HOLtm{DNF_OF} formulas on a set \HOLtm{phis}, then there exists a \HOLtm{DNF_OF} formula on \HOLtm{phis} which is equivalent to their disjunction. 
\begin{holmath}
  \HOLthm[phi/f,psi1/p1,psi2/p2]{IBCDNFrevised.DNF_OF_DISJ_equiv0}
\end{holmath}
\end{lm}

Expanding the definition of \HOLtm{DNF_OF} and \HOLtm{DISJ_OF0} gives four cases, we prove the only interesting one among them, the other three are immediate:
\begin{prop}[\holref{\texttt{DNF_OF_DISJ_equiv0_case4}}{IBCDNFrevised}{721}]
If \HOLtm{psi1} and \HOLtm{psi2} are \HOLtm{DISJ_OF0} formulas on a set \HOLtm{phis}, then there exists a \HOLtm{DISJ_OF0} formula on \HOLtm{phis} which is equivalent to their disjunction. 
\begin{holmath}
  \HOLthm[psi1/p1,psi2/p2,phi/f]{prettyPrinting.ppDNF_OF_DISJ_equiv0_case4}
\end{holmath}
\end{prop}

\begin{proof}
By induction on \HOLtm{DISJ_OF0}, the base case is by a straightfoward two-layer induction, for the step case, suppose \HOLtm{f1 IN fs} and \HOLtm{DISJ_OF0 psi1 (fs DIFF {f1\})} and \HOLtm{DISJ_OF0 psi2 fs}, we are asked to prove:
\begin{holmath}
 \HOLtm[phi/f,psi1/p1,psi2/p2]{∃f. DISJ_OF0 f fs ∧ equiv0 μ f (DISJ (DISJ f1 p1) p2)}
\end{holmath}
from the inductive hypothesis 
\begin{holmath}
\HOLtm[psi1/p1,psi2/p2,phi/f]{∀p2.
            DISJ_OF0 p2 (fs DIFF {f1\}) ⇒
            ∃f. DISJ_OF0 f (fs DIFF {f1\}) ∧ equiv0 μ f (DISJ p1 p2)}
\end{holmath}
If \HOLtm[psi1/p1,psi2/p2,phi/f]{DISJ_OF0 p2 (fs DIFF {f1\})}, then we are done by inductive hypothesis, otherwise we need a trick: If \HOLtm[psi1/p1,psi2/p2,phi/f]{DISJ_OF0 p2 fs} but \HOLtm[psi1/p1,psi2/p2,phi/f]{¬DISJ_OF0 p2 (fs DIFF {f1\})}, it must be the case that $\phi_1$ appears in $\psi_2$, hence we can extract $\phi_1$ to the beginning of $\psi_2$ to split $\psi_2$ as a disjunction $\phi_1\lor t$, using the following lemma proved by induction on \HOLtm{DISJ_OF0}:

\begin{lm}[\holref{\texttt{DISJ_OF0_split}}{IBCDNFrevised}{1090}]
\begin{holmath}
  \HOLthm[phi/f,psi/p]{IBCDNFrevised.DISJ_OF0_split}
\end{holmath}
\end{lm}
After applying the lemma above, we can finish the proof by using the inductive hypothesis.
\end{proof}

\subsubsection{Case for negation}

Let us consider our last case, which amounts to prove:
\begin{lm}[\holref{\texttt{IBC_DNF_EXISTS_case3}}{IBCDNFrevised}{1781}]
If \HOLtm{psi} is a \HOLtm{DNF_OF} formula on a finite non-empty set \HOLtm{phis}, then there exists a \HOLtm{DNF_OF} formula on \HOLtm{phis} which is equivalent to its negation. 
\begin{holmath}
  \HOLthm[phi/f,psi/p]{IBCDNFrevised.IBC_DNF_EXISTS_case3}
\end{holmath}
\end{lm}
The idea of this proof is to use `complement'. Take a finite set $\phi s$ and consider a modal formula $\psi$ such that \HOLtm{DNF_OF psi fs}, we find a formula $\phi$ such that \HOLtm{DNF_OF phi fs}, and in addition, $\phi$ is be satisfied if and only if $\lnot \psi$ is satisfied. As $\psi$ is a disjunction, $\lnot \psi$ is satisfied once none of $\psi$'s disjuncts is satisfied. As \HOLtm{DNF_OF psi fs}, all of $\psi$'s disjuncts are taken from the set of all of the \HOLtm{CONJ_OF} formulas on $\phi s$, and these disjuncts form a subset $ss$ of \HOLtm{{c | CONJ_OF c fs\}}. Since none of the conjunctions in $ss$ is satisfied, it must be the case that the satisfied conjunction lives in \HOLtm{{c | CONJ_OF c fs\} DIFF ss}. 

To get some sense what we are doing, let us consider an example. Again, let $\phi s = \{\phi_1,\phi_2\}$, so $\psi:= (\phi_1\land \phi_2)\lor (\phi_1\land\lnot \phi_2)$ is a \HOLtm{DNF_OF} formula on $\phi s$. For $\lnot \psi$ is satisfied, neither $\phi_1\land \phi_2$ nor
$ \phi_1\land\lnot \phi_2$ is satisfied, so it must be the case that either $\lnot \phi_1\land\lnot \phi_2$ or $\lnot \phi_1\land \phi_2$. We take the disjunction of the elements in the set $\{\lnot \phi_1\land\lnot \phi_2,\lnot \phi_1\land \phi_2\}$ formed by taking out the disjuncts appear in $\psi$ from the set $\{\phi_1\land \phi_2,\lnot \phi_1\land \phi_2,\lnot \phi_1\land\lnot \phi_2,\lnot \phi_1\land \phi_2\}$ of all the \HOLtm{CONJ_OF} formulas on $\phi s$, it gives the formula $(\lnot \phi_1\land\lnot \phi_2)\lor (\lnot \phi_1\land \phi_2)$, which is equivalent to the negation of $\psi$.

Although it may be possible to stick with the former tools \HOLtm{lit_list_to_form} and \HOLtm{lit_list_to_form2}, it is much more natural to directly deal with complement of sets rather than defining suitable notion of `complement of a list'. Again, for a finite set $\phi s$, we will use literals, which are pairs \HOLtm{(phi,tv)}, where $\phi\in \phi s$ and $tv$ is a truth value, to encode formulas in $fs$ or its negation. But instead of using list of literals, we will use sets of literals this time.

Since now we start working with set of literals, it is better to have a notion of `satisfaction of a literal'.

\begin{defn}[\holref{Satisfaction of a literal}{IBCDNFrevised}{1466}]
For a model \HOLtm{M} and a world \HOLtm{w}, a literal $(\phi,\top)$ is satisfied at $w$ if \HOLtm{satis M w phi}, and $(\phi,\bot)$ is satisfied at $w$ if \HOLtm{satis M w (NOT phi)}. 
\begin{holmath}
  \HOLthm[def,phi/f]{IBCDNFrevised.lsatis_def}
\end{holmath}
\end{defn}

Now we want to construct \HOLtm{CONJ_OF} formulas from set of literals. Recall in a former section where we talked about building \HOLtm{CONJ_OF} formulas from lists of literals, we require the lists that correspond to \HOLtm{CONJ_OF} formulas to satisfy some extra condition. Similarly, for a set $c$ of literals to correspond to a \HOLtm{CONJ_OF} formula, we require some conditions on the set. When a set of literals on a finite set $\phi s$ satisfies these conditions, we call this set \HOLtm{is_lset} of $\phi s$. 

\begin{defn}[\holref{$\sf lset$ on a set of formulas}{IBCDNFrevised}{1475}]
The concept `is a literal set on' only make sense for finite set \HOLtm{phis} of formulas. If \HOLtm{phis} is finite, a set $c$ of pairs of form \HOLtm{(phi,tv)} is a literal set on \HOLtm{phis} if $c$ is finite with its cardinality equal to the cardinality of \HOLtm{phis}, and moreover, if we collect the first coordinates of the pairs in $c$, we will get \HOLtm{phis}. 
\begin{holmath}
  \HOLthm[def]{IBCDNFrevised.is_lset_def}
\end{holmath}
\end{defn}

The condition of being an $\sf lset$ is merely a translation of the condition on a list which gives a \HOLtm{CONJ_OF} formula as in the story before. An $\sf lset$ encodes a conjunction, for instance, the $\sf lset$ $\{(\phi_1,\top),(\phi_2,\top)\}$ on the set $\phi s := \{\phi_1,\phi_2\}$ encodes the formula $\phi_1\land \phi_2$. The conjunction that an $\sf lset$ encodes is satisfied precisely when all of the literals in the $\sf lset$ is satisfied, so we define the satisfaction of literal sets as below, with the `c' here stands for `conjunction'. 
\begin{defn}[\holref{c-satisfaction}{IBCDNFrevised}{1469}]
A set of literals is c-satisfied at a world $w$ in a model \HOLtm{M} if every literal in it is l-satisfied at $w$. 
\begin{holmath}
  \HOLthm[def]{IBCDNFrevised.csatis_def}
\end{holmath}
\end{defn}
If two $\sf lset$s are different, the union of them must contains a literal of opposite sign, hence:
\begin{prop}[\holref{\texttt{NEQ_lsets_FALSE}}{IBCDNFrevised}{1583}]
The union of two distinct $\sf lset$s can never be c-satisfied. 
\begin{holmath}
  \HOLthm{IBCDNFrevised.NEQ_lsets_FALSE}
\end{holmath}
\end{prop}
By induction on \HOLtm{CONJ_OF} and the finiteness of $\sf lset$ respectively, we prove our expected results: \HOLtm{CONJ_OF} formulas on a finite set $\phi s$ corresponds to $\sf lset$s on $\phi s$, in the sense that the satisfaction of each $\sf lset$ corresponds to the satisfaction of a \HOLtm{CONJ_OF} formula, and any \HOLtm{CONJ_OF} formula $\phi$ has an $\sf lset$ which is satisfied if and only if $\phi$ is satisfied. 

\begin{prop}[\holref{\texttt{CONJ_OF_lset}}{IBCDNFrevised}{1478}]
\begin{holmath}
  \HOLthm{IBCDNFrevised.CONJ_OF_lset}
\end{holmath}
\end{prop}
\begin{prop}[\holref{\texttt{is_lset_CONJ_OF_EXISTS}}{IBCDNFrevised}{1537}]
\begin{holmath}
  \HOLthm[phi/f]{IBCDNFrevised.is_lset_CONJ_OF_EXISTS}
\end{holmath}
\end{prop}

Now to capture \HOLtm{DNF_OF} formulas using sets of literals, we need to consider about taking the \HOLtm{DISJ_OF0} the \HOLtm{CONJ_OF} formulas which we can obtain form $\sf lset$s. Such disjunctions can be captured by sets of literal sets. For instance, the set $\{\{(\phi_1,\top),(\phi_2,\top)\},\{(\phi_1,\bot),(\phi_2,\top)\}\}$ encodes the formula $(\phi_1\land \phi_2)\lor (\lnot \phi_1\land \phi_2)$. The notion of satisfaction of a set of $\sf lset$s is called `d-satisfaction', where `d' stands for `disjunction'.

\begin{defn}[\holref{d-satisfaction}{IBCDNFrevised}{1472}]
A set of $\sf lset$s is called `d-satisfied' at $w$ in a model \HOLtm{M} if and only if it contains an $\sf lset$ which is `c-satisfied' at $w$. 
\begin{holmath}
  \HOLthm[def]{IBCDNFrevised.dsatis_def}
\end{holmath}
\end{defn}
A useful proposition to prove is the set-version of the the previous proposition \texttt{ALL_POSSIBLE_VALUE_TRUE}:

\begin{prop}[\holref{\texttt{dsatis_ALL_POSSIBLE_VALUE}}{IBCDNFrevised}{1646}]
For any finite nonempty \HOLtm{phis}, the set of all the $\sf lset$s on \HOLtm{phis} is satisfied at any world in any model. 
\begin{holmath}
  \HOLthm{prettyPrinting.ppdsatis_ALL_POSSIBLE_VALUE}
\end{holmath}
\end{prop}

Using this as a lemma, we can prove the a critical fact about our idea of `complement'. 

\begin{prop}[\holref{\texttt{dsatis_is_lset_complement}}{IBCDNFrevised}{1673}]
A set of $\sf lset$s are d-satisfied iff its complement in the set of all $\sf lset$s is not d-satisfied.
\begin{holmath}
  \HOLthm{IBCDNFrevised.dsatis_is_lset_complement}
\end{holmath}
\end{prop}
\begin{proof}
Under the assumptions, for the implication from left to right, suppose both \HOLtm{dsatis M w cs} and \HOLtm{dsatis M w (({c | is_lset c fs\}) DIFF cs)}, then by definition of \HOLtm{dsatis}, it means two distinct $\sf lset$s are c-satisfied at the same point, which contradicts \texttt{NEQ_lsets_FALSE}. For the implication from right to left, suppose \HOLtm{¬dsatis M w cs}, by \texttt{dsatis_ALL_POSSIBLE_VALUE_TRUE}, we will be able to find the $\sf lset$ which holds on $w$ in \HOLtm{(({c | is_lset c fs\}) DIFF cs)}. This completes the proof.
\end{proof}


%The correspondence of set of $\sf lset$s  and \HOLtm{DISJ_OF0} formulas is given as: 



Altogether, here comes the correspondence results between sets of $\sf lset$ and \HOLtm{DNF_OF} formulas.
% where the correspondence is in the sense that for any fixed finite set $\phi s$, for any set $s$ of $\sf lset$s on $\phi s$, there exists a \HOLtm{DNF_OF} formula $\phi$ on $\phi s$ such that $\phi$ is satisfied precisely $s$ is d-satisfied, and vice versa. 

\begin{prop}[\holref{\texttt{DNF_OF_cset}}{IBCDNFrevised}{1517}]
For any \HOLtm{DNF_OF} formula $d$ on \HOLtm{phis}, there exists a set $cs$ of $\sf lset$s on \HOLtm{phis} which is d-satisfied precisely when $d$ is satisfied.  
\begin{holmath}
  \HOLthm{prettyPrinting.ppDNF_OF_cset}
\end{holmath}
\end{prop}

\begin{proof}
By induction on \HOLtm{DISJ_OF0} using \texttt{CONJ_OF_lset}, we obtain:

\begin{holmath}
  \HOLthm{prettyPrinting.ppDISJ_OF0_cset}
\end{holmath}  

Which reads: For any \HOLtm{DISJ_OF0} formula $d$ on \HOLtm{phis}, where \HOLtm{phis} is a set of \HOLtm{CONJ_OF} formulas on a set \HOLtm{phis0}, there exists a set $cs$ of $\sf lset$s on \HOLtm{phis0} such that for any model \HOLtm{M} and any world \HOLtm{w}, $d$ is satisfied at \HOLtm{w} if and only if \HOLtm{cs} is d-satisfied at $w$. 

The result follows by wrapping up the definitions of \HOLtm{DNF_OF} and \HOLtm{DISJ_OF}. 

\end{proof}

\begin{prop}[\holref{\texttt{is_lset_DNF_OF_EXISTS}}{IBCDNFrevised}{1699}]
For any finite non-empty \HOLtm{phis} and any finite set $s$ of $\sf lset$s on \HOLtm{phis}, there exists a \HOLtm{DNF_OF} formula on \HOLtm{phis} which is satisfied precisely when $s$ is d-satisfied. 
\begin{holmath}
  \HOLthm[phi/f]{prettyPrinting.ppis_lset_DNF_OF_EXISTS}
\end{holmath}
\end{prop}
\begin{proof}
\texttt{DNF_OF_cset} is an easy consequence of \texttt{DISJ_OF0_cset}. For \texttt{is_lset_DNF_OF_EXISTS}, the proof is by induction on finiteness of $s$. For the base case that $s=\emptyset$, the required formula $\phi$ is obviously $\bot$. Suppose for $s$ a finite set of $\sf lset$s, there exists a formula $\phi$ in disjunction normal form such that \HOLtm{satis M w phi <=> dsatis M w s} for any model \HOLtm{M} and any \HOLtm{w IN M.frame.world}, we find a formula $\psi$ such that \HOLtm{satis M w psi <=> dsatis M w (e INSERT s)}. By \texttt{is_lset_CONJ_OF_EXISTS}, there is a \HOLtm{CONJ_OF} formula $\phi'$ on $\phi s$ with the property that \HOLtm{satis M w phi' <=> csatis M w e} for arbitary \HOLtm{M}. If $\phi$ is equivalent to $\bot$, then $\phi'$ is the $\psi$ we want, and if $\phi'$ is equivalent to $\bot$, then $\phi$ is what we want. If both of them are not equivalent to $\bot$, we can take $\phi'\lor \phi$ as the $\psi$ we want. The first desired condition is easy to check, it remains to prove $\phi'\lor \phi$ is in disjunction normal form, which is suffices by proving \HOLtm[phi'/f',phi/f]{DISJ_OF0 f ({c| CONJ_OF c fs\} DIFF {f'\})}. Suppose not, then there exists a $\varphi$ such that \HOLtm{DISJ_OF0 varphi ({c| CONJ_OF c fs\} DIFF {phi\})} and \HOLtm{equiv0 μ phi (DISJ phi' varphi)} by \texttt{DISJ_OF0_split}. To obtain a contradiction, we find a model with a world satisfies $\phi'$ but not $\phi$. With the equivalence conditions on $\phi$ and $\phi'$, it amounts to find a modal \HOLtm{M} with a world \HOLtm{w IN M.frame.world} such that \HOLtm{csatis M w e} but \HOLtm{¬dsatis M w s}. Note that any world $c$-satisfying $e$ cannot $d$-satisfy $s$, otherwise it contradicts \texttt{dsatis_is_lset_completment}. Also since $\phi'$ is not equivalent to $\bot$, there exists a model \HOLtm{M} with a world $w$ in it such that \HOLtm{csatis M w e}. So we are done. 
\end{proof}

Now we have all the ingredients to prove our last case.

\begin{proof}
As \HOLtm{DNF_OF psi fs}, by \texttt{DNF_OF_cset} we obtain a $\sf lset$ $cs$ such that \HOLtm{satis M w psi <=> dsatis M w cs} for any \HOLtm{M} and $w$. Consider its complement \HOLtm{{c | is_lset c fs\} DIFF cs}, by \texttt{is_lset_DNF_OF_EXISTS} we obtain a formula $\phi$ such that \HOLtm{DNF_OF phi fs} and \HOLtm{satis M w phi} iff \HOLtm{dsatis M w ({c | is_lset c fs\} DIFF cs)} for any \HOLtm{M} and $w$. By \texttt{dsatis_is_lset_complement}, \HOLtm{dsatis M w ({c | is_lset c fs\} DIFF cs)} iff \HOLtm{¬dsatis M w cs}, so $f$ is equivalent to $\lnot \psi$.
\end{proof}

Here we are done with the proof of \texttt{prop_2_29_strengthen}. This is the end of the interlude.

This is time to return to discussion about the proof of finite model property. Recall in the last chapter, we have seen that a bisimulation gives arise to modal equivalence, modal equivalence between worlds means satisfying exactly the same formulas', but when we are building a finite model for a formula $\phi$, we do not care about the satisfaction of any formula of degree above \HOLtm{DEG phi}, since such formula cannot affect the satisfaction of $\phi$. Therefore, we just need some relation such that related worlds satisfy the same modal formulas up to some degree $n$. It turns out that the notion of `finite approximation of bisimulation' is such a relation. For a `finite approximation of bisimulation up to depth $n$'. it is called an \emph{$n$-bisimulation}. Let \HOLtm[w1/w,M1/M]{w IN M.frame.world} and \HOLtm[w2/w',M2/M']{w' IN M'.frame.world}, $w_1$ and $w_2$ are $n$-bisimilar if there exists a sequence of relations $Z_n\subseteq \cdots\subseteq Z_0$ such that:
\begin{itemize}
  \item $w_1$ and $w_2$ are related by $Z_n$
  \item If \HOLtm{v1 IN M1.frame.world} and \HOLtm{v2 IN M2.frame.world} are related by $Z_0$, then $v_1$ and $v_2$ satisfy the same propositional letters.
  \item If \HOLtm{v1 IN M1.frame.world} and \HOLtm{v2 IN M2.frame.world} are related by $Z_{i+1}$ and we have \HOLtm{M1.frame.rel v1 u1} for \HOLtm{u1 IN M1.frame.world}, then there exists \HOLtm{u2 IN M2.frame.world} such that \HOLtm{M2.frame.rel v2 u2} with $u_1$ and $u_2$ related by $Z_i$.
  \item If \HOLtm{v1 IN M1.frame.world} and \HOLtm{v2 IN M2.frame.world} are related by $Z_{i+1}$ and we have \HOLtm{M2.frame.rel v2 u2} for \HOLtm{u2 IN M2.frame.world}, then there exists \HOLtm{u1 IN M1.frame.world} such that \HOLtm{M1.frame.rel v1 u1} with $u_1$ and $u_2$ related by $Z_i$.
\end{itemize}

Such a sequence of $Z_i$ is a family of relations indexed by natural numbers from $0$ to $n$. When the world set of \HOLtm{M1} has type $\beta$ and the world set of \HOLtm{M2} has type $\gamma$, we encode such a family using functions $f:num\to \beta\to\gamma\to bool$. Such a function assigns each natural number a relation between terms of type $\beta$ and $\gamma$, so the \HOLtm{f i} is the relation $Z_i$ in the usual mathematical definition, and \HOLtm{nbisim M1 M2 f n w1 w2} means $w_1$ and $w_2$ are worlds in \HOLtm{M1} and \HOLtm{M2} respectively which are $n$-bisimilar via the family of relations given by $f$, as shown below. 
\begin{defn}[\holref{$n$-bisimulation}{chap2_3}{1059}]
\begin{holmath}
  \HOLthm[def,M1/M,M2/M',w1/w,w2/w',v1/v,v2/v',u1/u,u2/u']{chap2_3.nbisim_def}
\end{holmath} 
\end{defn}

If a type $\alpha$ is finite, then for models \HOLtm{M1} and \HOLtm{M2} with underlying set type $\beta$, $\gamma$ respectively, where both $\beta$ and $\gamma$ has infinite universe, then for any \HOLtm{w1 IN M1.frame.world} and \HOLtm{w2 IN M2.frame.world}, they agree on formulas up to degree $n$ if and only if there is an $n$-bisimulation relating them. This is the obtained by combining the two following results. 

\begin{prop}[\holref{\texttt{prop_2_31_half1}}{chap2_3}{1126}]
If two worlds \HOLtm{w IN M.frame.world} and \HOLtm{w' IN M'.frame.world} are related by an $n$-bisimulation, then they agree on all modal formulas up to degree $n$
\begin{holmath}
  \HOLthm[w1/w,w2/w',M1/M,M2/M']{prettyPrinting.ppprop_2_31_half1}
\end{holmath}
\end{prop}
\begin{proof}
By induction on $n$.
\end{proof}

For the implication of the other direction, we require the assumption on infinite type universe since we will need to use \texttt{prop_2_29}. 
\begin{prop}[\holref{\texttt{prop_2_31_half2}}{chap2_3}{1314}]
\begin{holmath}
  \HOLthm[showtypes,w1/w,w2/w',M1/M,M2/M']{prettyPrinting.ppprop_2_31_half2}
\end{holmath} 
\end{prop}
\begin{proof}
  The argument is analogue to the proof of Hennessy-Milner theorem, with \HOLtm{λn w1 w2. (!(phi: 'a chap1$form). DEG phi <= n ==> (satis M w1 phi <=> satis M' w2 phi))} giving  an $n$-bisimulation relation linking $w$ and $w'$.
\end{proof}

We also want a concept that measure the depth of a model. As `depth' is a relative concept measuring the distance of two points, to talk about the depth of a world \HOLtm{w IN M.frame.world}, we need \HOLtm{M} to be naturally equipped with a base point. Hence the `height' of a world only makes sense to rooted models. To tell the HOL about this definition, we start by defining \HOLtm{heightLE} as a inductive relation:


\begin{defn}[\holref{Upper bound of height}{chap2_3}{1429}]
\[
\begin{array}{c}
  \HOLthm[rule,conj1]{chap2_3.heightLE_rules}\\[4mm]
  \HOLthm[rule,conj2,width=120]{chap2_3.heightLE_rules}\\
\end{array}
\]
\end{defn}

Recall how we defined rooted model: \HOLtm{rooted_model M x M'} means `\HOLtm{M} is a rooted model generated by the world $x$ in the ambient model \HOLtm{M'}'. As \HOLtm{heightLE} is designed to be only make sense for rooted models, we encode the information about the rootedness of the model we are talking about into this definition. Therefore, \HOLtm{heightLE M x M' w n} reads `for the rooted model \HOLtm{M} generated by the root $x$ in \HOLtm{M'}, the distance from the world \HOLtm{w} to the root $x$ is less or equal to $n$', and we will always have an assumption on rootedness of \HOLtm{M} whence this definition is involved. The first rule says the height of the root for any rooted model is less or equal to any natural number, and the second rule says for a world \HOLtm{v} of \HOLtm{M}, if there exists a world \HOLtm{w} of \HOLtm{M} such that $w$ is related to $v$ in \HOLtm{M}, then if the height of \HOLtm{w} is less or equal to $n$, then the height of \HOLtm{v} is less or equal to \HOLtm{n + 1}.
% We define the actual height of a world $w$ to be the smallest natural number $n$ such that \HOLtm{heightLE M x M' w n}. The height of model is the maximum $n$ such that there is a world of height $n$ in the model.
\begin{defn}[\holref{Height of a world}{chap2_3}{1436}]
We define the actual height of a world $w$ to be the smallest natural number $n$ such that \HOLtm{heightLE M x M' w n}.
\begin{holmath}
  \HOLthm[def]{chap2_3.height_def}
\end{holmath}
\end{defn}

\begin{defn}[\holref{Height of a model}{chap2_3}{1438}]
The height of model is the maximum $n$ such that there is a world of height $n$ in the model.
\begin{holmath}
  \HOLthm[def]{chap2_3.model_height_def}
\end{holmath}
\end{defn}

Obviously, the root of any rooted model have height $0$. We are particularly interested in talking about heights in tree-like model. 
%When \HOLtm{M} is tree-like, if \HOLtm{w IN M.frame.world} has height $n$, then any world \HOLtm{v IN M.frame.world} such that \HOLtm{M.frame.rel w v} will have height $n+1$.
\begin{lm}[\holref{\texttt{tree_height_rel_lemma}}{chap2_3}{1673}]
When \HOLtm{M} is tree-like, if \HOLtm{w IN M.frame.world} has height $n$, then any world \HOLtm{v IN M.frame.world} such that \HOLtm{M.frame.rel w v} will have height $n+1$.
\begin{holmath}
  \HOLthm{chap2_3.tree_height_rel_lemma}
\end{holmath}
\end{lm}
\begin{proof}
By definition of tree like model, we can restate the goal as:
\begin{holmath}
\HOLtm{!x' w. (RESTRICT M.frame.rel M.frame.world)^* x' w ==> x = x' ==>
          !v. v IN M.frame.world ==> M.frame.rel w v ==> height M x M v = height M x M w + 1}
\end{holmath}
The rest of the proof is done by induction on reflexive and transitive closure using the induction principle \texttt{RTC_INDUCT_RIGHT1}. 
\end{proof}

The restriction of a rooted model \HOLtm{M} to the height $k$ is the submodel consisting of all the worlds in \HOLtm{M} of height up to $k$.
% We define a function \HOLtm{hrestriction} that takes a rooted model \HOLtm{M} sitting in an ambient model \HOLtm{M'} together with a natural number $n$, and give the model obtained by restricting \HOLtm{M} to the height \HOLtm{n}. The restriction of a tree-like model to any height is again a tree-like model:
\begin{defn}[\holref{Restriction a model up to some height}{chap2_3}{1442}]
We define a function \HOLtm{hrestriction} that takes a rooted model \HOLtm{M} sitting in an ambient model \HOLtm{M'} together with a natural number $n$, and give the model obtained by restricting \HOLtm{M} to the height \HOLtm{n}.
\begin{holmath}
  \HOLthm[def,p/phi,w1/n1,w2/n2,w/n]{chap2_3.hrestriction_def}
\end{holmath}
\end{defn}

\begin{prop}[\holref{\texttt{tree_hrestriction_tree}}{chap2_3}{1742}]
The restriction of a tree-like model to any height is again a tree-like model. 
\begin{holmath}
  \HOLthm{chap2_3.tree_hrestriction_tree}
\end{holmath}
\end{prop}

Restriction of rooted model gives arise of $n$-bisimulation. 
\begin{lm}[\holref{\texttt{lemma_2_33}}{chap2_3}{1530}]
If we restrict a rooted model \HOLtm{M} to height $k$, then a world $w$ of height $m$ in the restricted model is $k-m$-bisimilar to itself in the original model. 
\begin{holmath}
  \HOLthm{chap2_3.lemma_2_33}
\end{holmath}
\end{lm}
\begin{proof}
The $n$-bisimilar relation is give as \HOLtm{λn w1 w2. w1 = w2 /\ height M x M' w1 <= k - n}.
\end{proof}

Now we can start building a finite model via selection:
\begin{thm}[\holref{\texttt{thm_2_34}}{chap2_3}{1827}]
\begin{holmath}
  \HOLthm[M/FM]{chap2_3.thm_2_34}
\end{holmath}
\end{thm}

\begin{proof}
Suppose \HOLtm{satis M1 w1 phi} where $w_1$ is of type $\beta$ and $\phi$ is an $\alpha$-formula of degree $k$, then by \texttt{prop_2_15_corollary}, there exists a tree-like model \HOLtm{M2} with \HOLtm{phi} satisfied at its root \HOLtm{w2}. Such an \HOLtm{M2} obtained from \texttt{prop_2_15_corollary} has its world set of type $\beta\ list \to bool$, so all the lemmas proved before with a infinite universe assumption applies for any model with its world set a subset of \HOLtm{M2.frame.world} . Define \HOLtm{M3} $:=$ \HOLtm{hrestriction M2 w2 M2 k} to be the restriction of \HOLtm{M2} to height $k$, then \HOLtm{M3} is rooted and we have \HOLtm{nbisim M3 M2 f k w2 w2} by \texttt{lemma_2_33}. Hence \HOLtm{satis M3 w2 phi} by \texttt{prop_2_31_half1}. By \texttt{exercise_1_3_1} proved in the first chapter, if a propositional letter does not appear in $\phi$, then it has no effect to the satisfaction of $\phi$, so we can discard all the propositional letters in \HOLtm{M3} which does not occur in $\phi$ to obtain the model, by constructing a model \HOLtm{M'} whose world set and relation are both same as that of \HOLtm{M3}, and the valuation for any propositional letter which appears in \HOLtm{phi} is same as in \HOLtm{M3}, whereas for propositional letters which does not occur in \HOLtm{phi}, the valuation of \HOLtm{M3'} always assign them the truth value \HOLtm{F}. Such a model \HOLtm{M3'} looks like:
\begin{holmath}
\HOLtm{M3' =
   <| frame := <| world := M3.frame.world ;
                    rel := M3.frame.rel ;
                |>;
       valt := \p v. if ((VAR p) IN (subforms phi)) then (M3.valt p v) else F |>}
\end{holmath}
, and still have \HOLtm{satis M3' w2 phi}. We will select a finite model inductively from \HOLtm{M3'}.

Let $s$ denote the set of propositional letters used by $\phi$, so $s$ is finite. By \texttt{prop_2_29_strengthen}, there are only finitely many non-equivalent formulas of degree less or equal to $k$ which only use propositional letters in $s$, that is, the set $\Delta=$ \HOLtm[phi/f]{{f | DEG f <= k /\ prop_letters f ⊆ s\}//E μ} is a finite. We care about the equivalence classes in $\Delta$ which are equivalence classes of formulas starting with a $\Diamond$. For such a equivalence class, taking the intersection with the set \HOLtm{{d | ?d0. d = DIAM d0\}} does not give the empty set. Take the image of $\Delta$ under the function \HOLtm{\s. s ∩ {d | ?d0. d = DIAM d0\}} and delete the empty set from the image, we obtain a set $fs$ of sets of formulas, where for each $x\in fs$, $x$ consists of equivalent formulas of degree less or equal to $k$, only use propositional letters in $s$, and start with diamond. For each $x\in fs$, we choose a representative from $x$ using the choice function, and collect these representatives into the set  
$rs:=$ \HOLtm{IMAGE CHOICE 
                             ((IMAGE 
                               (\s. s INTER {d | ?d0. d = DIAM d0\})
                               Δ) 
                               DELETE {\})}. The set $rs$ is finite as the image of a finite set. 

We will construct sets $S_0,\cdots, S_k$ of worlds in \HOLtm{M3'}, where the points in $S_n$ have height $n$. Start with $S_0:=\{w_2\}$, and inductively, assume $S_0,\cdots, S_n$ has been defined, construct $S_{n+1}$ as follows: Consider an element in $v\in S_n$, for each $\Diamond \phi\in rs$ such that \HOLtm{satis M3' w2 (DIAM phi)}, pick a world \HOLtm{u IN M3'.frame.world} such that \HOLtm{M3'.frame.rel v u} and \HOLtm{satis M3' u phi}. Do the same thing to all the $v\in S_n$, then take $S_{n+1}$ as the set of all the such $u$'s which are selected in this way. 

To formalise the definition of such $S_i$'s, we define a primitive recursive function $ss:=$ \begin{holmath}
\HOLtm[alltt,width=95]{PRIM_REC {w2\}
                 (\s0:β list set n. 
                      {CHOICE uset |
	              ?phi v. satis M3' v (DIAM phi) /\ 
	              ((DIAM phi) IN 
                       (IMAGE CHOICE 
                             ((IMAGE 
                               (\s. s INTER {d | ?d0. d = DIAM d0\})
                               Δ) 
                               DELETE {\})) /\
                      v IN s0 /\
		      uset = { u | M3'.frame.rel v u /\ u IN M3'.frame.world /\
		                   satis M3' u phi\})\})
}
\end{holmath}
For each $i\le k$, $ss\ i$ will be our $S_i$. By induction on $i$, we can prove each $ss\ i$ is finite, so the set $W4 := \bigcup_i \{ss\ i\mid i \le k\}$ is finite. The resultant finite model we select is: 

\begin{holmath}
\HOLtm{M4 = <| frame:= <| world := W4;
                                  rel := M3.frame.rel |>;
		        valt:= M3'.valt |>}.
\end{holmath}
To prove \HOLtm{satis M4 w2 phi}, it suffices to give a $k$-bisimulation between \HOLtm{M4} and \HOLtm{M3'} relating $w2$ to itself. Such a $k$-bisimulation can be given as: 
\begin{holmath}
\HOLtm[alltt,width=120]{\n a1 a2. a1 IN M4.frame.world /\ a2 IN M3'.frame.world /\
                 height M3' w2 M3' a1 = height M3' w2 M3' a2 /\
		 height M3' w2 M3' a1 <= k - n /\
                 (!phi. (DEG phi <= n /\ prop_letters phi ⊆ s)
                     ==> (satis M3' a1 phi <=> satis M3' a2 phi))}
\end{holmath}
The rest of the proof amounts to check the above indeed gives a $k$-bisimulation, the proof is not hard using a similar argument as we proved the Hennessy-Milner theorem.
\end{proof}

In the proof above, note that what we do to capture indexing of set: A family of set indexed by $J$ is a function that takes an element in $J$ and gives a set. Here in our case, the $S$'s are indexed by natural numbers, so to define the family $S_n$ for $0\le n\le k$, we use the function $ss$ which take the index and gives the actual set indexed by it. We will treat index similarly afterwards. 


As we took a detour through \texttt{prop_2_15_corollary}, this construction of finite model changes the type of model. If we start with an $(\alpha,\beta)$-model, then the finite model we build by selection will be a $(\alpha,\beta \ list)$-model. 


\chapter{Reaching out to the world of first order logic}

As claimed by Slogan 3 in the introduction, modal logic is not an isolated formal system, in this chapter, we start connecting modal logic with the wider logical world by discussing about its relation to first order logic. In the first half of the chapter, we define standard translation as our link between modal logic and first order logic, and in the second half of the chapter, with the help of standard translation, we introduce the last one of the `big-four' constructions on models which give modal equivalence, and conclude this section by proving an elegant result about bisimulation: If we have a modal equivalence between worlds $w,v$ in two models \HOLtm{M} and \HOLtm{N}, although it may not the case that $w$ and $v$ are bisimilar, we can find a bisimulation in a pair of models constructed from \HOLtm{M} and \HOLtm{N}.

\section{Standard Translation}

To discuss the relationship between modal logic and first order logic, firstly we need to build some basics of first order logic in the HOL. First order logic is formalised in HOL light in 1998 by John Harrison, we take our construction of first-order model theory as in the paper (reference) of him.

For a first order language, a term is either a variable letter $x$ or a function symbol $f$ applied on a list of terms, which looks like $f(t_1,\cdots,t_n)$, where the $t$'s can either be variable letters or itself a function applied on some terms. As we are working in type theory, the variable letter $x$ need to come with its type. To avoid specifying the type of terms and formulas every where, we choose to fix the type of our first order terms formulas to only use variables of the type $(:num)$ of natural numbers. By this choice we made, we restrict our scope to countable language. The first order terms are encoded in HOL4 as below. 
\begin{defn}[First order terms]
\begin{holmath}
  \HOLthm{folLang.datatype_term}
\end{holmath}
\end{defn}
Hence our terms will look like \HOLtm{fV 6}, \HOLtm{Fn 1 [fV 1; fV 2]}, \HOLtm{Fn 2 [Fn 0 []]}, etc. The role of the two occurrences of the natural number $1$ in the term \HOLtm{Fn 1 [fV 1; fV 2]} are different: the first one is a function symbol, and the second one is variable letter. In the first order term \HOLtm{Fn 2 [Fn 0 []]}, we note the iterated application of function symbols, and also, \HOLtm{Fn 0 []} is the term obtained by applying the function symbol $0$ to the empty list. The $0$ here is a nullary function symbol, which is the same as a constant. 

Our formulas are defined inductively as well. 
%The primitive logical connectives we are using here are: the falsity `\HOLtm{fFALSE}', a predicate symbol applied on a list of variables, implication `\HOLtm{IMP}', and the universal quantification. Note that we do not define a separate notion of relation symbol. An $n$-ary relation symbol is a predicate symbol that takes lists of length $n$:
\begin{defn}[First order formulas]
The primitive logical connectives we are using here are: the falsity `\HOLtm{fFALSE}', a predicate symbol applied on a list of variables, implication `\HOLtm{IMP}', and the universal quantification.
\begin{holmath}
  \HOLthm{folLang.datatype_form}
\end{holmath}
Note that we do not define a separate notion of relation symbol. An $n$-ary relation symbol is a predicate symbol that takes lists of length $n$. 
\end{defn}
A quantified variable is called a bounded variable, otherwise it is called free. For instance, the $1$ in \HOLtm{Pred 4 [fV 1; fV 2]} is free, whereas the $1$ in \HOLtm{FALL 1 (Pred 4 [fV 1; fV 2])} is bounded.  
%We define a function that returns the set of free variables of the formula, starting by collecting variables occur in the terms of formulas, and then delete the bounded ones. 
\begin{defn}[Free variables]
 The function \HOLtm{FV} takes a first-order formula and returns the set of free variables of the formula, starting by collecting variables occur in the terms of formulas, and then delete the bounded ones. 
\begin{holmath}
  \HOLthm[def]{folLang.FVT_def}\\[3mm]
  \HOLthm[def,phi/f]{folLang.FV_def}
\end{holmath}
Here \HOLtm{LIST_UNION} is a function that takes a list of sets, and give us the union of all the sets in the list. 
\end{defn}

With roughly the similar idea, we also have a function \HOLtm{BV} that takes a first order formula and give the set of all its bounded variables, a function \HOLtm{form_functions} that gives the set of function symbols of a first order formula, and a function \HOLtm{form_predicates} which gives the set of predicate symbols of a first order formula. For a function symbol, it is consists of two pieces of information: the natural number that represents it and its arity. For a function symbol denoted by $m$ of arity $n$, we use the pair $(n,m)$ to record the function symbol. For example, \HOLtm{term_functions (Fn 2 [fV 1;fV 3]) = {(2,2)\}} and \HOLtm{form_functions (Pred 1 [Fn 0 []; Fn 1 []]) = {(0,0); (1,0)\}}. Similarly, a predicate symbol denoted by natural number $m$ and arity $n$ is recorded as a pair $(m,n)$ as well. Hence both the function \HOLtm{form_functions} and \HOLtm{form_predicates} takes a formula and gives a set of pairs of natural numbers. 

%A set of function symbols together with a set predicate symbols, which are both sets of pairs, determines a \emph{language}. For instance. 


The non-primitive first order connectives are defined in the canonical way:
\begin{defn}[Non-primitive first-order connectives]
\begin{holmath}
  \HOLthm[def,phi/f]{folLang.Not_def}\\
  \HOLthm[def]{folLang.True_def}\\
  \HOLthm[def,phi1/p,phi2/q]{folLang.Or_def}\\
  \HOLthm[def,phi1/p,phi2/q]{chap2_4revised.fAND_def}\\
  \HOLthm[def,phi/p]{folLang.Exists_def}
\end{holmath}
\end{defn}

To interpret these formulas, we need models for first order logic.
% A first order model \HOLtm{M} of type $\alpha$ is a triple consists of an $\alpha$-set \HOLtm{M.Dom} which is its domain, an interpretation \HOLtm{M.Fun} of function symbols, and an interpretation \HOLtm{M.Pred} of predicate symbols. Where as a interpretation of function symbol is a function that assigns each function symbol an actual function. Since we are using natural numbers as function symbols, an interpretation of function symbols is a function that takes a natural number and give a function that sends a tuple, which is a list, of variables of type $\alpha$ to an element of type $\alpha$. 
\begin{defn}[First order model]
A first order model \HOLtm{M} of type $\alpha$ is a triple consists of an $\alpha$-set \HOLtm{M.Dom} which is its domain, an interpretation \HOLtm{M.Fun} of function symbols, and an interpretation \HOLtm{M.Pred} of predicate symbols. Where a interpretation of function symbol is a function that assigns each function symbol an actual function, and a interpretation of predicate symbol is a function that assigns each predicate symbol an actual predicate. 
\begin{holmath}
  \HOLthm{folModels.datatype_model}
\end{holmath}
Since we are using natural numbers as function symbols, an interpretation of function symbols is a function that takes a natural number and give a function that sends a tuple, which is a list, of variables of type $\alpha$ to an element of type $\alpha$. Similar for interpretation of predicate symbols. 
\end{defn}

%It does not make sense for a first order model to have functions that send a list of elements of its domain out of its domain. Hence when we talk about first-order models, we will always require an assumption on well-formedness. A first order model \HOLtm{M} is well-formed if and only if all its functions has codomain \HOLtm{M.Dom}.


Given a first order model \HOLtm{M}, we can interpret formulas or terms by assigning each variable symbol an element in \HOLtm{M.Dom}. Again, as we are using natural numbers as variable symbols, such an assignment is a function from the universe of natural numbers. We are only interested in the case when a function from the universe of natural numbers does send each natural number an element in \HOLtm{M.Dom}. 

\begin{defn}[Valuation]
 For a function $v$ from natural numbers with its image in the domain of \HOLtm{M}, we write \HOLtm{valuation M v}, and read it as `$v$ is a valuation of the model \HOLtm{M}'. 
\begin{holmath}
  \HOLthm[def]{folModels.valuation_def}
\end{holmath} 
\end{defn}

Interpretation of terms and formulas are given as \HOLtm{termval} and \HOLtm{feval}.  

%where \HOLtm{termval} takes an $\alpha$-model, a function of type $num\to \alpha$, gives us an element of type $\alpha$, and \HOLtm{feval} takes a model, a function of type $num\to \alpha$ and a first order formula, gives us the truth value of formula we give on the model under the current assignment of variable letters, we only care about when the assignment of variable letters is indeed a valuation as defined above, when $\sigma$ is a valuation, each first order term is will be sent to an element of \HOLtm{M.Dom} under \HOLtm{termval}, and if in addition \HOLtm{feval M σ phi}, we say `\HOLtm{phi} is satisfied in \HOLtm{M} under the valuation $\sigma$', and write it as \HOLtm{fsatis M σ phi}. In particular, if there is only one free variable $x$ in $\phi$, then \HOLtm{fsatis M σ phi} just means that \HOLtm{phi} is satisfied at the point \HOLtm{σ x} in the model \HOLtm{M}. 

\begin{defn}[Term Valuation]
The function \HOLtm{termval} takes an $\alpha$-model, a function of type $num\to \alpha$, gives us an element of type $\alpha$. 
\begin{holmath}
  \HOLthm[def,showtypes]{folModels.termval_def}
\end{holmath}
\end{defn}

\begin{defn}[Satisfaction of first order formula]
The function \HOLtm{feval} takes a model, a function of type $num\to \alpha$ and a first order formula, gives us the truth value of formula we give on the model under the current assignment of variable letters. 
\begin{holmath}
  \HOLthm[def,phi/f]{folModels.holds_def}
\end{holmath}
\end{defn}

We only care about when the assignment of variable letters is indeed a valuation as defined above, when $\sigma$ is a valuation, each first order term is will be sent to an element of \HOLtm{M.Dom} under \HOLtm{termval}, and if in addition \HOLtm{feval M σ phi}, we say `\HOLtm{phi} is satisfied in \HOLtm{M} under the valuation $\sigma$', and write it as \HOLtm{fsatis M σ phi}. In particular, if there is only one free variable $x$ in $\phi$, then \HOLtm{fsatis M σ phi} just means that \HOLtm{phi} is satisfied at the point \HOLtm{σ x} in the model \HOLtm{M}.
When \HOLtm{σ} is a valuation for the model \HOLtm{M}, then a formula $\phi$ is satisfied in \HOLtm{M} if and only if \HOLtm{feval M σ phi}. Hence throughout our discussion, if we have already assumed \HOLtm{valuation M σ}, we will not distinguish between \HOLtm{feval M σ} and \HOLtm{fsatis M σ} in our following discussion. 

It does not make sense for a first order model to have functions that send a list of elements of its domain out of its domain. 
Hence when evaluate formulas with function symbols on a model, we will always require an assumption on well-formedness the model. 
%A first order model \HOLtm{M} is well-formed if and only if all its functions has codomain \HOLtm{M.Dom}.

\begin{defn}[\holref{Well-formed first-order model}{chap2_6}{926}]
A first order model \HOLtm{M} is well-formed if and only if all its functions has codomain \HOLtm{M.Dom}.
\begin{holmath}
  \HOLthm{prettyPrinting.ppwffm_def}
\end{holmath}
\end{defn}

Similar to the equivalence between modal formulas, we say two first order formulas $\phi_1,\phi_2$ are equivalent if for any first order model \HOLtm{M} and \HOLtm{σ} of \HOLtm{M}, we have \HOLtm{fsatis M σ f1 <=> fsatis M σ f2}. 


With the same idea we have in the discussion about \texttt{exercise_1_3_1}, we note the follows. 
%for a fixed model, the truth value of a first order formula only depends on what a valuation sends its free variable to. On the other hand, if the valuation is fixed, then two models are the same for evaluating a first order formula if they agree on all the functions and predicates appear in the formula. 

\begin{prop}[\texttt{holds_valuation}]
For a fixed model, the truth value of a first order formula only depends on what a valuation sends its free variable to.
\begin{holmath}
  \HOLthm[phi/p]{folModels.holds_valuation}
\end{holmath}
\end{prop}
\begin{prop}[\holref{\texttt{holds_functions_predicates}}{chap2_6}{1872}]
If the valuation is fixed, then two models are the same for evaluating a first order formula if they agree on all the functions and predicates appear in the formula.
\begin{holmath}
  \HOLthm[phi/p]{chap2_6.holds_functions_predicates}
\end{holmath}
\end{prop}


Therefore, although a valuation $v$ of \HOLtm{M} will assign elements in \HOLtm{M.Dom} to every natural number, what it effectively does is to only control where does the free variables in a formula goes to. The advantage of using a valuation instead of assign values to the free variables one by one is that a valuation can simultaneously assign terms of type $\alpha$ to any number of free variables.

Let us start looking at how is modal logic related to first order logic. Recall a modal model consists of three pieces of information: A set of worlds, a relation between these worlds, and a valuation of propositional letters at each world. A relation is a binary predicate, and for propositional letter $p$, it gives a unary predicate $P$ on the set of worlds such that $P \ w$ is true for a world if and only if \HOLtm{M.valt p w}. Hence for a $(num,\beta)$-modal model, the information it contains is actually enough for interpreting first order formulas which contains no function symbol, only one binary predicate, some unary predicate, each correspond to a propositional letter, and no predicate symbol of higher arity. For a formula satisfies these properties, we call it is in the \emph{language} $\mathcal L_{\tau}^1$ determined by our modal language. More generally, a language of first order logic is determined by a set of function symbols and a set of predicate symbols, which both are a sets of pairs. In our case, the two sets determine the language $\mathcal L_{\tau}^1$ are \HOLtm{{\}} and \HOLtm{(0,2) INSERT {(p,1) | p ∈ 𝕌(:num)\}}, for function and predicate symbols respectively. This means we fix the predicate symbol correspond to the relation on the model to be $0$. In our formalization, the condition for a first order formula to be in the language $\mathcal L_{\tau}^1$ is given as follows:
\begin{defn}[\holref{The language $\mathcal L_{\tau}^1$}{chap2_6}{29}]
\begin{holmath}
  \HOLthm[def]{chap2_6.L1tau_def}
\end{holmath}
\end{defn}

First order formulas in the language $\mathcal L_{\tau}^1$ are of the main interest in the rest of the thesis. As mentioned above, such formulas can be interpreted by a modal model. But of course, we can not write \HOLtm{fsatis M σ phi} if \HOLtm{M} is not a first order model but a modal model. Hence to interpret $\mathcal L_{\tau}^1$ formulas on modal models, the first thing to do is to formally convert a modal model into a first model. The function that takes a modal model and give the first model we will get by viewing it as a first order model is \HOLtm{mm2folm}. 

\begin{defn}[\holref{Conversion from a modal model to a first order model}{chap2_4revised}{19}]
\begin{holmath}
  \HOLthm[def]{chap2_4revised.mm2folm_def}
\end{holmath}
\end{defn}

As we can see from the above, there is no interesting information in the field $\sf Fun$ of a first model obtained by conversion from a modal model, and for the predicates, the only interesting information is for unary and the only binary one, and the others are constantly false.

 Conversely, we can view a first order model as a modal model, by fixing one binary predicate as the relation in the modal model and let the unary predicate symbols correspond to propositional letters. Here we fix the relation to determined by the binary predicate symbol $0$, and define the function converting a first order model into a modal model as \HOLtm{folm2mm}, as follows:

\begin{defn}[\holref{Conversion from a first order model into a modal model}{chap2_6}{40}]
\begin{holmath}
  \HOLthm[def,M/FM]{chap2_6.folm2mm_def}
\end{holmath}
\end{defn}

Whereas the conversion from a modal model into a first order model preserves any information of the original model, the conversion from a general first order model into a modal model will omit a lot of information: we will loss every function symbols, all except for one binary predicate symbols and all higher arity predicate symbols. Hence we cannot expect the functions \HOLtm{mm2folm} and \HOLtm{folm2mm} are inverses to each other. However, the conversion procedure will preserve $\mathcal L_{\tau}^1$-formulas.
% in the sense that an $\mathcal L_{\tau}^1$ formula is satisfied in \HOLtm{M} under $\sigma$ if and only iff it is satisfied under $\sigma$ in the model we obtain after we firstly convert \HOLtm{M} to a modal model, and then back to a first order model. We prove it as the following proposition:

\begin{prop}[\holref{\texttt{L1tau_mm2folm_folm2mm_comm_feval}}{chap2_6}{976}]
An $\mathcal L_{\tau}^1$ formula is satisfied in \HOLtm{M} under $\sigma$ if and only iff it is satisfied under $\sigma$ in the model we obtain after we firstly convert \HOLtm{M} to a modal model, and then back to a first order model.
\begin{holmath}
  \HOLthm[ϕ/f]{chap2_6.L1tau_mm2folm_folm2mm_comm_feval}
\end{holmath}
\end{prop}

With the setup on basics about first order logic and how does it interact with modal logic, let us start building intuition about how does modal formulas corresponds to first order formulas. The first thing to note is that as every symbol in a first order formula is represented by a natural number, without introducing cumbersome and complicated procedure, we can only translate $num$-modal formulas into first order formulas. Observe that unlike modal formulas which atomic formulas are propositional letters standing alone, even the atomic first order formulas (except \HOLtm{fFALSE}) have variable symbols involved. Hence to translate a modal formula into a first order formula, we must get variables involved as well. For a model \HOLtm{M}, it is natural to regard each modal formula as a predicate to be evaluate at worlds of \HOLtm{M}, such that this predicate is true at a world $w$ if and only if the formula is satisfied at $w$. Hence to translate a modal formula into a first order formula, the only natural thing to do is to get just one variable involved, and this variable will be later assigned to the state in a model by some valuation when we interpret the translated formula. 

Hence for the function \HOLtm{ST} which translates a modal formula to a first order formula, the first parameter it take is a variable symbol $x$, which is represented by a natural number, that we will introduce to mark the world we are looking at, as discussed above, and the second parameter is the $num$-modal formula which we want to translate. 


\begin{defn}[\holref{Standard Translation}{chap2_4revised}{58}]
Here `\HOLtm{ST x phi}' reads the standard translation of the modal formula $\phi$ at $x$.
\begin{holmath}
  \HOLthm[def]{chap2_4revised.ST_def}
\end{holmath}

\end{defn}

Let us analyze the above definition line by line: On the first line, \HOLtm{fP} is the abbrevation of \HOLtm{λp t. Pred p [t]}. We translate a propositional letter into a the unary predicate symbol represented by $p$ applied on the variable $x$. On the second line, we simply translate the falsity in modal formula into the falsity in first order formula. The third and forth line are clear. For the last line, according to the semantical interpretation of the `\HOLtm{DIAM phi}', which is `exists a world related to the current state where \HOLtm{phi} is satisfied, we translate \HOLtm{DIAM phi} into the existential formula, to capture `there exists some world' we must come up with a fresh variable which is bounded by the existential quantifier. To make sure that we are use a fresh variable symbol that is not the same as the variable $x$ which is marking the current state, we use $x+1$ as our new variable symbol, hence the standard translation of \HOLtm{DIAM phi} at $x$ says exactly the same thing as how do we interpret it in the model. 

Some properties of standard translation are immediate to prove.
% Three useful ones are shown below. The first says that there is always one free variable in a first order formula obtained by standard translation, and the third one says a standard translation is always a formula in $\mathcal L_{\tau}^1$.
\begin{prop}[\holref{\texttt{ST_FV_singleton}}{chap2_6}{131}, \holref{\texttt{ST_form_functions_EMPTY}}{chap2_6}{124}, \holref{\texttt{ST_L1tau}}{chap2_6}{33}]
Firstly there is at most one free variable in a first order formula obtained by standard translation. Secondly, a standard translation involves no function symbol. And thirdly, a standard translation is always a formula in $\mathcal L_{\tau}^1$.
\begin{holmath}
  \HOLthm[phi/f]{chap2_6.ST_FV_singleton}\\[3mm]
  \HOLthm[phi/f]{chap2_6.ST_form_functions_EMPTY}\\[3mm]
  \HOLthm[phi/f]{chap2_6.ST_L1tau}
\end{holmath}
\end{prop}


We can conjunct standard translations to get a standard translation. Also, the negation of standard translation is again a standard translation. With the idea of how we deal with big conjunction when we prove Hennessy-Milner theorem, we do not need an explicit definition of big conjunction, and keep things simple by just prove the existence of an standard translation formula such that it is satisfied precisely when a finite set of standard translation formula is satisfied. 

\begin{prop}[\holref{\texttt{ST_BIGCONJ}}{chap2_6}{490}]
\begin{holmath}
  \HOLthm[psi/f,cpsi/cf]{prettyPrinting.ppST_BIGCONJ}
\end{holmath}
\end{prop}

\begin{prop}[\holref{\texttt{ST_fNOT}}{chap2_6}{512}]
\begin{holmath}
  \HOLthm[phi/f]{chap2_6.ST_fNOT}
\end{holmath}
\end{prop}



Standard translation defined like this can be regarded as a first-order reformulation of modal satisfaction, since we have the precise correspondence of modal satisfaction and first-order satisfaction for standard translations.
\begin{prop}[\holref{\texttt{prop_2_47_i}}{chap2_4revised}{76}]
A modal formula is satisfied a point $w$ in a modal model iff its standard translation at $x$ is satisfied at the same modal viewed as a first order model when $x$ is valuated to $w$.
\begin{holmath}
  \HOLthm{prettyPrinting.ppprop_2_47_i}
\end{holmath}
\end{prop} 

There is a result corresponds to the above using \HOLtm{folm2mm}.


\begin{prop}[\holref{\texttt{prop_2_47_i'}}{chap2_7}{98}]
If a first order model \HOLtm{M} satisfies a standard translation \HOLtm{phi}, then if we view \HOLtm{M} as a modal model, the modal formula \HOLtm{phi} is satisfied at the state which is assigned to $x$ by $\sigma$. 
\begin{holmath}
  \HOLthm{prettyPrinting.ppprop_2_47_i'}
\end{holmath}
\end{prop}

As a interesting consequence of the `equivalence' between a modal formula and its standard translation, we can prove formulas obtained by standard translation are \emph{invariant under bisimulation}. 





\begin{defn}[\holref{Invariant for bisimulation}{chap2_6}{1135}]
An $\mathcal L_{\tau}^1$ formula $\alpha(x)$ with at most one free variable $x$ is invariant for bisimulations if for all models \HOLtm{M} and \HOLtm{N}, with \HOLtm{w IN M.frame.world} and \HOLtm{v IN N.frame.world}, if there exists a bisimulation relation between \HOLtm{M} and \HOLtm{N} relating $w$ and $v$, then $\alpha(x)$ holds at \HOLtm{w} if and only if it holds \HOLtm{v} when both \HOLtm{M} and \HOLtm{N} are viewed as first order models.
\begin{holmath}
  \HOLthm[def]{chap2_6.invar4bisim_def}
\end{holmath}
The predicate \HOLtm{invar4bisim} takes four parameters, the first one is the name of the only free variable in \HOLtm{phi} and the last one is the formula itself. For the second and third one. Recall the issue we meet when we define \HOLtm{equiv0} as in the first chapter, it need to take a type as a parameter since we cannot have type variable which only appears on the right hand side but not on the left hand side. For the same reason, here we need to tell HOL4 explicitly about the type of the world set of the models which can serve as \HOLtm{M} and \HOLtm{N} in our definition. 
\end{defn}


%An $\mathcal L_{\tau}^1$-formula $\psi$ which contains at most one free variable is called invariant under bisimulation if once we have models \HOLtm{M}, \HOLtm{N} and \HOLtm{w IN M.frame.world}, \HOLtm{v IN N.frame.world}, if $w$ and $v$ are related by a bisimulation relation, then $\psi$ is satisfied at $w$ in \HOLtm{mm2folm M} if and only if $\psi$ is satisfied in \HOLtm{mm2folm N} when we assign $x$ to $w$ and $v$ respectively.




 %Recall that in \texttt{thm_2_20}, we prove that worlds which are bisimilar are modal equivalent. Putting \texttt{thm_2_20} and \texttt{prop_2_47} together, we conclude that given any modal formula \HOLtm{phi} and consider modal models \HOLtm{M} and \HOLtm{N} where \HOLtm{w IN M.frame.world} and \HOLtm{v IN N.frame.world} are bisimilar. After viewing both \HOLtm{M} and \HOLtm{N} as first order models, for any variable symbol $x$, \HOLtm{ST x phi} is satisfied at \HOLtm{w} if and only if it is satisfied at \HOLtm{v}. 

\begin{prop}[\holref{\texttt{thm_2_68_half2'}}{chap2_6}{1899}]
Standard translations are invariant for bisimulation.
\begin{holmath}
  \HOLthm[showtypes]{chap2_6.thm_2_68_half2'}
\end{holmath}
\end{prop}

\begin{proof}
By \texttt{ST_FV_singleton} and \texttt{ST_L1tau}, a formula obtained by standard translation has at most one free variable and is $\mathcal L_{\tau}^1$.
By \texttt{thm_2_20}, bisimilar worlds are modal equivalent, the result follows from \texttt{prop_2_47}.

\end{proof}

In fact, using set theory as foundation, we can prove that every formula which is invariant under bisimulation arises as a standard translation of a modal formula, so formulas which are invariant under bisimulation coincides with standard translations. We can translate the set-theoretic proof into a simple type-theoretic proof. But the proof of the other direction requires more advanced tools, and also does not look the same as its mathematical statement as in set theory in HOL4 because of the lack of expressiveness of simple type theory. We will leave the other direction of the proof to the next chapter.


The current definition of standard translation makes good semantical sense, but syntactically, it has space for improvement: To make the notation simple, we use mathematical notation to talk about our example, where $ST_{x}\phi$ is \HOLtm{ST x phi} as above, $R$ is our \HOLtm{fR} and $\exists x \phi$ is our \HOLtm{fEXISTS x phi}. The formula \HOLtm{DIAM (DIAM f)} with $a_1$ marking its state is translated to $\exists a_2(R a_1 a_2\land\exists a_3(Ra_2a_3 \land ST_{a_3}(f)))$, it uses three variables $a_1,a_2$ and $a_3$, which is unnecessary: the formula above is equivalent to $\exists a_2(R a_1 a_2\land\exists a_1(Ra_2a_1\land ST_{a_1}(f)))$. With this observation, we conclude that we do not need to always come up with a variable symbol for each \HOLtm{DIAM}, instead, we can use only two variable symbols alternating in each layer. As a consequence, we can redefine standard translation as follows, where $x$ is the variable $0$ or $1$. Using such a definition, the we get a version of standard translation that always use no more than two variable symbols.

\begin{defn}[\holref{Alternative definition of standard translation}{chap2_4revised}{153}]
\begin{holmath}
  \HOLthm[def]{chap2_4revised.ST_alt_def}
\end{holmath}
\end{defn}

\begin{prop}[\holref{\texttt{ST_alt_two_var}}{chap2_4revised}{233}]
\begin{holmath}
  \HOLthm{chap2_4revised.ST_alt_two_var}
\end{holmath}
\end{prop}

As we expected, these two versions of definition of standard translation actually gives equivalent translated formulas. It is evident from the follow proposition we can prove. 
\begin{defn}[\holref{\texttt{prop_2_47_i_alt}}{chap2_4revised}{161}]
\begin{holmath}
  \HOLthm{prettyPrinting.ppprop_2_47_i_alt}
\end{holmath}
\end{defn}

To conclude this section, we state the result that every modal formula is `equivalent' to a first order formula containing only two variables in the sense of equi-satisfaction, such a first order formula is actually obtained by translating the modal formula using \HOLtm{ST_alt}. The result is shown below:

\begin{prop}[\holref{\texttt{prop_2_49_i}}{chap2_4revised}{263}]
\begin{holmath}
  \HOLthm[psi/fphi]{chap2_4revised.prop_2_49_i}
\end{holmath}
\end{prop}

\section{Modal Saturation via ultrafilter extensions}

In the second chapter, we have seen bisimilarity implies modal equivalence, but only proved the converse for image finite models. In this section, we are interested in another particular class of models, called \emph{m-saturated} models, where worlds which are modal equivalent are bisimilar. 

Let us explain what is meant by `m-saturated' first. m-saturated is a sort of compactness property, which says `finite satisfaction implies satisfaction'. We need give three definitions consecutively to finally get m-saturation to be formally defined in HOL4. 


%More precisely, a set of formulas \HOLtm{Σ} is called satisfiable in a set of worlds $X$ of a model \HOLtm{M} if there exists a world in $X$ such that all the formulas in \HOLtm{Σ} are satisfied, and is called finitely satisfiable if every finite subset of \HOLtm{Σ} is satisfiable, a model is called m-saturated if for any \HOLtm{w IN M.frame.world}, if a set \HOLtm{Σ} is finitely satisfiable in the set of in the set of successors of $w$, then it is satisfiable in the set of successors of $w$.
\begin{defn}[\holref{Satisfiable}{chap2_5}{43}]
 A set of formulas \HOLtm{Σ} is called satisfiable in a set of worlds $X$ of a model \HOLtm{M} if there exists a world in $X$ such that all the formulas in \HOLtm{Σ} are satisfied. 
\begin{holmath}
  \HOLthm[def,phi/form]{chap2_5.satisfiable_in_def}
\end{holmath}
\end{defn}

\begin{defn}[\holref{Finitely satisfiable}{chap2_5}{47}]
A set of formulas \HOLtm{Σ} is called finitely satisfiable if every finite subset of \HOLtm{Σ} is satisfiable. 
\begin{holmath}
  \HOLthm[def]{chap2_5.fin_satisfiable_in_def}
\end{holmath}
\end{defn}

\begin{defn}[\holref{m-saturated}{chap2_5}{50}]
A model is called m-saturated if for any \HOLtm{w IN M.frame.world}, if a set \HOLtm{Σ} is finitely satisfiable in the set of in the set of successors of $w$, then it is satisfiable in the set of successors of $w$.
\begin{holmath}
\HOLthm[def]{prettyPrinting.ppM_sat_def}
\end{holmath}
\end{defn}

m-saturated models are useful because it is another kind of models that make bisimilarity and modal equivalence coincide. 

\begin{prop}[\holref{\texttt{prop_2_54_DIST_TYPE}}{chap2_5}{136}]
For two worlds $w_1$ and $w_2$ living in m-saturated models \HOLtm{M1} and \HOLtm{M2} respectively, if $w_1$ and $w_2$ are modal equivalent, then they are bisimilar.
\begin{holmath}
  \HOLthm[M1/M,M2/M',w1/w,w2/w']{prettyPrinting.ppprop_2_54_DIST_TYPE}
\end{holmath}
\end{prop}

\begin{proof}
Let \HOLtm{M1} and \HOLtm{M2} be $(\alpha,\beta),(\alpha,\gamma)$-models respectively. Under the assumptions, the bisimulation relation is given by \HOLtm{λw1 w2. (!phi. satis M1 w1 phi <=> satis M2 w2 phi)}. To prove this relation is indeed a bisimulation, the only non-trivial clause to check is that for worlds $w_1,v_1$ of \HOLtm{M1} and world $w_2$ of \HOLtm{M2} such that $w_1$ and $w_2$ are modal equivalent, we can find a world $v_2$ of \HOLtm{M2} such that \HOLtm{M2.frame.rel w2 v2} and $v_1$ and $v_2$ are modal equivalent. This statement may familar, as we have been asked to prove it in Hennessy-Milner theorem. But the idea used here is completely different from that proof.

Under the assumptions above, let \HOLtm{Σ} denote the set of formulas satisfied by $v_1$, it suffices to find a successor of $w_2$ where each formula in \HOLtm{Σ} is satisfied. As \HOLtm{M2} is m-saturated, it suffices to prove each finite subset $\Delta\subseteq \Sigma$ is satisfied in some successor of $w_2$. Take such a $\Delta$, then it is satisfied at $v_1$ by its definition. As $\Delta$ is finite, there exists a formula $\psi$ such that for all $(\alpha,\beta)$-models, $\psi$ is satisfied at a world if and only if all elements in $\Delta$ are satisfied, just as what we did in the proof of Henessy-Milner theorem. We have \HOLtm{satis M1 v1 psi}, and therefore \HOLtm{satis M1 w1 (DIAM psi)}. By modal equivalence of $w_1$ and $w_2$, we then get \HOLtm{satis M2 w2 (DIAM psi)}, so there exists a successor of $w_2$ that satisfies $\psi$. 

But the property of formula $\psi$ is not enough to let us continue with our proof! On the next step, we need to conclude that there is a successor of $w_2$ that satisfies all the formulas in $\Sigma$, but from above, although we can conclude that $w_2$ has a successor that satisfies the formula \HOLtm{psi}, the conditions by hand do not allow us to conclude that such a successor of $w_2$ satisfies all the formulas in $\Delta$. The problem comes from the fact that the type of world set of \HOLtm{M1} and \HOLtm{M2} are different: the lemma that gives big conjunction only gives a formula which works as a big conjunction of finitely many formulas on one type. It does not prove that for any finite set $s$ of modal formulas, there exists a modal formula which is equivalent to the conjunction of all the elements of $s$ on models with their world set of any type. In our case, for our formula $\psi$, we know for any $(\alpha,\beta)$-model \HOLtm{M1} with \HOLtm{w1 IN M1.frame.world}, we have \HOLtm{satis M1 w1 psi} if and only if all the elements in $\Delta$ are satisfied. But the \HOLtm{M2} here is an $(\alpha,\gamma)$-model, so even though we already know that there exists a world $v_2$ such that \HOLtm{satis M2 v2 psi}, there is nothing allowing us to derive \HOLtm[phi/f]{!f. f IN Δ ==> satis M2 v2 f}.

This problem is not hard to fix here: since we only need a big conjunction formula which works on models of two distinct types. Therefore, we prove the following lemma:

\begin{holmath}
  \HOLthm[phi/f,psi/ff,showtypes]{chap2_5.BIGCONJ_EXISTS_DIST_TYPE}
\end{holmath}

The formula obtained from lemma with $s=\Delta$ works perfectly for our proof.
\end{proof}

Since m-saturated models are nice, here is a natural question: How can we get such models? In the following of this section, we will see the fact that for every model its \emph{ultrafilter extension} is an m-saturated model. In order to talk about ultrafilter extensions, we need to build a theory of ultrafilters in HOL4.

\subsection{Interlude II: Ultrafilters}

As its name suggests, an ultrafilter is a special kind of filter. 

%Given a non-empty set $W$, a set $L$ which is a subset of the power set of $W$, is called a filter if it contains $W$ itself, closed under binary intersection, and is closed upward. Note that by induction, closure under binary intersection implies closure under any finite intersection. The simplest but most boring filter is the power set \HOLtm{POW} $W$ itself. By upward closure, if a filter on $W$ contains the empty set, then the filter must be the whole power set \HOLtm{POW} $W$. We are mainly interested to filters which is not a power set, such a filter is called a \emph{proper filter}. 
\begin{defn}[\holref{Filter}{ultrafilter}{18}]
 Given a non-empty set $W$, a set $L$ which is a subset of the power set of $W$, is called a filter if it contains $W$ itself, closed under binary intersection, and is closed upward. 
\begin{holmath}
  \HOLthm[def,L/FLT]{ultrafilter.filter_def}
\end{holmath}
 Note that by induction, closure under binary intersection implies closure under any finite intersection.
\end{defn}

The simplest but most boring filter is the power set \HOLtm{POW} $W$ itself. By upward closure, if a filter on $W$ contains the empty set, then the filter must be the whole power set \HOLtm{POW} $W$. We are mainly interested to filters which is not a power set, such a filter is called a \emph{proper filter}. 

For a partially ordered set $C$, it is called a \emph{chain} if for any $a,b\in C$, we have either $a \le b$ or $b\le a$. In particular, a set of sets is natually equipped with a partial order given by containment. We can union a chain of proper filters to get a proper filter. 

\begin{prop}[\holref{\texttt{UNION_proper_proper}}{ultrafilter}{342}]
If $U$ is a chain of proper filters, then the union of elements of $U$ is again a proper filter. 
\begin{holmath}
  \HOLthm{ultrafilter.UNION_proper_proper}
\end{holmath}
\end{prop}

Besides the proper filters, another important kind of filter is called \emph{generated filter}. It has many versions of definitions, which are all equivalent. Fix a set $W$ and a subset $E$ of its power set, all of the followings can serve as definition of `the filter on $W$ generated by $E$':
\begin{itemize}

\item The filter generated by $E$ is the intersection of all of the filters on $W$ which contains $E$, that is, it is the big intersection $\bigcap\ \{F\mid E\subseteq F\land F\text{ is a filter on } W\}$.

\item The filter generated by $E$ is the smallest filter on $W$ that contains $E$.

\item The filter generated by $E$ is the set of all the subsets of $W$ which is either $W$ itself or contains a intersection of finitely many elements in $E$, in mathematical language, it is the set
$\{X\mid X\subseteq W\land((X = W)\lor ((\exists S\subseteq E)(S \text{ is finite}\land \bigcap S\subseteq X)))\}$.

\end{itemize}

We take the first of those three as our definition of generated filter as it is defined in terms of big intersection, and hence directly allows us to derive a induction principle which can be very useful to prove the proper of elements in the generated filter. 
%More precisely, if $P$ is a property on sets, to prove $P$ holds for any element of the filter on $A$ generated by $E$, the induction principle we will get from the first definition will reduce the task in to prove the followings: Firstly, we need $A$ has the property $P$, and if $X$ and $Y$ both has $P$, we require $X\cap Y$ also has $P$, and the last thing to prove is that if $X$ has $P$, any subset of $A$ that contains $X$ also has $P$. The only defect of this definition is that if we use it, than the fact that generated filter is a filter is not automatic. Nevertheless, it is easy enough to prove using induction principle:
 

%Actually, all of the above definitions can be captured by the HOL4, where the first two just require a translation into machine language, but the third one requires some extra effort, we will prove all the three definitions are equivalent. 

\begin{defn}[\holref{Generated filter}{ultrafilter}{57}]
\begin{holmath}
  \HOLthm[def]{ultrafilter.generated_filter_def}
\end{holmath}
\end{defn}

\begin{prop}[Induction principle for generated filters, \holref{\texttt{generated_filter_ind}}{ultrafilter}{60}]
\begin{holmath}
  \HOLthm{ultrafilter.generated_filter_ind}
\end{holmath}
If $P$ is a property on sets, to prove $P$ holds for any element of the filter on $A$ generated by $E$, the induction principle will reduce the task in to prove the followings: Firstly, we need $A$ has the property $P$, and if $X$ and $Y$ both has $P$, we require $X\cap Y$ also has $P$, and the last thing to prove is that if $X$ has $P$, any subset of $A$ that contains $X$ also has $P$.
\end{prop}

 The only defect of this definition is that if we use it, than the fact that generated filter is a filter is not automatic. Nevertheless, it is easy enough to prove using the induction principle above. 

Actually, all of the three definitions listed  can be captured by the HOL4, and we can prove in HOL4 that all the three definitions are equivalent. Since the properties required by the second and third definition define a set uniquely, it suffices to show the property required by the second and third definition is satisfied by the generated filter we defined above. They are proved as the following two theorems:


\begin{prop}[\holref{\texttt{generated_filter_minimal}}{ultrafilter}{784}]
For any set $E$ of subsets of a non-empty set $W$, any filter on $W$ containing $E$ must contain the filter generated by $E$. 
\begin{holmath}
  \HOLthm{ultrafilter.generated_filter_minimal}
\end{holmath}
\end{prop}

%It is easy to see what subsets are in the generated filter: We put any subset $W$ that contains a finite intersection of elements in $F$ in the generated filter of $F$, such subsets are precisely the ones that are required by the definition. We also use the induction principle of generated filter to prove this concrete construction is equivalent to our definition
\begin{prop}[\holref{\texttt{generated_filter_elements}}{ultrafilter}{741}]
The elements of generated filter is the same as what we stated in the third definition of generated filter. 
\begin{holmath}
  \HOLthm{ultrafilter.generated_filter_elements}
\end{holmath}
\end{prop}

The filters generated by a singleton are particularly interesting. For a set $W$ and an element $w\in W$, by definition of generated filter, the filter generated by \HOLtm{{w\}} is the set of subsets of $W$ that contains $w$, it is trivial to check it is indeed a filter. Such a filter is called \emph{principal filters}. In HOL4, we define a function \HOLtm{principle_UF} to capture these filters, where \HOLtm{principle_UF w W0} is the principal filter generated by $w$ in $W$ when $w$ is an element of $W$. Actually, principal filters are simplest examples of \emph{ultrafilters}. 
\begin{defn}[\holref{Ultrafilter}{ultrafilter}{34}]
 An ultrafilter on a set $W$ is a proper filter $F$ such that for any $S\subseteq W$, either $S$ or its complement $W\setminus S$ is in $F$, but not both.
\begin{holmath}
  \HOLthm[def]{ultrafilter.ultrafilter_def}\\[3mm]

\end{holmath}
\end{defn}

\begin{prop}[\holref{\texttt{principle_UF_UF}}{ultrafilter}{122}]
Principle filters are ultrafilters. 
\begin{holmath}
  \HOLthm{ultrafilter.principle_UF_UF}
\end{holmath}
\end{prop}

In the rest of this interlude, we are interested in the question that how can we get an ultrafilter. We will get our answer by the end of the interlude, which proves a corollary of the ultrafilter theorem. This corollary says that for any subset if $\mathcal P(W)$ which has \emph{finite intersection property}, it can be extended to an ultrafilter on $W$. 
%A subset of $\mathcal P (W)$ has finite intersection property if once we take the intersection of finitely many elements in it, the resultant set is nonempty. Any proper filter has the finite intersection property, since if the finite intersection of elements of a proper filter give the empty set, then it will contradicts the properness of a filter. Note that finite intersection property is a property of subset of power sets, hence \HOLtm{FIP} defined below takes two parameters, a set of subsets of $W$, and an ambient set $W$. 
\begin{defn}[\holref{Finite intersection property}{ultrafilter}{179}]
 A subset of $\mathcal P (W)$ has finite intersection property if once we take the intersection of finitely many elements in it, the resultant set is nonempty.
\begin{holmath}
  \HOLthm{ultrafilter.FIP_def}
\end{holmath}
\end{defn}

Note that finite intersection property is a property of subset of power sets, hence \HOLtm{FIP} defined below takes two parameters, a set of subsets of $W$, and an ambient set $W$. 
%Any proper filter $U$ has the finite intersection property. Moreover, for $B\subseteq W$ such that neither $B$ nor $W/B$ is in $U$, then inserting $B$ to $U$ does not destory the finite intersection property of $U$.


\begin{prop}[\holref{\texttt{proper_filter_FIP}}{ultrafilter}{245}]
Any proper filter has the finite intersection property. 
\begin{holmath}
  \HOLthm{ultrafilter.proper_filter_FIP}
\end{holmath}
\end{prop}
\begin{proof}
 If the finite intersection of elements of a proper filter give the empty set, then it will contradicts the properness of a filter by upward closure property of a filter. 
\end{proof}


\begin{prop}[\holref{\texttt{proper_filter_INSERT_FIP}}{ultrafilter}{266}]
For $B\subseteq W$ such that neither $B$ nor its complement is in $U$, inserting $B$ to $U$ does not destory the finite intersection property of $U$.
\begin{holmath}
  \HOLthm{ultrafilter.proper_filter_INSERT_FIP}
\end{holmath}
\end{prop}

\begin{proof} 
Take a finite subset $S\subseteq \{B\}\cup U$, if $B\notin S$, then we are done by \texttt{proper_filter_FIP}. Otherwise, if we have $\bigcap S = B \cap (\bigcap U')=\emptyset$ for some finite $U'\subseteq U$, it will imply $\bigcap U'\subseteq W\setminus B$, hence $W\setminus B\in U$ by upward closure of a filter, contradicting the assumption that $W\setminus B\notin U$.
\end{proof}

Towards the goal of extending a set with finite intersection property to an ultrafilter, we firstly prove that a set with finite intersection property can be extended into a proper filter.
\begin{prop}[\holref{\texttt{FIP_PSUBSET_proper_filter}}{ultrafilter}{212}]
For any set $S$ of subsets of a nonempty set $W$ with finite, there is a proper filter that contains $S$. 
\begin{holmath}
  \HOLthm{ultrafilter.FIP_PSUBSET_proper_filter}
\end{holmath}
\end{prop}
\begin{proof}
The desired proper filter is given by the filter generated by $S$, checking its property is straightfoward.
\end{proof}


A proper filter which is not properly contained by any proper filter is called a maximal filter. Any ultrafilter is maximal. For a proof: Consider an ultrafilter $U$ on $W$. Recall the fact that for each subset of $U$, either the set itself or its complement is in $U$, but not both. If a filter properly contains $U$, then it must contain both $A$ and $W\setminus A$ for some $A\subseteq W$, hence by closure under intersection, it will contain the empty set. It follows that there is no proper filter that properly contains $U$. The converse also holds, that is, ultrafilters and maximal filters are actually the same thing. But the proof is a bit more complicated. The converse is proved below: 
% add a lemma about iff?
\begin{prop}[\holref{\texttt{maximal_ultrafilter}}{ultrafilter}{297}]
Any maximal filter is an ultrafilter. 
\begin{holmath}
  \HOLthm{ultrafilter.maximal_ultrafilter}
\end{holmath}
\end{prop}
\begin{proof}
If a maximal filter $U$ on $W$ is not an ultrafilter, then for some $A$, either $A\in U\land W \setminus A\in U$ or $A\notin U\land W\setminus A\notin U$. In the first case we have $\emptyset\in U$, contradicts the properness of maximal filter. In the second case, by \texttt{proper_filter_INSERT_FIP}, the set $U\cup \{A\}$ has the finite intersection property, hence extends to a proper filter $U'$ by \texttt{FIP_PSUBSET_proper_filter}. But then $U$ is properly contained in $U'$ since $A\in U'$ but $A\notin U$, contradicts the maximality of $U$. This completes the proof. 
\end{proof}

With all these set-ups, we can begin our proof of ultrafilter theorem now.
%talk about Zorn's lemma in the HOL?
\begin{thm}[\holref{\texttt{ultrafilter_theorem}}{ultrafilter}{361}]
Any proper filter is contained in an ultrafilter. 
\begin{holmath}
  \HOLthm{ultrafilter.ultrafilter_theorem}
\end{holmath}
\end{thm}

\begin{proof}
Given a property filter $F$, we will find out an ultrafilter containing it. Consider the set $S$ of all the proper filters containing $F$, ordered by inclusion, we will apply Zorn's lemma on $S$. The Zorn's lemma in the HOL4 looks like:

\begin{holmath}
  \HOLthm{set_relation.zorns_lemma}
\end{holmath}

Here $s$ is a set, $r$ is a predicate that takes a pair of elements $(a,b)$ with $a,b\in s$ and return the truth value whether $a$ and $b$ are related. For a set $t$ with the same type as $s$, we have \HOLtm{chain t r} if for any $a,b\in t$, we have either $(a,b)\in r$ or $(b,a)\in r$. Here our $s$ is the set $S$ defined above. $r$ is defined by inclusion. For $A,B\in S$, $(A,B)\in r$ iff $A\subseteq B$, so a chain $T$ on $S$ is a subset of $S$ such that $A\subseteq B$ or $B\subseteq A$ for any $A,B\in T$.

The thing to check is that any chain $T$ on $S$ has an upper bound. If the chain is empty, then the upper bound is clearly $F$. Otherwise, we claim the union of the chain is the upper bound. To prove the claim, it amounts to check:

\begin{itemize}
  \item $\bigcup T$ is a proper filter containing $F$.
  \item Any element in $T$ is a subset of $\bigcup T$.
\end{itemize}
  The second item is trivial, the first one is by \texttt{UNION_proper_proper}.

Applying the Zorn's lemma gives a proper filter $X\in S$ which is an maximal element of $S$, it suffices to prove $X$ is an ultrafilter. The fact that $X$ is the maximal element of $S$ proves $X$ is a maximal filter, hence we are done by \texttt{maximal_ultrafilter}.
\end{proof}

As a corollary, we can extend any set with finite intersection into an ultrafilter:

\begin{prop}[\holref{\texttt{ultrafilter_theorem_corollary}}{ultrafilter}{417}]
For any set $s$ of subsets of a non-empty set $W$, there exists an ultrafilter on $W$ which contains $s$.
\begin{holmath}
  \HOLthm{ultrafilter.ultrafilter_theorem_corollary}
\end{holmath}
\end{prop}

\begin{proof}
For $S\subseteq {\mathcal P}(W)$ with finite intersection property, by \texttt{FIP_PSUBSET_proper_filter}, we have a proper filter $P$ containing $S$, and $P$ extends to an ultrafiler $U$ such that $S\subseteq P\subseteq U$ by \texttt{ultrafilter_theorem}.
\end{proof}
%A special kind of ultrafilters, called countably incomplete ultrafilters, will play an important role in our discussion about ultraproducts in the next interlude, so we also give some basics about countably incomplete ultrafilters here. Firstly, the definition is:

As an application of \texttt{ultrafilter_theorem_corollary}, we prove the existence of \emph{countably incomplete ultrafilters}. A countably incomplete ultrafilter is an ultrafilter which is not closed under countably infinite intersection.
\begin{defn}[\holref{Countably incomplete ultrafilter}{ultrafilter}{509}]
A countably incomplete ultrafilter $U$ on $W$ is an ultrafilter on $W$ such that there is a countably infinite set of $U$ whose intersection is empty. 
\begin{holmath}
  \HOLthm[def,K/IFS]{ultrafilter.countably_incomplete_def}
\end{holmath}
\end{defn}

\begin{prop}[\holref{\texttt{example_2_72}}{ultrafilter}{513}]
Any ultrafilter $U$ on the natural numbers $\mathbb N$ which does not contain any singleton is countably incomplete.
\begin{holmath}
  \HOLthm{ultrafilter.example_2_72}
\end{holmath}
\end{prop}
\begin{proof}
Under the assumptions, the countable intersection of the sets $\mathbb N\setminus \{n\}$ which are members of $U$ yields the empty set.
\end{proof}

Therefore, we just need to find out an ultrafilter on $\mathbb N$ which does not contain any singleton. Clearly, we will done if we can prove the existence of an ultrafilter on $\mathbb N$ which does not contain any finite set. It suffices to prove the set of subsets of $\mathbb N$ of form $\mathbb N\setminus X$ has finite intersection property, then by \texttt{ultrafilter_theorem_corollary}, this set will extend to an ultrafilter. This ultrafilter will not contain any finite set, otherwise, it will contain both a subset of $\mathbb N$ and also its complement, which will contradict its properness.
\begin{prop}[\holref{\texttt{exercise_2_5_4_a}}{ultrafilter}{536}]
The set of subsets of $\mathbb N$ of form $\mathbb N\setminus X$ has finite intersection property.
\begin{holmath}
  \HOLthm{ultrafilter.exercise_2_5_4_a}
\end{holmath}
\end{prop}
\begin{proof}

By definition of the finite intersection property, it suffices to prove for any finite $S_0\subseteq$ \HOLtm{{𝕌(:num) DIFF X | FINITE X\}}, if $S_0\ne \emptyset$, then \HOLtm{BIGINTER S0} is infinite. This is done by induction of finiteness of $S$. 
\end{proof}

In the next chapter, we will see the usefulness of the following interesting feature of countably incomplete ultrafilters: 
\begin{prop}[\holref{\texttt{countably_incomplete_chain}}{ultrafilter}{653}]
In a countably incomplete ultrafilter$U$ on $I$, we can find a chain $I=I_0\supseteq I_1\supseteq I_2\supseteq\cdots$ with each $I_i$ is in $U$, such that $\bigcap_{n\in \mathbb N}I_n=\emptyset$. As before, throughout the following proof, we will capture indexing of family of sets as a function from the index set. 
\begin{holmath}
  \HOLthm{ultrafilter.countably_incomplete_chain}
\end{holmath}
\end{prop}
\begin{proof}
By definition of countably incompleteness, there exists a family $X_n$ in $U$ indexed by natural numbers such that $\bigcap_{n\in \mathbb N}X_n=\emptyset$. Define $J_n:=\bigcap_{m\le n}X_n$, so $J_{n+1}\subseteq J_n$ for all $n\in\mathbb N$, and moreover $\bigcap_{n\in \mathbb N}J_n=\emptyset$. In HOL4, the family $J_n$ is defined recursively as the function \HOLtm{ PRIM_REC (X 0) (\Xn n. Xn ∩ (X (n + 1)))}. We get the desired chain $I_n$ by inserting $I$ at the begining of $J_n$.
\end{proof}
 

This is the end of Interlude II. 

With the theory about ultrafilters built in HOL4, we can now launch on the construction of ultrafilter extension of a model. For a model \HOLtm{M}, the world set of its ultrafilter extension of \HOLtm{M} is simply the set of ultrafilters on the world set of \HOLtm{M}, whereas the relation defined on the set of ultrafilters require more explanation to understand. 

Fix a model \HOLtm{M} and a subset $X$ of its world set, we can consider two set of worlds arises from $X$: One of them is the set of worlds of \HOLtm{M} which `can see' some world in $X$, an element of this set is a world $w$ of \HOLtm{M} such that there exists some \HOLtm{v IN X} such that \HOLtm{M.frame.rel w v}.  The other one is the set of worlds in \HOLtm{M} which `only see' the worlds in $X$, an element $w$ of this set is a world in \HOLtm{M} such that once we have \HOLtm{M.frame.rel w v} for some other world \HOLtm{v IN M.frame.world}, we must have \HOLtm{v IN X} as well. Formally, their definitions are given as:

\begin{defn}[\holref{`Can see'}{chap2_5}{189} and \holref{`Only see'}{chap2_5}{192}]
Given a model \HOLtm{M} and a set \HOLtm{X} of worlds of \HOLtm{M}, an element in the set of worlds of \HOLtm{M} which `can see' some world in $X$ is a world $w$ of \HOLtm{M} such that there exists some \HOLtm{v IN X} such that \HOLtm{M.frame.rel w v}.  An element in the set of worlds in \HOLtm{M} which `only see' the worlds in $X$ is a world $w$ in \HOLtm{M} such that once we have \HOLtm{M.frame.rel w v} for some other world \HOLtm{v IN M.frame.world}, we must have \HOLtm{v IN X}.
\begin{holmath}
  \HOLthm[def]{chap2_5.can_see_def}\\[3mm]
  \HOLthm[def]{chap2_5.only_see_def}
\end{holmath}
\end{defn}

By definition of satisfaction, for any model formula \HOLtm{phi}, the worlds satisfying \HOLtm{DIAM phi} is exactly the set of worlds that can see a world where \HOLtm{phi} is satisfied, and the worlds that satisfy \HOLtm{BOX phi} are exactly the worlds that only sees the worlds where \HOLtm{phi} is satisfied. 


 The concept `can see' and `only see' are actually dual to each other.


\begin{prop}[Duality between \holref{`can see'}{chap2_5}{213} and \holref{`only see'}{chap2_5}{207}]
The worlds that can see an world in $X$ is precisely a world that does not only see worlds that are not in $X$. Similarly, a world that can only see worlds in $X$ is precisely a world which can not see worlds which are not in $X$. 
\begin{holmath}
  \HOLthm{chap2_5.can_only_dual}\\[3mm]
  \HOLthm{chap2_5.only_can_dual}
\end{holmath}
\end{prop}

A world can see some world in the union of $X$ and $Y$ if and only if it can see a world in $X$ or a world in $Y$, hence \HOLtm{can_see} distributes over union. Similarly, a worlds only see the worlds in the intersection of $X$ and $Y$ if and only if it can only see worlds in $X$ and worlds in $Y$.


\begin{prop}[\holreff{\texttt{can_see_UNION}}{chap2_5}{611}, \holref{\texttt{only_see_INTER}}{chap2_5}{273}]
The operation \HOLtm{can_see M} for any model \HOLtm{M} distributes over union, and \HOLtm{only_see M} distributes over intersection. 
\begin{holmath}
  \HOLthm{prettyPrinting.ppcan_see_UNION}\\[3mm]
  \HOLthm{chap2_5.only_see_INTER}
\end{holmath}
\end{prop}


Return to the discussion about definition of relation on the ultrafilter extension of \HOLtm{M}. We define:

\begin{defn}[\holref{Relation used in ultrafilter extension}{chap2_5}{221}]
Two ultrafilter $u,v$ on \HOLtm{M} to be related if for any $X\in u$, the set that $X$ can see is in $v$. 
\begin{holmath}
  \HOLthm[def]{chap2_5.UE_rel_def}
\end{holmath}
\end{defn}

 By the duality between `can see' and `only see', this relation has a reformulation:

\begin{prop}[\holref{\texttt{exercise_2_5_5}}{chap2_5}{237}]
Two ultrafilters $u$ and $v$ on \HOLtm{M.frame.world} are related if and only if for any subset $Y$ of \HOLtm{M.frame.world}, if the set of worlds of \HOLtm{M} that it can only see $Y$ is in $u$, then $Y$ is in $v$.
\begin{holmath}
  \HOLthm{prettyPrinting.ppexercise_2_5_5}
\end{holmath}
\end{prop}

\begin{proof}
Suppose \HOLtm{UE_rel M u v} and pick a set $Y$ of worlds such that \HOLtm{(only_see M Y) IN u}, we will prove $Y\in V$. As $v$ is an ultrafilter, it suffices to prove that \HOLtm{(M.frame.world DIFF Y) ∉ v}, by definition of \HOLtm{UE_rel}, since we have \HOLtm{UE_rel M u v}, it suffices to prove \HOLtm{(can_see M (M.frame.world DIFF Y)) ∉ u}. As $u$ is also an ultrafilter, it suffices to prove \HOLtm{(M.frame.world DIFF (can_see M (M.frame.world DIFF Y))) IN u}. But we have \HOLtm{M.frame.world DIFF can_see M (M.frame.world DIFF Y) = only_see M Y} by duality, and hence we are done. 

Conversely, assume the right hand side, and pick any $X\in v$, we prove \HOLtm{(can_see M X) IN u}, which amounts to prove \HOLtm{M.frame.world DIFF (only_see M (M.frame.world DIFF X))} is in $u$ by the duality. As $v$ is an ultrafilter, we have \HOLtm{M.frame.world DIFF X ∉ v}, under the assumption, it implies \HOLtm{only_see M (M.frame.world DIFF X) ∉ u}, so we are done as $u$ is an ultrafilter. 
\end{proof}

In order to define the ultrafilter extension model, the only remaining issue is to define the valuation. We define a propositional letter $p$ to be satisfied at an ultrafilter $v$ if and only if the worlds in \HOLtm{M} which satisfies the $p$ is in $v$. Hence the full definition of ultrafilter extension is:

\begin{defn}[\holref{Ultrafilter extension}{chap2_5}{267}]
The ultrafilter extension \HOLtm{UE} is defined as a function that takes a model and given the extended model. 
\begin{holmath}
  \HOLthm[def]{chap2_5.UE_def}
\end{holmath}
\end{defn}
The ultrafilter extension also changes the type of the input model, namely, it change the type of world set from $\beta$ to $(\beta\to bool)\to bool$, it is indeed an extension, in the sense that \HOLtm{M} is embedded in \HOLtm{UE M} as a submodel by the function sending \HOLtm{w IN M.frame.world} to the principle ultrafilter \HOLtm{principle_UF w M.frame.world} generated by $w$. In general, this embedding does not necessarily give a generated submodel, nevertheless, we have an invariance result for this embedding:
\begin{prop}[\holref{\texttt{prop_2_59_ii}}{chap2_5}{483}]
For any model \HOLtm{M} and any world \HOLtm{w} of \HOLtm{M}, \HOLtm{w} is modal equivalent to the principle filter generated by \HOLtm{w} which is embedded in the ultrafilter extension of \HOLtm{M}. 
\begin{holmath}
  \HOLthm{chap2_5.prop_2_59_ii}
\end{holmath}
\end{prop}
This is actually a special case of the following proposition, where $u$ is taken as \HOLtm{principle_UF w M.frame.world}. This proposition below captures the idea that ultrafilters are used to describe the sense of `most'. More explicitly, for an ultrafilter $U$ on a set $W$, we can regard $U$ as the set of subset of $W$ where can be regarded as `most of' elements in $W$, then the closure property under intersection can be interpreted as `if two subsets of $W$ both contain most of elements in $W$, then their intersection also contains most of elements in $W$'. The upward closure property can be regarded as `if a subset of $W$ contains most of elements in $W$, then any subset of $W$ that contains this subset also contain most of elements in $W$', which consists with our intuition. Finally, if a subset of $W$ is regarded as `most of elements in $W$', then we are regarding its complement as `a small part of elements in $W$', so its complement cannot also be in the ultrafilter. From this aspect, the proposition below says that a formula $\phi$ is satisfied in an ultrafilter $u$ on \HOLtm{M.frame.world} iff $\phi$ is satisfied at most worlds in \HOLtm{M}, where the sense of `most' is measured by $u$, as described above. 
\begin{prop}[\holref{\texttt{prop_2_59_i}}{chap2_5}{316}]
A formula \HOLtm{phi} is satisfied at an ultrafilter $u$ in the ultrafilter extension of \HOLtm{M} if and only if in the unextended model, the set of worlds in \HOLtm{M} satisfying \HOLtm{phi} is in \HOLtm{u}. 
\begin{holmath}
  \HOLthm{chap2_5.prop_2_59_i}
\end{holmath}
\end{prop}
\begin{proof}
By induction on \HOLtm{phi}. Everything except for the diamond case is by unwinding the definitions of \HOLtm{UE M} and ultrafilter. We only give the proof of the diamond case. 

From right to left: Suppose \HOLtm{satis (UE M) u (DIAM phi)}, then \HOLtm{satis (UE M) u' phi} for some \HOLtm{UE_rel M u u'}. By inductive hypothesis, \HOLtm{satis (UE M) u' phi} implies \HOLtm{{w | w IN M.frame.world /\ satis M  w phi\} IN u'}. And then by definition of \HOLtm{UE_rel M}, this implies \HOLtm{(can_see M {w | w IN M.frame.world /\ satis M w phi\}) IN u}. But as observed earlier in this section, we have  \HOLtm{(can_see M {w | w IN M.frame.world /\ satis M w phi\})={w | w IN M.frame.world /\ satis M w (DIAM phi)\}} and hence we are done. 

From left to right: Suppose \HOLtm{{w | w IN M.frame.world /\ satis M w (DIAM phi)\} IN u}, we need to find out an ultrafilter $u'$ such that \HOLtm{UE_rel M u u'} and \HOLtm{satis (UE M) u' phi}. By \texttt{exercise_2_5_5}, \HOLtm{UE_rel M u u'} is equivalent to $s:=$ \HOLtm{{Y | (only_see M Y) IN u /\ Y ⊆ M.frame.world\} ⊆ u'}. We prove \HOLtm{s ∪ {{w |  w IN M.frame.world /\ satis M w phi\}\}} has finite intersection property. Firstly, we check (1) $s$ is closed under binary and hence finite intersection, and (2) The intersection of any element in $s$ with \HOLtm{{w |  w IN M.frame.world /\ satis M w phi\}} is non-empty. 

For (1), if $a,b\in s$, then both \HOLtm{only_see M a} and \HOLtm{only_see M b} are in $u$, and hence their intersection is in $u$. By \texttt{only_see_INTER}, \HOLtm{only_see M a ∩ only_see M b = only_see M (a INTER b)}, hence \HOLtm{a ∩ b IN u}.

For (2), let $Y\in s$, then \HOLtm{(only_see M Y) IN u}, as also \HOLtm{{w | w IN M.frame.world /\ satis M w (DIAM phi)\} IN u}, by closure under intersection for an ultrafilter, \HOLtm{(only_see M Y) ∩ {w | w IN M.frame.world /\ satis M w (DIAM phi)\} <> {\}}.  Consider any element $x$ of it, as \HOLtm{x IN {w | w IN M.frame.world /\ satis M w (DIAM phi)\}}, there exists \HOLtm{y IN M.frame.world} such that \HOLtm{satis M y phi}, as \HOLtm{x IN (only_see M Y)}, we have $y\in Y$. Hence we obtain an element of \HOLtm{Y ∩ {w |  w IN M.frame.world /\ satis M w phi\}}, which shows this set is non-empty. 

Hence by induction on finiteness, the set \HOLtm{s ∪ {{w |  w IN M.frame.world /\ satis M w phi\}\}} has finite intersection property. By \texttt{ultrafilter_theorem_corollary}, there exists an ultrafilter $u'$ such that \HOLtm{s ∪ {{w |  w IN M.frame.world /\ satis M w phi\}\} ⊆ u'}. This is the $u'$ we want: We have \HOLtm{UE_rel M u u'} since \HOLtm{{Y | (only_see M Y) IN u\}}$=s\subseteq u'$. Also as \HOLtm{{w | w IN M.frame.world /\ satis M w phi\} IN u'}, we get \HOLtm{satis (UE M) u' phi} by inductive hypothesis.
\end{proof}
The above proposition leads to a proof of m-saturatedness of ultrafilter extensions.
\begin{prop}[\holref{\texttt{prop_2_61}}{chap2_5}{504}]
The ultrafilter extension of any model is m-saturated. 
\begin{holmath}
  \HOLthm{chap2_5.prop_2_61}
\end{holmath}
\end{prop}
\begin{proof}
Suppose \HOLtm{Σ} is a set of formulas which is finitely satisfiable in the set of successors of a world \HOLtm{u IN (UE M).frame.world}, we need to find a world \HOLtm{u' IN (UE M).frame.world} such that \HOLtm{UE_rel M u u'} and \HOLtm{satis (UE M) u' phi} for all \HOLtm{phi IN Σ}. By \texttt{exercise_2_5_5} and \texttt{prop_2_59_i}, it amounts to find an ultrafilter $u'$ on \HOLtm{M.frame.world} such that \HOLtm{{Y | (only_see M Y) IN u\} ⊆ u'} and \HOLtm{{w | w IN M.frame.world /\ satis M w phi\} IN u'} for all \HOLtm{phi IN Σ}.

Consider the set $\Delta:=$
\begin{holmath}
\HOLtm{{{w | w IN M.frame.world /\ !phi.phi IN s ==> satis M w phi\}| FINITE s /\ s ⊆ Σ\} ∪ {Y | (only_see M Y) IN w /\ Y ⊆ M.frame.world\}}
\end{holmath}
. Similar as in the proof of \texttt{prop_2_59_i}, we check $\Delta$ has the finite intersection property. The only nontrivial thing to check is that for $a$ in the first set of union and $b$ in the second set of union, we have $a\cap b\ne\emptyset$.

Suppose $s \subseteq\Sigma$ is finite, and $b$ is a set of worlds in \HOLtm{M} such that \HOLtm{(only_see M b) IN u}, we show \HOLtm{{w | w IN M.frame.world /\ !phi. phi IN s ==> satis M w phi\} ∩ b <> {\}}. Recall \HOLtm{Σ} is finitely satisfiable in the set of successors of $u$, we have a world $u''$ such that \HOLtm{UE_rel M u u''} and \HOLtm{satis (UE M) u'' phi} for all $\phi \in s$, in other worlds, \HOLtm{{w | w IN M.frame.world /\ satis M w phi\} IN u''} for all $\phi\in s$. Then as $s$ is finite, \HOLtm{{w | w IN M.frame.world /\ !phi.phi IN s ==> satis M w phi\}} is a big intersection of finitely many sets in $u''$, and hence is in $u''$. By \texttt{exercise_2_5_5} again, \HOLtm{UE_rel M u u''} gives \HOLtm{{Y | (only_see M Y) IN u /\ Y ⊆ M.frame.world\} ⊆ u''}, so $b\in u''$ as well. As two elements in $u''$ has nonempty intersection, we are done.

Hence by \texttt{ultrafilter_theorem_corollary}, there exists an ultrafilter $u'$ contains $\Delta$, it is easy to check $u'$ is what we want.
\end{proof}

Finally, as claimed at the begining of this chapter, we arrive at the characterisation of modal equivalence as bisimilarity in the ultrafilter extensions:
\begin{thm}[\holref{\texttt{thm_2_62}}{chap2_5}{579}]
Given two models \HOLtm{M1} and \HOLtm{M2} with \HOLtm{w1 IN M1.frame.world} and \HOLtm{M2.frame.world}, \HOLtm{w1} and \HOLtm{w2} are modal equivalent if and only if the principle filters generated by \HOLtm{w1} in the ultrafilter extension of \HOLtm{M1} and the principle filter generated by \HOLtm{w2} in the ultrafilter extension of \HOLtm{M2} are bisimilar. 
\begin{holmath}
  \HOLthm{chap2_5.thm_2_62}
\end{holmath}
\end{thm}
\begin{proof}Bisimulation implies modal equivalence by \texttt{thm_2_20}. For the reverse direction, if \HOLtm{w1 IN M1.frame.world} and \HOLtm{w2 IN M2.frame.world} are modal equivalent, then \HOLtm{(principle_UF w1 M1.frame.world) IN (UE M1).frame.world} is modal equivalent to \HOLtm{(principle_UF w2 M2.frame.world) IN (UE M2).frame.world} by \texttt{prop_2_59_ii}. As \HOLtm{UE M1} and \HOLtm{UE M2} are m-saturated by \texttt{prop_2_61}, the result follows by \texttt{prop_2_54_DIST_TYPE}.
\end{proof}
\chapter{Two characterizing results}

In last chapter, we presented the definition of `invariant for bisimulation', and mentioned that if we are working with set theory, then we can prove that first order formulas that are invariant for bisimulation are precisely the first order formulas we can obtain by applying standard translation to modal formulas. We translated one direction of the set-theoretic proof of this result there. In the first section of this chapter, we will translate another half of the proof into HOL4, and explain why we cannot get the double implication when working with simple type theory.  In the second section, we translate a proof similar to the characterization of standard translations from set theory, which says a modal formula is \emph{preserved under simulation} if and only if it is \emph{positive existential}. The two new terminologies are to be introduced in the second section of this chapter.

%In this chapter we put everything we have developed so far together. Using the theory we have already constructed, we can characteristic two semantical behaviour by syntactical features. In the first section, we prove that an $\mathcal L_{\tau}^1$ formula is invariant under bisimulations precisely when it is equivalent to a first order formula which is obtained by standard translation. In the second section, we prove that a modal formula is \emph{preserved under simulation} if and only if it is \emph{positive existential}, where the two concepts are to be introduced there. 


%With and use them to give syntactical characterisations of semantical properties `invariant for bisimulation' and `preserved under simulation'. 



%This whole chapter relies highly on first order logic, and we will swap between modal models and first order models very frequently. Hence when we talk about first order models, we restrict our scope to the ones which contains the same amount of information as a modal model. And only talk about first order formulas which makes sense to such models. So when we say `a first order formula' in this chapter, we secretly refer to a first order formula with no function symbols and only have unary predicate symbols and only one binary predicate symbol.

\section{The `modal' fragment of $\mathcal L_{\tau}^1$ formulas}

In the last chapter, we introduce the standard translation and proved that every modal formula is equivalent to a first order formula, in the sense that for any point in any model that satisfies the formula precisely when if we view the model as a first order model, the first order formula corresponds to the modal formula is satisfied. As discussed earlier, any first order formula which is corresponds to a first order formula is an $\mathcal L_{\tau}^1$ formula, but it is clearly not the fact that every $\mathcal L_{\tau}^1$ formula is equivalent to the standard translation of a modal formula. For instance, the formula \HOLtm{fR (fV 1) (fV 2)} is not a standard translation. Here comes a natural question: what are the $\mathcal L_{\tau}^1$-formulas which is equivalent to a standard translation? In last chapter, we have already given a short answer: an $\mathcal L_{\tau}^1$ formulas which is equivalent to a standard translation if and only if it is invariant under bisimulation. Also recall that we have already proved that standard translations are invariant under bisimulation. In this section, we devote to translate the proof of the other direction, saying `any formula which is invariant under bisimulation is equivalent to a standard translation', into HOL4, which uses simple type theory as its foundation. The tools that this proof will use centered on saturated models, which we are introducing now:

Given a first order model \HOLtm{M}, we can expand it by add some new function symbols to it. In HOL4, this operation is easy to define when we are expanding a model \HOLtm{M} with no interesting information on function symbols. Fortunately, we are only interested in such easy case throughout the discussion below, even more, here we are only considering adding finitely many nullary function symbols, which are actually constants. Hence to keep things simple, the definition of expansion of models is taken to be as follows:

\begin{defn}[\holref{Expansion}{lemma2_73}{65}]
In HOL4, \HOLtm{expansion} is defined as a predicate, where the model \HOLtm{M} is the model we start with and \HOLtm{M'} is the resultant model after adding a finite number of constants, each corresponds to an element in \HOLtm{A}, which is a world in \HOLtm{M}.
\begin{holmath}
  \HOLthm[def]{lemma2_73.expansion_def}
\end{holmath}
For the notations: \HOLtm{CARD} is the function that takes a set and gives its cardinality, \HOLtm{count} is a function takes a natural number $m$ and gives the set $\{0,\cdots ,n-1\}$, and \HOLtm{BIJ f A B} means `$f$ is a bijection from $A$ to $B$'. 
\end{defn}

The expanded model has the same domain and same predicate symbols as the unexpanded one, that are only the function symbols that makes them different. Before the expansion, as there is no information contained in \HOLtm{M} about function symbols, any first order term that contains some function symbol does not make sense to \HOLtm{M}, hence \HOLtm{M} cannot be used to interpret any formula with a function symbol. If $A$ has cardinality $m$, where $m$ is a natural number, after the expansion, any term \HOLtm{Fn t []} for $0\le t< m$ makes sense to \HOLtm{M'}, and it evaluated to the element \HOLtm{f t}. Therefore, the formulas which only uses these function symbols can be interpreted in the expanded model. The role of \HOLtm{f} here is to assign each $0\le t < m$ an element of the domain of \HOLtm{M}, where the term \HOLtm{Fn t []} will be evaluated to. 


A set \HOLtm{Σ} of first order formula is called \emph{consistent} with a model \HOLtm{M} if for any finite subset \HOLtm{Σ0} of it, there exists an element in domain of \HOLtm{M} such that all elements of \HOLtm{Σ0} are satisfied, in this case, we write \HOLtm{consistent M Σ}. A set \HOLtm{Γ} of first order formula is called an \emph{type} if there is a variable symbol $x$ such that for each formula in \HOLtm{Σ}, the only free variable that it may contain is $x$, in this case, we write \HOLtm{ftype x Γ} in HOL4. When \HOLtm{ftype x Γ}, we say \HOLtm{Γ} is \emph{realized} in \HOLtm{M} if there is an element in the domain of \HOLtm{M} such that all the elements in \HOLtm{Γ} are satisfied, and write \HOLtm{frealizes M x Γ}. 

%A first order model \HOLtm{M} is called $n$-saturated if for any set \HOLtm{A ⊆ M.frame.world} where \HOLtm{CARD A < n} and for any \HOLtm{M'} and \HOLtm{f} assigning natural numbers to elements in the domain of \HOLtm{M} such that \HOLtm{expansion M A M' f}, \HOLtm{M'} realizes every consistent set \HOLtm{Γ} such that \HOLtm{ftype x Γ}, where $x$ is any variable symbol. A model is countably saturated if it is $n$-saturated for all $n$.



\begin{defn}[\holref{$n$-saturated}{lemma2_73}{77} and \holref{countably saturated}{lemma2_73}{90}]
A first order model \HOLtm{M} is called $n$-saturated if for any set \HOLtm{A ⊆ M.frame.world} where \HOLtm{CARD A < n} and for any \HOLtm{M'} and \HOLtm{f} assigning natural numbers to elements in the domain of \HOLtm{M} such that \HOLtm{expansion M A M' f}, \HOLtm{M'} realizes every consistent set \HOLtm{Γ} such that \HOLtm{ftype x Γ}, where $x$ is any variable symbol. A model is countably saturated if it is $n$-saturated for all $n$.
\begin{holmath}
  \HOLthm[def,Γ/G]{prettyPrinting.ppn_saturated_def}\\[3mm]
  \HOLthm[def]{lemma2_73.countably_saturated_def}
\end{holmath}
\end{defn}

Countably saturated models are interesting for us since for countably saturated models, when we view them as modal models, then bisimulation and modal equivalence coincides on those models. 

\begin{thm}[\holref{\texttt{thm_2_65_corollary}}{chap2_6}{407}]
\begin{holmath}
  \HOLthm{prettyPrinting.ppthm_2_65_corollary}
\end{holmath}
\end{thm}

By \texttt{prop_2_54}, to prove the above, it suffices to prove:
\begin{thm}[\holref{\texttt{thm_2_65}}{chap2_6}{168}]
Countably saturated first-order models are m-saturated when viewing as modal models. 
\begin{holmath}
  \HOLthm{chap2_6.thm_2_65}
\end{holmath}
\end{thm}
\begin{proof}
 Suppose \HOLtm{countably_saturated (mm2folm M)}. Let \HOLtm{a IN M.frame.world} and \HOLtm{Σ} a set of modal formulas which is finitely satisfiable in the set of successors of $a$. We find a successor of $a$ in \HOLtm{M} realising all the formulas in \HOLtm{Σ}. 


Define \HOLtm{Σ' = {fR (Fn 0 []) (fV x)\} UNION {ST x phi | phi IN Σ\}} and 
\begin{holmath}
\HOLtm[alltt,width=90]{M' = <| Dom := (mm2folm M).Dom;
                     Fun := (λn args. if n = 0 ∧ args = [] then w 
                                      else CHOICE (mm2folm M).Dom);
                     Pred := (mm2folm M).Pred |>}
\end{holmath}
, then we can easily check \HOLtm{expansion (mm2folm M) {w\} M' (\n.w)}. We claim \HOLtm{consistent M' Σ'}. Take a finite set \HOLtm{Σ0 ⊆ Σ'}, we should find an element in \HOLtm{M'} where every formula in \HOLtm{Σ0} is satisfied. For each element in \HOLtm{Σ0} which is a standard translation, use \HOLtm{CHOICE} to choose a modal formula $p\in \Sigma$ that is translated to it. Collect the formulas we choose into a set \HOLtm{ps}, then \HOLtm{ps} is a finite subset of \HOLtm{Σ}. Recall we have assumed \HOLtm{Σ} is finitely satisfiable in the set of successors of \HOLtm{a}, hence there exists \HOLtm{b IN M.frame.world} and \HOLtm{M.frame.rel a b} such that \HOLtm{satis M b p} for any \HOLtm{p IN Σ0}. It follows by \texttt{prop_2_47_i} that no matter \HOLtm{fR (Fn 0 []) (fV x)} is in \HOLtm{Σ} or not, we have \HOLtm{Σ0} is satisfied at \HOLtm{b} in \HOLtm{M'}.

This proves \HOLtm{consistent M' Σ'}. Since \HOLtm{(mm2folm M)} is countably saturated, the whole set \HOLtm{Σ'} itself is satisfied in some \HOLtm{b} in \HOLtm{M'}. The fact that \HOLtm{fR (Fn 0 []) (fV x)} holds at $b$ implies $b$ is a successor of $a$ in \HOLtm{M}, and \HOLtm{{ST x phi | phi IN Σ\}} holds at \HOLtm{b} implies that \HOLtm{satis M b phi} for any \HOLtm{phi IN Σ} by \texttt{prop_2_47_i}.
\end{proof}

Knowing the interesting properties of countably saturated models, we now answer the question that where to obtain them. The canonical way to obtain such models involve the usage of ultraproducts, which we will discuss in the following interlude:

\subsection{Interlude III: Countably saturated models via ultraproducts}

Although we are interested in ultraproduct on models, we will begin by introducing the construction of ultraproduct of sets. 
%Suppose $J\ne\emptyset$ and for each $j\in J$, $A_j$ is a non-empty set. The Cartestian product is the set of functions with domain $J$ such that for all $j\in J$, $f(j)\in A_j$. As before, in the definition below, \HOLtm{A} is encoded as a function, and hence for $j\in J$, \HOLtm{A j} is the set $A_j$ indexed by $j$.  

\begin{defn}[\holref{Cartesian product}{ultraproduct}{20}]
 Suppose $J$ is a non-empty set indexing the family $\{A_j\}_{j\in J}$, where each $A_j$ is non-empty. The Cartestian product of the family  $\{A_j\}_{j\in J}$ is the set of functions with domain $J$ such that for all $j\in J$, $f(j)\in A_j$.
\begin{holmath}
  \HOLthm[def,j/i,J/I]{ultraproduct.Cart_prod_def}
\end{holmath}
As before, in the definition below, \HOLtm{A} is encoded as a function, and hence for $j\in J$, \HOLtm{A j} is the set $A_j$ indexed by $j$.  
\end{defn}

%If $U$ is an ultrafilter on $J$, for two functions $f,g$ in the Cartesian product \HOLtm{Cart_prod J A}, we say $f$ and $g$ are $U$-equivalent if the set \HOLtm{{i | i IN I /\ f i = g i\}} where the values of $f$ and $g$ agrees is in $U$. For any ultrafilter $U$ on any set $J$, \HOLtm{Uequiv U J} is an equivalent relation on the Cartestian product of the $A_j$'s. The ultraproduct of $A_j$ modulo $U$ is the set of equivalence classes partitioned by the relation \HOLtm{Uequiv U J A}. The ultraproduct of $A_j$ modulo $U$ is the set of equivalence classes obtained by partitioning \HOLtm{Cart_prod J A} using the relation \HOLtm{Uequiv U J A}. In the definition below, \HOLtm{partition} is a function that takes a relation and a set, and give the set of equivalence classes of the set partitioned by the relation. 
\begin{defn}[\holref{$U$-equivalence}{ultraproduct}{23} and \holref{ultraproduct}{ultraproduct}{43}]
If $U$ is an ultrafilter on $J$, for two functions $f,g$ in the Cartesian product \HOLtm{Cart_prod J A}, we say $f$ and $g$ are $U$-equivalent if the set \HOLtm{{i | i IN I /\ f i = g i\}} where the values of $f$ and $g$ agrees is in $U$. For any ultrafilter $U$ on any set $J$, \HOLtm{Uequiv U J} is an equivalent relation on the Cartestian product of the $A_j$'s. The ultraproduct of $A_j$ modulo $U$ is the set of equivalence classes partitioned by the relation \HOLtm{Uequiv U J A}. The ultraproduct of $A_j$ modulo $U$ is the set of equivalence classes obtained by partitioning \HOLtm{Cart_prod J A} using the relation \HOLtm{Uequiv U J A}.
\begin{holmath}
  \HOLthm[def,J/I,j/i]{ultraproduct.Uequiv_def}\\[3mm]
  \HOLthm[def,J/I]{ultraproduct.ultraproduct_def}
\end{holmath}
Here \HOLtm{partition} is a function that takes a relation and a set, and give the set of equivalence classes of the set partitioned by the relation. 
\end{defn}

In the case where $A_j = A$ for all $j\in J$, the ultraproduct is called ultrapower of $A$ modulo $U$.

We have notions of ultraproduct of both modal and first order models. For modal models: 
\begin{defn}[\holref{Ultraproduct of modal models}{ultraproduct}{109}]
 Given a family \HOLtm{MS} of modal models indexed by $J$ and an ultrafilter $U$ on $J$, where \HOLtm{MS} is a encoded as a function that takes an element of $J$ and gives a model, the ultraproduct model of \HOLtm{MS} modulo $U$ is described as follows:

\begin{itemize}
  \item The world set is the ultraproduct of world sets of \HOLtm{MS} modulo $U$. 

  \item For two equivalence classes $f_U,g_U$ of functions in the ultraproduct, they are related iff there exists $f\in f_U,g\in g_U$, such that \HOLtm{{j IN J | (MS j).frame.rel (f j) (g j)\}} is in $U$.
  \item For a propositional letter $p$ and an equivalence class $f_U$, we have $p$ is satisfied at $f_U$ iff there exists $f\in f_U$ such that \HOLtm{{j | j IN J /\ (f j) IN (MS j).valt p\}} is in $U$.
\end{itemize} 
\begin{holmath}
  \HOLthm[def,J/I,j/i]{ultraproduct.ultraproduct_model_def}
\end{holmath}
Here \HOLtm{models2worlds} is a function that takes a function that assign each index to a model and turn it into a function that assign each index the corresponding world set:
\begin{holmath}
  \HOLthm[def]{ultraproduct.models2worlds_def}
\end{holmath}
\end{defn}


In the definition of relation and valuation of ultraproduct modal model, the occurrence of the existential quantifier is used to describe the existence of representatives of an equivalence class with certain additional property. As we can expect, as \HOLtm{Uequiv U J A} is an equivalence relation for any ultrafilter, the choice of representative does not matter, in the sense that if only one representative satisfies this condition we require, then all the elements in the equivalence class satisfies the condition. Therefore, if we replace all the existential quantifier with universal quantifier in the above definition, the construction is still valid, and will give the same model as the current definition. 


The critical result we will need about ultraproduct on modal models is a modal version of the fundamental theorem of ultraproducts, which is also called \L o\'s's theorem. 
\begin{thm}[\holref{\texttt{Los_modal_thm}}{ultraproduct}{193}]
The modal version of \L o\'s's theorem states that for $U$ a ultrafilter on $J$, and \HOLtm{MS} a family of models, on the ultraproduct of this family of models on $U$, a modal formula is satisfied at a equivalence class $fc$ if and only if there exists a function $f \in fc$ such that the set of elements $j$ in $J$ such that  \HOLtm{satis (MS j) (f j) phi} is in $U$.
\begin{holmath}
  \HOLthm[MS/Ms,j/i]{ultraproduct.Los_modal_thm}
\end{holmath}
\end{thm}
\begin{proof}
  Given an ultrafilter $U$ on $J$ and a family \HOLtm{MS} of models. We proceed by induction on \HOLtm{phi}, the base case for \HOLtm{phi = VAR p} is directly by definition, and the case for \HOLtm{phi = FALSE} is by the fact that the empty set is not in the ultrafilter. The boolean cases are by basic property of ultrafilters. We only spell out the proof for diamond case. The induction hypothesis gives for any equivalence \HOLtm{fc} in the ultraproduct, we have 
\begin{holmath}
\HOLtm{(satis (ultraproduct_model U J MS) fc phi ⇔
             ∃f. f ∈ fc ∧ {j | j ∈ J ∧ satis (MS j) (f j) phi\} ∈ U)}
\end{holmath}
Given a world $fc$ in \HOLtm{(ultraproduct_model U J MS)}, we will prove 
\begin{holmath}
\HOLtm{satis (ultraproduct_model U J MS) fc (◇ phi) ⇔
        ∃f. f ∈ fc ∧ {j | j ∈ J ∧ satis (MS j) (f j) (◇ phi)\} ∈ U}
\end{holmath}
Left to right: Assume the left hand side, then there is an equivalence class $gc$ that is related to \HOLtm{fc} and satisfied \HOLtm{phi}. Suppose the equivalence class $gc$ is represented by a function $g$, and $fc$ is represented by the function $f$. We check the $f$ can be taken as our $f$ as above. By defination of satisfaction, our task is to check the set 
\begin{holmath}
\HOLtm[alltt,width=95]{A={j |
         j ∈ J ∧ 
         ∃v.
             (MS i).frame.rel (f j) v ∧ v ∈ (MS j).frame.world ∧
             satis (MS j) v phi\}} 
\end{holmath}
is in $U$.
By inductive hypothesis, the fact that \HOLtm{phi} is satisfied at $gc$ implies the existence of an element $x$ in \HOLtm{gc} such that \HOLtm{ {j | j IN J /\ satis (MS j) (x j) phi\}} is in $U$, but as \HOLtm{Uequiv} is an equivalence relation, this implies \HOLtm{ {j | j IN J /\ satis (MS j) (g j) phi\}} is in $U$. As we can check: Since $x$ and $g$ lives in the same equivalence class, \HOLtm{{j | j IN J /\ g j = x j\}} is in $U$. As ultrafilters are closed under finite intersection, \HOLtm[alltt,width=90]{{j | j IN J /\ g j = x j\} ∩ {j | j IN J /\ satis (MS j) (x j) phi\}} is in $U$, this is a subset of  \HOLtm{ {j | j IN J /\ satis (MS j) (g j) phi\}}, hence by upward closure, the result follows. As $fc$ and $gc$ is related, there exists representatives $f' \in fc, g' \in gc$ such that \HOLtm{{j | j IN J /\ (MS j).frame.rel (f' j) (g' j)\}} is in $U$. By a same procedure of checking independence of representatives, we can show that the set \HOLtm{{j | j IN J /\ (MS j).frame.rel (f j) (g j)\}} is in $U$. Hence the intersection \HOLtm{{j | j IN J /\ (MS j).frame.rel (f j) (g j)\} ∩ {j | j IN J /\ satis (MS j) (g j) phi\}} is in $U$. As our $A$ is a supset of this set, $A$ is in $U$ as well.

Right to left: Suppose there is an $f\in fc$ such that
\begin{holmath}
 \HOLtm[alltt,width=90]{{j |  j ∈ J ∧
         ∃v.
             (MS j).frame.rel (f j) v ∧ v ∈ (MS j).frame.world ∧
             satis (MS j) v phi\}}
\end{holmath}
 is in $U$, we need to find an equivalence class which is related to $fc$ and satisfies $\phi$, which by definition of relation in ultraproduct model, amounts to find a representative of such an equivalence class. The representative is given by :
\begin{holmath}
\HOLtm[alltt,width=90]{\j. if (?v.
          (MS j).frame.rel (f j) v /\ v IN (MS j).frame.world /\
          satis (MS j) v phi) then CHOICE {v | (MS j).frame.rel (f j) v /\ v IN (Ms j).frame.world /\ satis (MS j) v phi\}
	  else CHOICE (MS j).frame.world}
\end{holmath}
checking this is the correct representative is tedious, but just routine, using representative independence and the property of \HOLtm{CHOICE} function. 

\end{proof}

In the case that we are taking the ultraproduct of a constant family of models with \HOLtm{MS i = M} for all $i\in I$, we get an ultrapower of \HOLtm{M}. Specialsing \texttt{Los_modal_thm} to the case of ultrapowers yields:
\begin{coro}[\holref{\texttt{prop_2_71}}{ultraproduct}{490}]
The map sends a world \HOLtm{w IN M.frame.world} to the equivalence class represents by constant function at $w$ embeds the model \HOLtm{M} to its ultrapower on $U$, with the corresponding points satisfy the same modal formulas. 
\begin{holmath}
  \HOLthm[j/i,MS/Ms]{ultraproduct.prop_2_71}
\end{holmath}
\end{coro}
The construction of ultraproduct of first order models is similar to the construction for modal models, but a bit more complicated, since we will have predicates and functions to deal with. 

\begin{defn}[\holref{Ultraproduct of first order models}{ultraproduct}{551}]
The domain of the ultraproduct of family \HOLtm{MS} of first order models over an ultrafilter $U$ on $J$ is the ultraproduct of their domains over $U$ on $I$. The definition of functions and predicates of the ultraproduct of first order model is given by: 


\begin{itemize}
\item A function with its symbol denoted by natural number $n$ will send a list of equivalence class $lc$ to the equivalence class of a function that sending $i\in I$ to the element \HOLtm{(MS i).Fun n l}, where the $k$-th member of the list $l$ can be any element of the equivalence class that appears as the $k$-th element of $lc$. 

%We can therefore check our function denoted by $n$

%\HOLtm{(FMS i).Fun n (MAP (λfc. CHOICE fc i) fs)}. That is, to see where does $i\in I$ goes to, evaluate each representative in the list $fs$ at $i$, collect them into a list, and use this list as the input of the function denoted by $n$ in the model \HOLtm{FMS i}.

\item A predicate with its symbol denoted by $p$ will hold for a list $zs$ of equivalence classes if an only if $zr$ is a list such that the $k$-th member is a representative of the $k$-th member of $zs$, which is an equivalence class, the set of elements in $J$ such that \HOLtm{(MS j). Pred p zr} is in $U$. 


%iff when we pick representatives in each member of $zs$ and evaluate these representatives at $i$, the predicate $p$ holds in \HOLtm{FMS i} when we evaluate it with the list \HOLtm{(MAP (λfc. CHOICE fc i) zs)} of the outputs. 
\end{itemize}
\begin{holmath}
  \HOLthm[def,J/I,j/i]{ultraproduct.ultraproduct_folmodel_def}
\end{holmath}
Here we fix the representative for each equivalence class $fc$ to be \HOLtm{CHOICE fc}. The function \HOLtm{folmodels2Doms} plays the same role as the function \HOLtm{models2worlds} as before. 
\end{defn}

Recall the discussion in a previous section, the \HOLtm{wffm M} here is just a well-formedness assumption that saying the functions in \HOLtm{M} never sends a list out of the domain of \HOLtm{M}. We will include such an assumption throughout our discussion of semantical behavior of first order ultraproduct models. We firstly ask where are first order terms evaluated to by \HOLtm{termval}. 

%For an ultraproduct model of the family \HOLtm{MS} of first order models, a valuation $\sigma$ assigns each natural number an equivalence class in the ultraproduct of the world sets of the family, for each natural number \HOLtm{n}, pick \HOLtm{CHOICE (σ n)} as the representative of the equivalence class \HOLtm{σ n} assigned to $n$ by $\sigma$, then \HOLtm{CHOICE (σ n)} will be an element in the Cartesian product \HOLtm{Cart_prod J (folmodels2Doms MS)}, which means that for each \HOLtm{j IN J}, we have \HOLtm{((CHOICE (σ n)) j) IN (MS j).Dom}. Hence for each $j\in J$, the function defined on natural numbers that sends $n$ to \HOLtm{((CHOICE (σ n)) j)} is a valuation of the model \HOLtm{MS j}. For a term $t$, it will be evaluated to the equivalence class represented by the function that sends an element $j\in J$ to the element in \HOLtm{MS j} which we get by applying term evaluation on \HOLtm{t} in the model \HOLtm{MS j} using \HOLtm{\n. (CHOICE (σ n)) j} as assignment of free variables, in other words, such a representative function sends $j\in J$ to \HOLtm{termval (MS j) (\n. (CHOICE (σ n)) j) t}.


 %Recall the discussion in a previous section, the \HOLtm{wffm M} here is just a well-formedness assumption that saying the functions in \HOLtm{M} never sends a list out of the domain of \HOLtm{M}. We will include such an assumption throughout our discussion. 


 %A term $t$ will be sent to the equivalence class represented by the function defined as follows: 


%Firstly, consider the function from $J$ defined as for any $j \in J$

%for $j\in J$, the function that assigns a variable symbol $n$ to the representative of \HOLtm{σ n} evaluated at $i$ will be an assignment of variable symbols to elements in \HOLtm{FMS i}, and $i$ is sent to the element in \HOLtm{(FMS i).Dom} we will get by evaluating $t$ in \HOLtm{FMS i} using this assignment of variable symbols.
\begin{thm}[\holref{\texttt{thm_A_19_i}}{ultraproduct}{632}]
For an ultraproduct model of the family \HOLtm{MS} of first order models, a valuation $\sigma$ assigns each natural number an equivalence class in the ultraproduct of the world sets of the family, for each natural number \HOLtm{n}, pick \HOLtm{CHOICE (σ n)} as the representative of the equivalence class \HOLtm{σ n} assigned to $n$ by $\sigma$, then \HOLtm{CHOICE (σ n)} will be an element in the Cartesian product \HOLtm{Cart_prod J (folmodels2Doms MS)}, which means that for each \HOLtm{j IN J}, we have \HOLtm{((CHOICE (σ n)) j) IN (MS j).Dom}. Hence for each $j\in J$, the function defined on natural numbers that sends $n$ to \HOLtm{((CHOICE (σ n)) j)} is a valuation of the model \HOLtm{MS j}. For a term $t$, it will be evaluated to the equivalence class represented by the function that sends an element $j\in J$ to the element in \HOLtm{MS j} which we get by applying term evaluation on \HOLtm{t} in the model \HOLtm{MS j} using \HOLtm{\n. (CHOICE (σ n)) j} as assignment of free variables, in other words, such a representative function sends $j\in J$ to \HOLtm{termval (MS j) (\n. (CHOICE (σ n)) j) t}.
\begin{holmath}
  \HOLthm[J/I,j/i]{prettyPrinting.ppthm_A_19_i}
\end{holmath}
\end{thm}
\begin{proof}
 By complete induction on \HOLtm{term_size t}.
\end{proof}

The next theorem describe the evaluation of first order formulas on ultraproduct models. This theorem, called \L o\'s's theorem, is unarguably  the most basic and famous result about ultraproduct models. It characterize satisfaction of first order formulas on ultraproduct models:


\begin{thm}[\L o\'s's theorem, \holref{\texttt{thm_A_19_ii}}{ultraproduct}{986}]
For the ultraproduct of a family \HOLtm{MS} of first order models over an ultrafilter \HOLtm{U} on $J$, a formula \HOLtm{phi} is satisfied under an valuation \HOLtm{σ} if and only if the set indexing the models \HOLtm{MS j} in the family where \HOLtm{phi} is true under the valuation \HOLtm{(\n. (CHOICE (σ n)) j)} is in the ultrafilter $U$. 
\begin{holmath}
  \HOLthm[J/I,j/i,n/x]{prettyPrinting.ppthm_A_19_ii}
\end{holmath}
\end{thm}

\begin{proof}
 By induction on \HOLtm{phi}. The base case for \HOLtm{fFALSE} comes from the fact that the empty set is not in an ultrafilter. As for the atomic case, after unwinding the definitions, we are asked by HOL4 to prove

% what we only need to do is to check representative independence as follows: We need to prove 
\begin{holmath}
\HOLtm[alltt,width=120,j/i,t/x]{S1 = {i |
            i ∈ J ∧
            (FMS i).Pred n
              (MAP
                 (λx. CHOICE (termval (ultraproduct_folmodel U J FMS) σ x) i)
                 l)\}}
\end{holmath}
 is in $U$ iff
\begin{holmath}
\HOLtm[alltt,width=120,j/i,n/x]{S2 = {i |
            i ∈ J ∧
            (FMS i).Pred n (MAP (termval (FMS i) (λx. CHOICE (σ x) i)) l)\}}
\end{holmath}
 is in $U$.

Let $v_1,v_2$ denote the functions 
\begin{holmath}
\HOLtm{(λt. CHOICE 
                     (termval (ultraproduct_folmodel U J FMS) σ t) j)}
\end{holmath}
and 
\begin{holmath}
\HOLtm{(termval (FMS j) (λn. CHOICE (σ n) j))}
\end{holmath} respectively. 

Consider the set \HOLtm{J0} $:=$ \HOLtm{{j | j IN J /\
                 (MAP v1 l) = (MAP v2 l)\}}
%\begin{holmath}
%\HOL tm[alltt,width=125]{I0 = {j | j IN J /\
               %  (MAP 
                %   (λn. CHOICE 
                %     (termval (ultraproduct_folmodel U J FMS) σ n) j) l) = 
                % (MAP (termval (FMS j) (λn. CHOICE (σ n) j)) l)\}}
%\end{holmath}
, then it is clear that
\HOLtm{I0 ∩ S1 = I0 ∩ S2}. If \HOLtm{I0 IN U}, suppose in addition that \HOLtm{S1} is in $U$, then \HOLtm{S2} is a supset of the set \HOLtm{I0 ∩ S2}, which is in $U$. Similarly, if $I_0\in U$ and $S_2\in U$, then $S_1\in U$ as well. Therefore, it suffices to prove \HOLtm{I0 IN U}.
Obviously, if for each $j\in J$, we have \HOLtm{v1 j = v2 j}, then we have \HOLtm{MAP v1 l = MAP v2 l}. Thus, if $A$ is
\[
\HOLtm[width=125]{BIGINTER 
      {
      {j | j ∈ J ∧ 
          v1 a = v2 a\}
      | MEM a l\}}
\] then \HOLtm{A SUBSET J0}. 

It follows that it suffices to prove $A\in U$. By \texttt{thm_A_19_i}, for each member $a$ of $l$, 
\[
\HOLtm{(termval (ultraproduct_folmodel U J FMS) σ a)}
\] is the equivalence class represents by \HOLtm{(λj. termval (FMS j) (λn. CHOICE (σ n) j) a)}, from there, we can check that $\HOLtm[width=100]{{j | j ∈ J ∧  v1 a = v2 a \}}$ is in $U$ for each member $a$ of $l$. As a list only have finitely many members, it follows that $A$ is in $U$ as the intersection of finitely many elements in $U$.



%the two maps we are interested in agree on each member of \HOLtm{l}, then the resultant list we get will be equal. That gives 
%\begin{holmath}
%\HOL tm[alltt,width=125]{A= BIGINTER 
     % {
      % {i | i ∈ I ∧ 
     %       CHOICE 
     %         (termval (ultraproduct_folmodel U I FMS) σ a) i
     %       = (termval (FMS i) (λx. CHOICE (σ x) i) a)\}
    %   | MEM a l\}} 
%\end{holmath}

%is a subset of \HOLtm{I0}, reduces our task to prove \HOLtm{A} is in $U$. 

%But by \texttt{thm_A_19_i}, for each member $a$ of $l$, \HOLtm{(termval (ultraproduct_folmodel U I FMS) σ a)} is the equivalence class represents by \HOLtm{(λi. termval (FMS i) (λn. CHOICE (σ n) i) a)}. Hence 
%\begin{holmath}
%\HOL tm[alltt,width=100]{{i | i ∈ I ∧  CHOICE (termval (ultraproduct_folmodel U I FMS) σ a) i
 %           = (termval (FMS i) (λx. CHOICE (σ x) i) a)\}}
%\end{holmath}

 %is in $U$ for each $a$. So $A$ is in $U$ as a finite intersection of sets in $U$.

The implication case is trivial from inductive hypothesis. Finally, we prove the case for universal quantifier. 
From left to right, suppose \HOLtm{FALL n phi} is satisfied under a valuation \HOLtm{σ} in the ultraproduct model for \HOLtm{FMS}. We need \HOLtm[alltt,width=90]{{j | j ∈ J ∧ feval (FMS j) (λx. CHOICE (σ x) j) (FALL n phi)\} ∈
                 U}. Suppose not, then as $U$ is an ultrafilter, \HOLtm[alltt,width=90]{B={j | j ∈ J ∧ feval (FMS j) (λx. CHOICE (σ x) j) (fEXISTS n (fNOT phi))\} IN U}. Use choice, define the function $f$ to send $j\in J$ to a chosen point in \HOLtm{(FMS j).Dom} where \HOLtm{phi} is not satisfied. Such a function in HOL looks like:
\begin{holmath}
\HOLtm[alltt,width=90,j/i]{f = \i. if 
                  (∃a. a ∈ (FMS i).Dom ∧
                       ¬feval (FMS i) (λx. CHOICE (σ x) i)⦇n ↦ a⦈ phi) then 
                  (CHOICE {a | a ∈ (FMS i).Dom ∧ 
                               ¬feval (FMS i) (λx. CHOICE (σ x) i)⦇n ↦ a⦈ phi\})
                 else (CHOICE (FMS i).Dom)}
\end{holmath}
.
Then \HOLtm{{j | j IN J /\ 
            ¬feval (FMS j) (λx. CHOICE (σ x) j)⦇n ↦ f j⦈ phi\} = B }, and hence  is in U. Then by the inductive hypothesis, we can show the equivalence class represented by $f$ does not satisfy \HOLtm{phi}, which contradicts our assumption. 

From right to left. It is straightforward to check \HOLtm[j/i]{{i | i ∈ J ∧ feval (FMS i) (λx. CHOICE (σ x) i) (FALL n phi)\}} is a subset of \HOLtm[j/i]{{i | i ∈ J ∧ feval (FMS i) (λx. CHOICE (σ⦇n ↦ a⦈ x) i) phi\}}, for any equivalence class $a$. So the assumption that former one is in $U$ the later one is in $U$, and we are done by the inductive hypothesis. 

\end{proof}

\L o\'s's theorem gives a classical corollary:

\begin{coro}[\holref{\texttt{corollary_A_21}}{ultraproduct}{1556}]
Any first order model \HOLtm{M} is embedded in its ultrapower on any ultrafilter $U$ on $J$ by sending a world to the equivalence class represented by the constant function on that world.
\begin{holmath}
  \HOLthm[J/I,j/i]{prettyPrinting.ppcorollary_A_21}
\end{holmath}
\end{coro}

The above corollary is straightforward to prove once we get the following lemma:

%Although the \L o\'s theorem proves above only gives us result when the representative is fixed using the choice function, in practice, we are able to freely apply the \L o\'s theorem regardless the choice of representatives. This is a consequence of the following result. 

%The way we stated the \L o\'s theorem will looks not such satisfactory, since it seems to restrict us for the choice of representatives, but it is not. We can be very free with our choice of representatives, as indicated in the following result:
\begin{lm}[\holref{\texttt{ultraproduct_rep_independence_lemma}}{ultraproduct}{1471}]
Given a family \HOLtm{MS} of first order models indexed over $J$ and $U$ is an ultrafilter on $J$. Let \HOLtm{σ} be a valuation to the ultraproduct model of \HOLtm{MS} over \HOLtm{U}, then for a first order formula \HOLtm{phi}, if \HOLtm{rv} is a function that assigns each free variable $v$ in \HOLtm{phi} a representative in the equivalence class \HOLtm{σ v}, then for each \HOLtm{j IN J}, \HOLtm{\v. rv v j} will be a valuation. The set of elements $j$s in \HOLtm{J} such that \HOLtm{phi} holds in \HOLtm{MS j} under the valuation \HOLtm{(\v. CHOICE (σ v) j)} is in $U$ if and only if the set of elements $j$s in \HOLtm{J} such that \HOLtm{phi} holds in \HOLtm{MS j} under the valuation \HOLtm{(\v. rv v j)} is in $U$
\begin{holmath}
  \HOLthm[v/x,J/I,j/i]{prettyPrinting.ppultraproduct_rep_independence_lemma}
\end{holmath}
If the index set $J$ is an $\alpha$-set and the world of models in \HOLtm{FMS} are of type $\beta$, then \HOLtm{rv} here is of type $num\to\alpha\to \beta$. 
%For each natural number \HOLtm{v}, \HOLtm{σ v} is an equivalence class. The \HOLtm{rv} here assigns each variable symbol $v$ an element \HOLtm{rv v} in the equivalence class \HOLtm{σv v}. 
\end{lm}
 
%If the world of models in \HOLtm{FMS} are of type $\beta$, then \HOLtm{rv} here is of type $num\to\beta$. For each natural number \HOLtm{v}, \HOLtm{σ v} is an equivalence class. The \HOLtm{rv} here assigns each variable symbol $v$ an element \HOLtm{rv v} in the equivalence class \HOLtm{σv v}. 

 For its proof, it actually amounts to check representative independence, which is of the same flavor of the second base case in the proof of \L o\'s's theorem.

\begin{proof}
(of \texttt{corollary_A_21} using \texttt{ultraproduct_rep_independence_lemma})

By \L o\'s's theorem, assume the left hand side, to prove the right hand side, it suffices to prove 
\begin{holmath}
\HOLtm{ {j |
         j ∈ J ∧
         feval (FMS j)
           (λv. CHOICE {g | Uequiv U J (folmodels2Doms FMS) g (λj. σ v)\} j)
           phi\} ∈ U}
\end{holmath}.
By the lemma above, with \HOLtm{λv. {g | Uequiv U J (folmodels2Doms FMS) g (λj. σ v)\}} plugged into the place of \HOLtm{σ}, it suffices to find an \HOLtm{rv} which assigns each \HOLtm{v IN FV phi} an element of \HOLtm{σ v}, such that \HOLtm{{j | j ∈ J ∧ feval (FMS j) (λv. rv v j) phi\} ∈ U}. Let each \HOLtm{rv v} be the constant function at \HOLtm{σ v}, then \HOLtm{{j | j ∈ J ∧ feval (FMS j) (λv. rv v j) phi\}} is just \HOLtm{{j | j ∈ J ∧ feval (FMS j) σ phi\}}. But also we know that for all $j\in J$, \HOLtm{FMS j = M}, hence the \HOLtm{ {j | j ∈ J ∧ feval (FMS j) σ phi\}} is the whole set $J$, which is in $U$. The other direction is similar. 


\end{proof}

%With the help of \texttt{ultraproduct_rep_independence_lemma}, we can prove a classical corollary of \L o\'s theorem, which says any first order model \HOLtm{M} is embedded in its ultrapower on any ultrafilter $U$ on $J$ by sending a world to the equivalence class represented by the constant function on that world:

%better explanation?

The above `independence of representative' lemma is very helpful.  The lemma above enable us to be free of choice of representatives of equivalence classes in the ultraproduct when applying \L o\'s's theorem. 

%In particular, it gives the following result, which says if we want to find a valuation of a ultraproduct model satisfying a first order formula $\phi$, instead of assigning equivalence classes to natural numbers directly, it suffices to assign representatives. 
% each $v$ a suitable representative functions in the Cartesian product :
\begin{prop}[\holref{\texttt{ultraproduct_suffices_rep}}{ultraproduct}{1643}]
If we want to find a valuation of a ultraproduct model satisfying a first order formula $\phi$, instead of assigning equivalence classes to natural numbers directly, it suffices to assign representatives. 
\begin{holmath}
  \HOLthm[J/I,j/i]{prettyPrinting.ppultraproduct_suffices_rep}
\end{holmath}
\end{prop}

\begin{proof}
Given $U,J,rv,$ \HOLtm{MS}, \HOLtm{phi} satisfying our assumptions, by \L o\'s's theorem, to prove the conclusion, it suffices to prove 
\begin{holmath}
\HOLtm{{j |
         j ∈ J ∧
         feval (FMS j)
           (λv. CHOICE {g | Uequiv U J (folmodels2Doms FMS) g (rv v)\} j) phi\}}
\end{holmath}
is in $U$. With the function \HOLtm{\v. {g | Uequiv U J (folmodels2Doms FMS) g (rv v)\}} plugged in the place of \HOLtm{σ}, the result follows by  \texttt{ultraproduct_rep_independence_lemma}.



\end{proof}


All the construction we done above serves to paving a way to getting a countably saturated model. The remaining task is to prove this lemma: 

O%nce we prove that for any family of non-empty models, their ultraproduct on a countably incomplete ultrafilter is countably saturated, since we have already proved the existence of countably incomplete ultrafilters in interlude II, we will get some countably saturated models to use. Therefore, the remaining task is to prove this lemma: 
\begin{lm}[\holref{\texttt{lemma_2_73}}{lemma2_73}{1085}]
For any family of non-empty models, their ultraproduct on a countably incomplete ultrafilter is countably saturated. 
\begin{holmath}
  \HOLthm[J/I,j/i]{prettyPrinting.pplemma_2_73}
\end{holmath}
\end{lm}
Once the above is proved, as we have already proved the existence of countably incomplete ultrafilters in Interlude II, we will get some countably saturated models to use.

With all the setups about ultraproduct models, we may expect that this will be a consequence of \L o\'s's theorem. But if we take a closer look of the statement, we will find out \L o\'s's theorem cannot be directly applied here. The definition of countably saturated asks us to prove the realisation of a set of first order formulas in an expanded first order model, where the first order model we expand is itself obtained from turning a modal model into a first order model. The obstacles here will become clear when we compare what we want to prove to the statement of \L o\'s's theorem: \L o\'s's theorem tells us the result for an ultraproduct of first order models, and says nothing about expansion. But we are proving a statement for an expanded model obtained from viewing an ultraproduct of modal models as a first order model. However, as we shell see now, it cannot stop us from applying \L o\'s's theorem.%quote the goal?

The first issue is to remove the expansion on the outmost layer. The key observation is that we have an alternative approach to capture the idea of `constants'. Constant are nothing more than forcing some symbols to be sent to some point in a model under any valuation, hence rather then use nullary function symbols, we fixed a set of variable letters, each corresponds to a function symbol, and only consider the valuations that sends these variable letters to fixed certain points. With this idea, we can remove all the constants in a formula, and hence change our scope from an expanded model back to the unexpanded model. Recall when we defined expansion, we only consider adding finitely many constants. Hence in the following discussion, we will only interested in removing finitely many constants as well. To get rid of $n$-function symbols, we need to come up with $n$ fresh variable symbols which have not already appeared in the formula we are looking at to be sent to certain places. The easiest way to ensure that the variable symbols do not clash is to force those $n$-variable symbols to be represented by $0,\cdots, n-1$, and then add $n$ to all the variable symbols which is originally used in a formula. The construction of discarding constants in a formula can be done by a two functions working on first order terms and first order formulas respectively. 
\begin{defn}[Shifting on \holref{terms}{lemma2_73}{349} and \holref{formulas}{lemma2_73}{356}]
\begin{holmath}
  \HOLthm[def]{lemma2_73.shift_term_def}\\[3mm]
  \HOLthm[def,phi/f]{lemma2_73.shift_form_def}
\end{holmath}
\end{defn}
%Here we will need to prove the termination for the function \texttt{shift_term}. The termination relation is given by \HOLtm{measure (term_size o SND)}. %need to talk about termination?
We can talk about the shifting construction only when we are considering an expansion of a model. If we expand a model by throwing in constants corresponds to elements in a set $A$, then the $n$ will be taken as \HOLtm{CARD A}. As an example, if \HOLtm{M'} obtained by expanding \HOLtm{M} by adding one constant corresponds to the point \HOLtm{a IN M.Dom}, then after the expansion, the formulas involves the term \HOLtm{Fn 0 []} makes sense to \HOLtm{M'}. If we do not want to work with expansion, given a formula where the only function symbol that may occur is \HOLtm{(0,0)}, then we can firstly add $1$ to any variable symbol that appear in the formula, and then replace any occurrence of \HOLtm{Fn 0 []} by \HOLtm{fV 0}. The formula \HOLtm{fR (Fn 0 []) (fV 0)} will become \HOLtm{fR (fV 0) (fV 1)}, and the formula \HOLtm{fDISJ (fP p (fV 1)) (fP q (fV 2))} will become \HOLtm{fDISJ (fP p (fV 2)) (fP q (fV 3))}. 


We can check that we get the syntactical result we want: 
%after applying the shifting construction to a formula that only nullary function symbols which corresponds to elements in $A$, there is no function symbol remaining in the resultant formula. Also, if we start with a formula with only free variables in $s$, then a free variable in the resultant formula is either of form \HOLtm{x + (CARD A)} for some $x\in s$, or an element in $\{0,\cdots , ({\sf CARD} \ A - 1)\}$ that is used to capture a constant.
 %the function symbols are removed by applying the shifting construction, and the set of free variables is also under control.
\begin{prop}[\holref{\texttt{shift_form_functions_EMPTY}}{lemma2_73}{444}, \holref{\texttt{shift_FV}}{lemma2_73}{480}]
After applying the shifting construction to a formula that only nullary function symbols which corresponds to elements in $A$, there is no function symbol remaining in the resultant formula. Also, if we start with a formula with only free variables in $s$, then a free variable in the resultant formula is either of form \HOLtm{x + (CARD A)} for some $x\in s$, or an element in $\{0,\cdots , ({\sf CARD} \ A - 1)\}$ that is used to capture a constant.
\begin{holmath}
  \HOLthm{prettyPrinting.ppshift_form_functions_EMPTY}\\[3mm]
  \HOLthm{prettyPrinting.ppshift_FV}
\end{holmath}
\end{prop}
Now if we still want to use an arbitary valuation to evaluate a shifted formula, something may go wrong. Since $0,\cdots,n-1$ in the shifted formula are now designed to be sent to fixed place $f \ 0,\cdots,f \ (n-1)$, it does not make sense to assign these variable symbols to anywhere else. Hence to talk about satisfaction of shifted formula, the first thing is to make sure that the valuation we are considering sends the variables which actually denotes constants to the right place. The job of ensuring a valuation we use to make sense to shifted formulas can be done by shifting the valuation accordingly:
\begin{defn}[\holref{Shifting on valuations}{lemma2_73}{363}]
\begin{holmath}
  \HOLthm[def]{lemma2_73.shift_valuation_def}
\end{holmath}
\end{defn}

Continue with the previous example. Formerly, we can use the valuation \HOLtm{\n.b} where \HOLtm{b IN M.Dom} and \HOLtm{b <> a} to evaluate the formula \HOLtm{fR (Fn 0 []) (fV 1)}. But after the shifting, it does not make sense to use the same valuation to evaluate \HOLtm{fR (fV 0) (fV 1)}. To turn this valuation into a valuation that makes sense to the shifted formula, we need to let $0$ to be sent to the correct place $a$, and let the variable symbol which is formerly sent to $b$ to be also sent to $b$. Formerly, the variable symbol $0$ is sent to $b$, but now the variable which plays the same role as the $0$ after the shifting is the variable symbol $1$, hence we need the $1$ in the shifted formula to be sent to $b$, as we can check, according to our definition, \HOLtm{shift_valuation 1 (\n.b) (\n.a) = \n. if n = 0 then a else b} does the correct thing. 

The shifting construction also gives the desired semantical behavior on first order formulas:

%In the following proposition, we see that if \HOLtm{M'} is a model we get by adding a bunch of constants corresponds to elements in a set $A$ to a model \HOLtm{M}, then for a first order formula \HOLtm{phi} such that the constants appear in \HOLtm{phi} can only be the ones that corresponds to element in $A$, \HOLtm{phi} is satisfied in \HOLtm{M} under valuation \HOLtm{σ} if and only if when we `shift away' all the constants in \HOLtm{phi} and shift the valuation \HOLtm{σ} accordingly, then the resultant formula will be satisfied on \HOLtm{M} under the shifted valuation.


%the satisfaction of a first order formula with constants only corresponds to the functions added to   on is equivalent to the satisfaction
%By `shifting away' function symbols in formulas with function symbols, we can talk get rid of taking about expansions. Recall our aim is to get rid of constants and hence avoid talking about expansion of models, the following proposition proves our construction does a good job:
\begin{prop}[\holref{\texttt{expansion_shift_feval}}{lemma2_73}{382}]
If \HOLtm{M'} is a model we get by adding a bunch of constants corresponds to elements in a set $A$ to a model \HOLtm{M}, then for a first order formula \HOLtm{phi} such that the constants appear in \HOLtm{phi} can only be the ones that corresponds to element in $A$, \HOLtm{phi} is satisfied in \HOLtm{M} under valuation \HOLtm{σ} if and only if when we `shift away' all the constants in \HOLtm{phi} and shift the valuation \HOLtm{σ} accordingly, then the resultant formula will be satisfied on \HOLtm{M} under the shifted valuation.
\begin{holmath}
  \HOLthm{prettyPrinting.ppexpansion_shift_feval}
\end{holmath}
\end{prop}

The shifting construction get us out of the expansion, leaving us a model obtained by converting a ultraproduct modal model to a first model. To apply \L o\'s's theorem on such a model, we prove the ultraproduct construction on modal and first order models are equivalent on `good first order formulas' in the following sense: 

%that if we take the ultraproduct of a family of modal models, if we view the resultant modal ultraproduct model as a first order model, this first order model will satisfies the same $\mathcal L_{\tau}^1$-formulas as the model we obtained by firstly view each modal model in the family as a first model, then take their ultraproduct as first order models. Moreover, for a family of first order models, if we take their first-order ultraproducts of them, the resultant model satisfies the same $\mathcal L_{\tau}^1$-formulas as the model we get by firstly regard this family as a family of modal models, take their ultraproduct as modal models, and then view the resultant ultraproduct modal model as a first order model.

\begin{prop}[\holref{\texttt{ultraproduct_comm_feval}}{lemma2_73}{188}]
Take the ultraproduct of a family of modal models, if we view the resultant modal ultraproduct model as a first order model, this first order model will satisfies the same first order formulas without function symbols as the model we obtained by firstly view each modal model in the family as a first model, then take their ultraproduct as first order models.
\begin{holmath}
  \HOLthm{prettyPrinting.ppultraproduct_comm_feval}
\end{holmath}
\end{prop}
\begin{proof}
By induction on \HOLtm{phi}. 
\end{proof}

 Similarly, we can also prove that for a family of first order models, if we take their first-order ultraproducts of them, the resultant model satisfies the same $\mathcal L_{\tau}^1$-formulas as the model we get by firstly regard this family as a family of modal models, take their ultraproduct as modal models, and then view the resultant ultraproduct modal model as a first order model. This result is not used here for our saturation proof, but using the idea that the satisfaction of a first order formula on only depends on the functions and predicates that appear in the formula, here is a result that is stated not from the aspect of formulas, but from the aspect of models, which is proved to be useful later. 
 

\begin{prop}[\holref{\texttt{ultraproduct_comm_feval'}}{chap2_6}{554}]
For abbreviation, call a first model `nice' if the model only has unary predicates and only one binary predicate denoted by the symbol `0', no higher arity predicate and no function symbol. If we take the ultraproduct of a family of nice models, then a first order formula is satisfied on the ultraproduct model if and only if the formula is satisfied on the model obtained by firstly converting the modal ultraproduct model of the family obtained by converting each model of of the family of nice model we start with into a modal model. 
\begin{holmath}
  \HOLthm{prettyPrinting.ppultraproduct_comm_feval'}
\end{holmath}
\end{prop}

%they are equivalent when we talk about formulas which makes sense to both of them. The capitability results are also witnesses of our success on construction of ultraproduct models. %recall function symbols does not make sense to modal models, so once modal models get involved, we cannot talk about constants anymore except in the case that we expand the model?

%Firstly, if we start with a family of modal models and take their ultraproduct in modal sense, then turn the resultant model into a first order model, then this model satisfies the same well-formed formula as the model we get by firstly turning the family of modal models into a family of first order models, then apply the ultraproduct construction in first order sense.

%Moreover, for a family of first order models, if we take their first-order ultraproducts of them, the resultant model satisfies the same $\mathcal L_{\tau}^1$-formulas as the model we get by firstly regard this family as a family of modal models, take their ultraproduct as modal models, and then view the resultant ultraproduct modal model as a first order model.




%With the two lemmas above and  \texttt{corollary_A_21}, here is another version of the embedding lemma to ultraproduct models which will be:
%\begin{prop}[\texttt{ultraproduct_mm2folm_folm2mm_comm_feval}]
%\begin{holmath}
 % \HOL thm{prettyPrinting.ppultraproduct_mm2folm_folm2mm_comm_feval}
%\end{holmath}
%\end{prop}


According to the discussion above, \texttt{ultraproduct_comm_feval} and \texttt{expansion_shift_feval} reduce our task to the following: 


\begin{lm}[Saturation of ultraproduct model, \holref{\texttt{ultraproduct_sat}}{lemma2_73}{876}]
Take the ultraproduct of a family of well-formed models \HOLtm{MS} on a countably incomplete ultrafilter $U$ on $J$. 
Consider the a set $s$ of $\mathcal L_{\tau}^1$-formulas whose free variables are a subset of $\{x\}\cup C$. 
Let $f$ be a function from $C$ into the domain of \HOLtm{ultraproduct_folmodel U J MS}. 
This $f$ serves to give meaning to the free variables in $C$, treating them as constants. 
Then if for any finite subset $ss$ of $s$, there exists a valuation \HOLtm{σ} that agrees with $f$ on the elements of $C$ (i.e., it sends the `constants' to the correct places), and all the formulas in \HOLtm{ss} are satisfied in \HOLtm{ultraproduct_folmodel U J MS} under \HOLtm{σ}, then there exists a valuation \HOLtm{σ} sending the constants to the correct places that makes every formula in \HOLtm{s} satisfied on \HOLtm{ultraproduct_folmodel U J MS}.
\begin{holmath}
  \HOLthm[J/I,j/i,C/N]{prettyPrinting.ppultraproduct_sat}
\end{holmath}
\end{lm}
\begin{proof}

Given the assumptions, which read as: 
Suppose $s$ is a set of formulas in $\mathcal L_{\tau}^1$, such that for each element $\phi$ in $s$, we only allow one free variable $x$ to occur in $\phi$ other then the ones in $C$ which are actually used to capture constants. In addition, for all finite $ss\subseteq s$, exists a valuation \HOLtm{σ} such that \HOLtm{σ n = f n} for all $n\in C$, and \HOLtm{feval (ultraproduct_folmodel U J FMS) phi} for each \HOLtm{phi IN ss}. If $s$ is finite, there is nothing to prove, so we assume $s$ is infinite. As we are using a countable first order language, any infinite set of first order formula is countable, and hence there exists a bijection \HOLtm{enum} from the set of all natural numbers to the set $s$. Thus it suffices to prove the existence of a valuation \HOLtm{σ} such that \HOLtm{σ} agree with $f$ on $C$ and moreover, \HOLtm{feval (ultraproduct_folmodel U J FMS) (enum n)} for all natural number $n$. The \HOLtm{σ} we want is an assignment of variables to equivalence class. But by \texttt{ultraproduct_suffices_rep} and \L o\'s's theorem, instead of find out this assignment to equivalence classes, it suffices to find out a function \HOLtm{rv} that assigning each natural number a representative of some equivalence class satisfying the following conditions. 

\begin{itemize}
  \item \HOLtm{∀v j. j ∈ J ⇒ rv v j ∈ (FMS j).Dom }
  \item \HOLtm{(∀n. n ∈ C ⇒ {g | Uequiv U J (folmodels2Doms FMS) g (rv n)\} = f n)}
  \item \HOLtm{∀k:num. 
             {j | j ∈ J ∧ feval (FMS j) (λv. rv v j) (conj k)\} ∈ U}
\end{itemize}

The first item says what $rv$ assign to each natural number must be an element in the Cartesion product. And the second item says that the equivalence class assigned to free variables in $C$ has already been fixed by $f$. Both of these two are easy to be satisfied. We devote find and $rv$ satisfying the third condition. 

By \texttt{countbly_incomplete_chain} proved in interlude II, we have a chain \HOLtm{In} where \HOLtm{In n ∈ U} and \HOLtm{In (n + 1) ⊆ In n} for each \HOLtm{n}, which start with \HOLtm{In 0 = J}. Moreover, the intersection of this chain is empty. Let 
\begin{holmath}
\HOLtm{conj = PRIM_REC (True) (\conjn n. fAND conjn (enum n))}
\end{holmath}
, hence \HOLtm{conj 0 = True}, and \HOLtm{conj n} is the conjunction of first order fomulas in $s$ from \HOLtm{enum 0} to \HOLtm{enum (n - 1)}. Define 
\begin{holmath}
\HOLtm[alltt,width=100]{Jn = \n. {j | j IN J /\ 
                 (!σ.
                    (!k. k IN N ==> σ k = CHOICE (f k) j) ==>
                      feval (FMS j) σ (Exists x (conj n)) 
                 )\}}
\end{holmath}

, then what the \HOLtm{Jn} actually give is that \HOLtm{Jn 0 = J}, and for $n>0$, \HOLtm{Jn n} is the subset of \HOLtm{J} indexing the set of models \HOLtm{MS j} with a point in its domain such that the conjunction from \HOLtm{enum 0} to \HOLtm{enum (n - 1)} are satisfied. Therefore, \HOLtm{Jn} is a descending chain. Since any finite subset of $ss$ is satisfied in \HOLtm{(ultraproduct_folmodel U J FMS)} by assumption, \L o\'s's theorem implies that \HOLtm{(Jn n) IN U} for any $n$. Define \HOLtm{Xn = \n. (In n) ∩ (Jn n)}, then \HOLtm{Xn} is a descending chain in $U$ starting with \HOLtm{J} and the intersection of all \HOLtm{Xn n} is the empty set. For such a chain, each element \HOLtm{j IN J} can only belong to finitely many of \HOLtm{Xn}s. Hence there exists a function \HOLtm{Nj} that send an element \HOLtm{j} to smallest set in the chain \HOLtm{Xn} that \HOLtm{j} belongs to. That is, for all \HOLtm{j ∈ J}, we have \HOLtm{j ∈ Xn (Nj j)} and \HOLtm{j ∉ Xn a} for any \HOLtm{a > Nj j}.

The \HOLtm{rv} we are looking for can be taken as:
\begin{holmath}
\HOLtm[alltt,width=100]{(\v j. if (v IN C) 
        then (CHOICE (f v) j)
       else 
       (CHOICE 
               {a | a IN (FMS j).Dom /\
                    feval (FMS j) 
                          (\n. if n IN C then ((CHOICE (f n)) j) 
                               else a)
                    (conj (Nj j))\}))}
\end{holmath}
The first two conditions are immediate to check. It remains to show \HOLtm{{j | j ∈ In 0 ∧ feval (FMS j) (λv. rv v j) (conj k)\} ∈ U} for any $k$. As \HOLtm{Xn k} is in $U$ for any $k$, it suffices to check that for any $k$, we have \HOLtm{Xn k ⊆ {j | j ∈ In 0 ∧ feval (FMS j) (λv. rv v j) (conj k)\} }. For any \HOLtm{j IN (Xn k)}, by definition of the function \HOLtm{Ni}, we have \HOLtm{k <= Nj j}. As \HOLtm{j IN (Xn (Nj j))}, in particular, \HOLtm{j IN (Jn (Ni j))}. From here, we can deduce \HOLtm{feval (FMS j) (λv. rv v j) (conj (Nj j))} using the definition of \HOLtm{rv}. As \HOLtm{conj m} implies \HOLtm{conj n} for \HOLtm{n <= m}, we are done.

\end{proof}

With the help of \texttt{lemma_2_73}, we yield another theorem about `modal equivalence between two worlds implies bisimilarity of the two worlds when embedded in some other models'. 
%Namely, if two worlds \HOLtm{w IN M.frame.world} and \HOLtm{v IN N.frame.world} are modal equivalent, then we can find an ultrafilter $U$ on $J$ such that in ultrapower models of \HOLtm{M} and \HOLtm{N} on $U$ respectively, there is a bisimulation between the worlds corresponds to \HOLtm{w} and \HOLtm{v}. 

\begin{thm}[\holref{\texttt{thm_2_74_half2}}{chap2_6}{439}]
If two worlds \HOLtm{w IN M.frame.world} and \HOLtm{v IN N.frame.world} are modal equivalent, then we can find an ultrafilter $U$ on $J$ such that in ultrapower models of \HOLtm{M} and \HOLtm{N} on $U$ respectively, there is a bisimulation between the worlds corresponds to \HOLtm{w} and \HOLtm{v}. 
\begin{holmath}
  \HOLthm[J/I,j/i]{prettyPrinting.ppthm_2_74_half2}
\end{holmath}
\end{thm}
\begin{proof}
The \HOLtm{U} we require here is any countably incomplete ultrafilter which exists by Interlude II. Then by \texttt{lemma_2_73}, the models \HOLtm{(mm2folm (ultraproduct_model U J (\i.M)))}, \HOLtm{(mm2folm (ultraproduct_model U J (\i.N)))} are countably incomplete. Hence we are done by \texttt{thm_2_65_corollary} and \texttt{prop_2_71}.
\end{proof}

%The last step towards the main theorem is used to pass from infinite set to finite set.

The last ingredient we need for the main theorem we are proving is the compactness theorem of first order logic. The standard statement of compactness theorem says that for a set \HOLtm{Σ} of modal formulas, if for each finite subset \HOLtm{Σ0 ⊆ Σ}, there exists a model such that all the formulas in \HOLtm{Σ0} are satisfied, then there exists a model such that all the formulas in \HOLtm{Σ} are satisfied. This standard version of compactness theorem is formalized in 1998 in HOL4 by John Harrison. The way that Harrison states the compactness theorem looks very different from the style that we are working with. Hence with the help of a corollary proved from Harrison's work by my supervisor, we can connect the work of Harrison with our project and prove a version of compactness theorem for $\mathcal L_{\tau}^1$-formulas, which is no more than a specialization to the standard version of compactness theorem to $\mathcal L_{\tau}^1$-formulas. We will use this version of compactness theorem for our work. The statement looks like:

\begin{thm}[\holref{\texttt{compactness_thm_L1tau}}{chap2_6}{1432}]
If $\alpha$-is an infinite type, then for any set $A$ of $\cal L_{\tau}^1$-formulas, if for any finite subset $ss$ of $A$, there exists an $\alpha$-model \HOLtm{M} and a valuation \HOLtm{σ} such that every formula in $ss$ is satisfied in \HOLtm{M} under \HOLtm{σ}, then there exists a $\alpha$-model \HOLtm{M} and a valuation on \HOLtm{M} such that all the formulas in $A$ are satisfied. 
\begin{holmath}
  \HOLthm[phi/f,phi/ff]{prettyPrinting.ppcompactness_thm_L1tau}
\end{holmath}
\end{thm}

The assumption on infiniteness of the type universe comes from similar reason as why we only have equivalence of diamond formulas implies equivalence of the formulas when taking off the diamonds. Because of this assumption, any statement which requires compactness theorem will be  required to include the assumption on the infiniteness of type universe. 

As a consequence of the compactness theorem, we have:

\begin{coro}[\holref{\texttt{compactness_corollary_L1tau}}{chap2_6}{1482}]
If \HOLtm{Σ} is a set of $\mathcal L_{\tau}^1$ formula such that for any model \HOLtm{M} and valuation \HOLtm{σ}, if \HOLtm{feval M σ phi} for every \HOLtm{phi IN Σ}, then \HOLtm{feval M σ a}, then there exists a finite subset \HOLtm{Σ0} of \HOLtm{Σ} such that once every formula in \HOLtm{Σ0} is satisfied in \HOLtm{M} under a valuation \HOLtm{σ}, then \HOLtm{feval M σ a}. 
\begin{holmath}
  \HOLthm[phi/f]{prettyPrinting.ppcompactness_corollary_L1tau}
\end{holmath}
\end{coro}

\begin{proof}
Under the assumptions, suppose, in order to get a contradiction, that for every finite subset $ss$ of $A$, there exists a model \HOLtm{M} and a valuation \HOLtm{σ} where all the formulas in $ss$ are satisfied by $a$ is not satisfied, then any finite of \HOLtm{ss ∪ {fNOT a\}} is satisfied on some model \HOLtm{M} under some valuation \HOLtm{σ}. As $a$ is an $\mathcal L_{\tau}^1$-formula, so does $\lnot a$. By \texttt{compactness_thm_L1tau}, this implies the whole set \HOLtm{ss ∪ {fNOT a\}} is satisfied on some model under some valuation, contradicts our assumption. 
\end{proof}


Now we have all the ingredient for translating the hard direction of the standard proof of \emph{Van Benthem Characterization Theorem} into HOL4. 

\begin{thm}[Van Benthem Characterization Theorem, hard direction, \holref{\texttt{thm_2_68_half1}}{chap2_6}{1512}]
For an infinite type $\alpha$, if $a$ is a first order formula which is invariant for bisimulation on first order models whose domains are $(num\to\alpha\to bool)$-sets, then there exists a modal formula which is equivalent to $a$ on first order models whose domains are $\alpha$ sets. 
\begin{holmath}
  \HOLthm[showtypes]{prettyPrinting.ppthm_2_68_half1}
\end{holmath}
\end{thm}

\begin{proof}
 Suppose $a$ is a first order formula invariant for bisimulation with only one free variable $x$. Consider the modal consequence of $a$, which is the set of standard translations implied by $a$ on well-formed first order models, defined in the HOL as \begin{holmath}
\HOLtm[alltt,width=110]{MOC = {ST x phi | phi |
          (!M σ. 
            (wffm M /\
            valuation M σ /\ feval M σ a) ==> feval M σ (ST x phi))\}}
\end{holmath}
Our first claim is that it suffices to prove \HOLtm{a} is implies by \HOLtm{MOC}. To see why it suffices, assume it is true, then by \texttt{compactness_corollary_L1tau}, there exists a finite subset of \HOLtm{Σ0} of \HOLtm{MOC} such that once all the formulas in \HOLtm{Σ0} are satisfied, then the $a$ is satisfied. Also by definition of \HOLtm{MOC}, once $a$ is satisfied, every formula in \HOLtm{Σ0} is satisfied. Hence $a$ will be equivalent to the big conjunction of formulas in \HOLtm{Σ0}, which is a standard translation by \texttt{ST_BIGCONJ}. 

Now, fix a well-formed model \HOLtm{M} and suppose \HOLtm{feval M σ varphi} for any \HOLtm{varphi IN MOC}, we prove \HOLtm{feval M σ a}. 

Consider of the set \HOLtm{Tx} of formulas \HOLtm{ST x phi} such that \HOLtm{feval M σ (ST x phi)}. We prove there is a well-formed model \HOLtm{N} with an evaluation \HOLtm{σn} such that for all \HOLtm{varphi IN (Tx ∪ {a\})}, we have \HOLtm{feval N σn varphi}. 
Suppose, in order to get a contradiction, that such a model does not exists, then for any well-formed model, once all the formulas in \HOLtm{Tx} are satisfied, then \HOLtm{a} is not satisfied. Then by compactness, there exists a finite subset of \HOLtm{Tx} implies $\lnot a$. Taking its contrapositive, then \HOLtm{a} implies the negation of the big conjunction \HOLtm{psi} of finitely many elements in \HOLtm{Tx}. By \texttt{ST_BIGCONJ} and \texttt{ST_fNOT}, a negated big conjunction of standard translations is again a standard translation. Hence \HOLtm{fNOT psi} is in \HOLtm{MOC}. Recall we have assumed \HOLtm{feval M σ varphi} for any \HOLtm{varphi IN MOC}, so \HOLtm{feval M σ (fNOT psi)}, but also \HOLtm{feval M σ psi} by definition of \HOLtm{Tx}, we have a contradiction. 

Hence we obtain a model \HOLtm{N} and a valuation \HOLtm{σn} satisfying each formula in \HOLtm{(Tx ∪ {a\})}. Now let \HOLtm{w} denote \HOLtm{σ x} and \HOLtm{v} denote \HOLtm{σn x}, we claim that if we regard both \HOLtm{M} and \HOLtm{N} as modal models, then \HOLtm{w} and \HOLtm{v} are modal equivalent. To prove this, suppose \HOLtm{satis (folm2mm M) w phi} for a modal formula \HOLtm{phi}, then \HOLtm{ST x phi} is in \HOLtm{Tx} by \texttt{prop_2_47_i}, \texttt{L1tau_mm2folm_folm2mm_feval} and the definition of \HOLtm{Tx}, hence \HOLtm{feval N σn (ST x phi)}. By these two propositions again, it follows that that \HOLtm{satis (folm2mm N) v phi}. This proves \HOLtm{!phi. satis (folm2mm M) w phi ==> satis (folm2mm N) v phi}. The other direction is by a symmetry argument. 



%By \texttt{mm2folm_folm2mm_feval}, this is equivalent to \HOLtm{feval (mm2folm (folm2mm N)) σn (ST x phi)}, and if follows from \texttt{prop_2_47_i} that \HOLtm{satis (folm2mm N) v phi}. This proves \HOLtm{!phi. satis (folm2mm M) w phi <=> satis (folm2mm N) v phi}. The other direction is by a symmetry argument. 

If modal equivalence implies bisimularity, then we are done: Suppose modal equivalence implies bisimularity, then as \HOLtm{w IN (folm2mm M).frame.world} and \HOLtm{v IN (folm2mm N).frame.world} are modal equivalent, there exists a bisimulation between them. And as \HOLtm{a} is invariant for bisimulation and is satisfied at \HOLtm{v}, then it is also satisfied at \HOLtm{w}. 

Although it is not always the case that modal equivalence implies bisimularity, we can take a detour with the help of \texttt{thm_2_47_half2}. We can embed the worlds $w,v$ into these models \HOLtm{Mst = (ultraproduct_model U I (λi. folm2mm M))}
,
\HOLtm{Nst = (ultraproduct_model U J (λj. folm2mm N))} as \HOLtm{wst = {fw | Uequiv U J (models2worlds (λj. folm2mm M)) (λj. w) fw\}},
\HOLtm{vst = {fv | Uequiv U J (models2worlds (λj. folm2mm N)) (λj. v) fv\}} respectively, where these two worlds are bisimilar. As $a$ is invariant for bisimulation, $a$ holds as \HOLtm{wst} in \HOLtm{(mm2folm Mst)} iff it holds at \HOLtm{vst} in \HOLtm{(mm2folm Nst)}. We are going to carry the $a$ from the model \HOLtm{N} where $a$ is satisfied at $v$, to the point \HOLtm{vst} in \HOLtm{(mm2folm Nst)}, then to the point \HOLtm{wst} in \HOLtm{(mm2folm Mst)}, and finally to \HOLtm{w} in \HOLtm{M}. 

To carry $a$ around, it suffices to prove \HOLtm{feval M σ a ⇔ feval (mm2folm Mst) (λx. wst) a} and \HOLtm{feval N σn a ⇔ feval (mm2folm Nst) (λx. vst) a} under our assumptions by hand. These two equivalence are of the same pattern, hence we prove it as a lemma:

\begin{holmath}
  \HOLthm[J/I,j/i]{chap2_6.L1tau_ultraproduct_mm2folm_folm2mm_comm_feval}
\end{holmath}

The lemma is proved by carrying $a$ around using \texttt{ultraproduct_comm_feval}, \texttt{L1tau_mm2folm_folm2mm_comm_feval} and \texttt{ultraproduct_comm_feval'}. Hence we are done. 

\end{proof}

Now we have formalized both directions of the Van Benthem Characterization theorem. A reader may expect we can put them together to get a double implication. However, as already mentioned in last chapter, we cannot get an `if an only if' result. To see the reason, note that the statement we have just proved says that if \HOLtm{phi} is invariant under bisimulation for models with type $(num\to \alpha)\to bool$, then we can conclude $\phi$ is equivalent to a standard translation on model of type $\alpha$. However, if we want to prove the converse of the above statement, we need to start with the assumption that $\phi$ is equivalent to a standard translation on models of type $\alpha$, and prove that $\phi$ is invariant for bisimulation for models of type $(num \to \alpha) \to bool$. But according to 
\texttt{thm_2_68_half2'}, we can only conclude $\phi$ is invariant for bisimulation for models of type $\alpha$. 

We get into this situation because the statements we have proved for both directions are not a precise translation from their set-theoretic statement. Consider the easy direction, its set-theoretic statement is that if $\phi$ is equivalent to a standard translation on models of any type, then it will be invariant for bisimulation on models of any type, where as in our statement `if $\phi$ is equivalent to a standard translation on models of type $\alpha$, then it is invariant for models of type $\alpha$', both the assumption and the conclusion are weakened. We cannot encode the original statement into HOL4, since we cannot quantify over types and refer to all the types to state `invariant for bisimulation for models of all types' and `equivalent to a standard translation on models of all types', just as the problem we encountered when defining \HOLtm{equiv0}. If we can quantify over types, that is, suppose we can state the goal `$\phi$ is invariant for bisimulation on models of any type if and only if $\phi$ is equivalent to a standard translation on models of any type', then we can prove it using the same proof we have written out. For the easy direction, the assumption is that $\phi$ is equivalent to a standard translation on models of every type, and we want to conclude that $\phi$ is invariant for bisimulation for models of type $\alpha$. But under assumption,  $\phi$ is equivalent to a standard translation on models of type $\alpha$ where $\alpha$ is an arbitrary type, so we prove the result by \texttt{thm_2_68_half2'}. Conversely, for the other direction, the assumption is that `$\phi$ is invariant for bisimulation on models of every type', and the goal is to prove $\phi$ is invariant on models of type $\alpha$ where $\alpha$ is an arbitrary type. By assumption, $\phi$ is invariant for bisimulation on models of type $(num\to \alpha)\to bool$, and the result follows from \texttt{thm_2_68_half1}. 

The fact that the two directions of implication does not yield an `if and only if' statement is an evident to the restriction of  simple type theory.



\section{Characterizing formulas which are preserved under simulations}

In last section, we proved that standard translations are exactly $\mathcal L_{\tau}^1$-formulas which are invariant for bisimulations. There exists a concept of `half of a bisimulation', which is called \emph{simulation}. Accordingly, the $\mathcal L_{\tau}^1$-formulas which are \emph{preserved under simulation} are interesting. We have set-theoretic proof that these formulas can also be characterized using their syntax. The aim of this section is to translate this proof into simple type theory. For precisely the same reason as in the last section, after we translate the proof of implications in both direction, they cannot be unified into a double implication. Nevertheless, we will spell out our formalization of proofs for those two directions separately. 

 % We present this characterization in this section. 

As we expect, the clauses defining  simulation is `half of' the clauses defining bisimulation. Recall for two worlds \HOLtm{w IN M.frame.world}, \HOLtm{w' IN M'.frame.world}, a bisimulation between \HOLtm{w} and \HOLtm{v} is a relation $Z$ between worlds in \HOLtm{M} and worlds in \HOLtm{M'} that relating $w$ and $v$, such that $w$ and $w'$ satisfies the same propositional letters, and we can make a transaction from $w$ to $v$ in \HOLtm{M} if and only if we can make a transaction from $w'$ to some $v'$ in \HOLtm{M'}, where $v$ and $v'$ are related by $Z$. After replacing `if and only if' in above clauses with one-direction implication, we will get the definition of simulation.

% A simulation $Z$ between two worlds \HOLtm{w IN M.frame.world} and \HOLtm{w' IN M'.frame.world} is a relation between worlds in \HOLtm{M} and \HOLtm{M'} relating $w$ and $w'$, such that each propositional letter which is satisfied at $w$ is also satisfied at $w'$, and if there is a world $v$ in \HOLtm{M} such that \HOLtm{M.frame.rel w v}, then there exists a world \HOLtm{v'} in \HOLtm{M'} such that \HOLtm{M'.frame.rel w' v'}, and moreover, $v$ and $v'$ are related by $Z$. Similar as what we did for defining bisimulation, we define `simulation' as a predicate such that \HOLtm{sim Z M M'} reads `$Z$ is a simulation between models \HOLtm{M} and \HOLtm{M'}'. 

\begin{defn}[\holref{Simulation}{chap2_7}{32}]
A simulation $Z$ between two worlds \HOLtm{w IN M.frame.world} and \HOLtm{w' IN M'.frame.world} is a relation between worlds in \HOLtm{M} and \HOLtm{M'} relating $w$ and $w'$, such that each propositional letter which is satisfied at $w$ is also satisfied at $w'$, and if there is a world $v$ in \HOLtm{M} such that \HOLtm{M.frame.rel w v}, then there exists a world \HOLtm{v'} in \HOLtm{M'} such that \HOLtm{M'.frame.rel w' v'}, and moreover, $v$ and $v'$ are related by $Z$. Similar as what we did for defining bisimulation. We define `simulation' as a predicate such that \HOLtm{sim Z M M'} reads `$Z$ is a simulation between models \HOLtm{M} and \HOLtm{M'}'. 
\begin{holmath}
  \HOLthm[def]{chap2_7.sim_def}
\end{holmath}
\end{defn}

 The concept which corresponds to `invariant for bisimulation' is `preserved under simulation'. In contrast to that of `invariant for bisimulation', `preserved under simulation' is a concept about modal formula. 
%A modal formula \HOLtm{phi} is preserved under simulation if once we have \HOLtm{w IN M.frame.world} and \HOLtm{w' IN M'.frame.world} with a simulation relating $w$ to $w'$, then if \HOLtm{phi} is satisfied at $w$, then it is also satisfied at $w'$. The predicate \HOLtm{preserved_under_sim} takes type parameters, by exactly the same reason as discussed when we define \HOLtm{invar4bisim}. 

\begin{defn}[\holref{Preserved under simulation}{chap2_7}{38}]
A modal formula \HOLtm{phi} is preserved under simulation if once we have \HOLtm{w IN M.frame.world} and \HOLtm{w' IN M'.frame.world} with a simulation relating $w$ to $w'$, then if \HOLtm{phi} is satisfied at $w$, then it is also satisfied at $w'$.
\begin{holmath}
  \HOLthm[def]{prettyPrinting.pppreserved_under_sim_def}
\end{holmath}
The predicate \HOLtm{preserved_under_sim} takes type parameters, by exactly the same reason as discussed when we define \HOLtm{invar4bisim}. 
\end{defn}

The aim of the rest of the section is to characterise formulas preserved under bisimulation as \emph{positively existential formulas}. A positive existential formula is a modal formula which does not contain `negative' connectives. In other words, a modal formula is positive existential if and only if  either it is $\top$ or $\bot$, or is built up using only contains positive connectives, namely `$\land$',`$\lor$' or `$\Diamond$'. Its definition is formalised as an inductive relation with rules:
%The formulas `$\bot$' and `$\top$' are positive existential, a propositional letter standing alone is positive existential, if $f_1$ and $f_2$ are both positive existential, then both their conjunction and their disjunction are positive existential, and finally, adding a diamond before a positive existential formula gives a positive existential formula. These rules are given below. 

\begin{defn}[\holref{Rules of positive existential formulas}{chap2_7}{44}]
 The formulas `$\bot$' and `$\top$' are positive existential, a propositional letter standing alone is positive existential, if $f_1$ and $f_2$ are both positive existential, then both their conjunction and their disjunction are positive existential, and finally, adding a diamond before a positive existential formula gives a positive existential formula.
\[
\begin{array}{c}
  \HOLthm[rule,conj1]{chap2_7.PE_rules} \ \ \ \ \ 
  \HOLthm[rule,conj2,width=30]{chap2_7.PE_rules} \ \ \ \ \ 
  \HOLthm[rule,conj3,width=20]{chap2_7.PE_rules} \ \ \ \ \
  \HOLthm[rule,conj4,width=80]{chap2_7.PE_rules} \ \ \ \ \ 
  \HOLthm[rule,conj5,width=80]{chap2_7.PE_rules} \ \ \ \ \ 
  \HOLthm[rule,conj6,width=80]{chap2_7.PE_rules}
\end{array}
\]
\end{defn}
Any finite conjunction or disjunction of positive existential formulas is again a positive existential formula. Again, instead of explicitly define big conjunction and big disjunction, we use the following propositions to captures this idea:
\begin{prop}[\holref{\texttt{PE_BIGCONJ}}{chap2_7}{311}, \holref{\texttt{PE_BIGDISJ}}{chap2_7}{328}]
\begin{holmath}
  \HOLthm[phi/f,psi/ff]{prettyPrinting.ppPE_BIGCONJ}\\[3mm]
 \HOLthm[phi/f,psi/ff]{prettyPrinting.ppPE_BIGDISJ}
\end{holmath}
\end{prop}

\begin{proof}
By induction on finiteness of $ss$. 
\end{proof}
 

We can immediately prove by rule induction on positive existential formulas that any positive existential formula is preserved under simulation, but the converse only holds for `good models'. In a previous section, we introduced the concept of m-saturated models, and we have already seen that they are `good' models, which gives equivalence between modal equivalence and bisimulation. It turns out that m-saturated models does not only give arise to nice property about bisimulations, but also work well for simulations. 

\begin{prop}[\holref{\texttt{exercise_2_7_1}}{chap2_7}{364}]
 If \HOLtm{w IN M.frame.world} and \HOLtm{w' IN M.frame.world} lives in m-saturated models \HOLtm{M} and \HOLtm{M'}. Then if for any positive existential formula $\phi$, the satisfaction of $\phi$ at $w$ implies the satisfaction of $\phi$ at $w'$, then there exists a simulation relation between \HOLtm{M} and \HOLtm{M'} which relates $w$ to $w'$.  
\begin{holmath}
  \HOLthm{chap2_7.exercise_2_7_1}
\end{holmath}
\end{prop}
\begin{proof}


   Under the assumptions, \HOLtm{\w1 w2. (!phi. PE phi ==> satis M w1 phi ==> satis M' w2 phi)} gives a simulation relation. Checking it is indeed a simulation is completely analogue to the proof of \texttt{prop_2_54}.
\end{proof}

%Although we have give the definition as allow \HOLtm{M} and \HOLtm{N} to be of distinct type. For the same reason that we only prove the characterisation for models of the same type, we only consider \HOLtm{M} and \HOLtm{N} to be of the same type in our main theorem. explain in the begining of chapter?



As the last theorem that is proved in the project, we prove the hard direction of the theorem that says modal formulas which are preserved under simulations are exactly those one which are equivalent to a positive existential formula. This proof will use the similar idea as the characterization theorem proved in the last section. But this time, since this time we are working within a modal language instead of first order language, we only need to work with ultrafilter extensions rather than ultrapowers. This proof also use compactness theorem, but here we just need the modal version of compactness theorem, stated as:


\begin{thm}[\holref{Compactness of modal logic}{chap2_7}{206}]
If $\alpha$ is an infinite type, then given a set $s$ of $num$-modal formulas, if for any finite subset $ss$ of $s$, there exist a modal model \HOLtm{M} with $\alpha$-world set and a world \HOLtm{w IN M.frame.world} such that \HOLtm{satis M w phi} for every \HOLtm{phi IN ss}, then there exists a model with $\alpha$-world set and a world in \HOLtm{M} which satisfies all the modal formulas in $s$. 
\begin{holmath}
  \HOLthm[phi/f]{chap2_7.modal_compactness_thm}
\end{holmath}
We only prove the compactness of $num$-modal formulas since we need to appeal to standard translation to prove it, and standard translation is only defined on $num$-modal formulas. 
\end{thm}
\begin{proof}
Under the assumptions, let \HOLtm[phi/f]{A = {ST x f | f IN s\}}. By \texttt{prop_2_24_i}, each finite subset of \HOLtm{A} is realised by some first order model. Hence \HOLtm{A} is realised by a first order model \HOLtm{M}. By \texttt{prop_2_47_i'}, \HOLtm{folm2mm M} realises all the modal formulas in $s$.

\end{proof}

As in the first order case, the modal version of compactness theorem has a similar corollary:

\begin{coro}[\holref{\texttt{modal_compactness_corollary}}{chap2_7}{277}]
For $\alpha$ is an infinite type, given a modal formula $a$ and a set $s$ of $num$-modal formulas, if for any modal model \HOLtm{M} with $\alpha$-world set, any world \HOLtm{w} which satisfies all the formulas in $s$ will also satisfy $a$, then there exists a finite subset of $s$ such that once a world $w$ in a model \HOLtm{M} with $\alpha$-world set, if every formula in $ss$ is satisfied at $w$, then $a$ is satisfied at $w$.
\begin{holmath}
  \HOLthm[phi/f]{chap2_7.modal_compactness_corollary}
\end{holmath}
\end{coro}

\begin{proof}
 Under the assumptions, suppose  such an $ss$ does not exists, then any finite subset of \HOLtm{ss ∪ {a\}} is satisfied by a modal model, and hence by modal compactness, \HOLtm{ss ∪ {a\}} is satisfied by some world \HOLtm{w IN M.frame.world} for some \HOLtm{M}. Hence both $a$ and $\lnot a$ are satisfied at $w$, contradiction.
\end{proof}


As we can see from their statements, the usage of compactness theorem requires an assumption on infiniteness of the type universe, so we need to include such an assumption in our main theorem below. It is possible to prove the result if the two types taken by \HOLtm{preserved_under_sim} are different, but it requires much more effort just to get the types working correctly at each step of the proof. Hence to keep things simple, we only consider simulations between models of the same type here. 


 %if possible, talk more about this difference
\begin{thm}[\holref{\texttt{thm_2_78_half2}}{chap2_7}{399}]
If $\beta$ is an infinite type. Then for any $num$-modal formula $\phi$, if $\phi$ is preserved under simulation on models with $(\beta\to bool)\to bool$ world sets, then there exists a positive existential $num$-modal formula which is equivalent to $\phi$ on models with $\beta$-world sets. 
\begin{holmath}
  \HOLthm[showtypes,varphi/phi0]{prettyPrinting.ppthm_2_78_half2}
\end{holmath}
\end{thm}
The statement may looks awkward because the assumption is about preservsion under simulation for models of type $(\beta\to bool)\to bool$, but the conclusion is about equivalent to a formula on models of type $\beta$. This is because of our detour through ultrafilter extensions, which embeds a model with $\beta$-worlds into a model with $(\beta\to bool)\to bool$-worlds. It means that for the usual language statement, although the hypothesis is that $\phi$ is preserved under simulation for any types, what we actually require in the proof is only the fact that the formula is preserved under simulation for a certain type.
\begin{proof}
  Suppose $\phi$ is preserved under simulation. Consider the set of positive existential formulas which are implied by $\phi$, defined as \HOLtm[alltt,width=100]{PEC = {psi | PE psi /\ 
                          (!M w:β. w IN M.frame.world ==>
                               satis M w phi ==> satis M w psi)\}} in HOL4.
By \texttt{modal_compactness_corollary}, if we can prove for any model \HOLtm{M} and \HOLtm{w IN M.frame.world}, \HOLtm{satis M w psi} for all \HOLtm{psi IN PEC} implies \HOLtm{satis M w phi}, then there exists a finite subset $S$ of \HOLtm{PEC} that entails $\phi$. This will prove $\phi$ is equivalent to the conjunction of all the formulas in $S$, which is again a positive existential formula.

Therefore, our task is to prove the entailment from \HOLtm{PEC} to $\phi$. Suppose \HOLtm{satis M w psi} for all \HOLtm{psi IN PEC} , we prove \HOLtm{satis M w phi}. Define \HOLtm{Γ={NOT psi | PE psi /\ satis M w (NOT psi)\}}. We claim that there exists a model with a world that satisfies the set \HOLtm{Γ ∪ {phi\}}. By \texttt{modal_compactness_thm}, it suffices to prove each finite subset of \HOLtm{Γ ∪ {phi\}} is satisfied by some model. Suppose there exists a finite subset of \HOLtm{Γ ∪ {phi\}} which cannot be satisfied by any model, then there exists $\lnot\psi_0,\cdots,\lnot\psi_n\in \Gamma$ such that for any model \HOLtm{N} and any world $v$ of it, if \HOLtm{satis N v phi}, then there exists some $0\le i\le n$ such that \HOLtm{satis N v} $\psi_i$. By \texttt{PE_BIGDISJ}, as all these $\psi$'s are positive existential, there exists a positive existential formula $\psi$ which is satisfied precisely when there exists some $\psi_i$ which is satisfied. Hence \HOLtm{psi IN PEC} for such a $\psi$. As \HOLtm{M} entails \HOLtm{PEC}, we have \HOLtm{satis M w psi}, and hence \HOLtm{satis M w} $\psi_i$ for some $i$ by definition of the $\psi$. But on other hand, \HOLtm{satis M w} $\lnot \phi_i$ for any $\psi_i$ by definition of \HOLtm{Γ}, this is a contradiction. 

Hence we obtain a model \HOLtm{N} realising \HOLtm{Γ ∪ {phi\}} at point $v$. For any positive existential formula $\psi$ such that \HOLtm{¬satis M w psi}, we have \HOLtm{NOT psi IN Γ}, so \HOLtm{satis N v (NOT psi)}. Hence for any positive existential $\psi$, if \HOLtm{satis N v psi}, then \HOLtm{satis M w psi}. We migrant this implication onto ultrafilter extensions: Now take the ultrafilter extension of \HOLtm{M} and \HOLtm{N} respectively. By \texttt{prop_2_59_ii}, for any positive existential $\psi$, \HOLtm{satis (UE N) (principle_UF v N.frame.world) psi} implies \HOLtm{satis N v psi}, by the discussion above, it implies \HOLtm{satis M w phi}, and hence implies \HOLtm{satis (UE M) (principle_UF w M.frame.world) psi} by \texttt{prop_2_59_ii} again. As \HOLtm{(UE M)} and \HOLtm{UE N} are m-saturated by \texttt{prop_2_61}, by \texttt{exercise_2_7_1}, we have a simulation relating \HOLtm{(principle_UF v N.frame.world)} to \HOLtm{(principle_UF w M.frame.world)}. 

As \HOLtm{satis N v phi}, \texttt{prop_2_59_ii} gives \HOLtm{satis (UE N) (principle_UF v N.frame.world) phi}, as $\phi$ is preserved under simulation, we have 
\HOLtm{satis (UE M) (principle_UF w M.frame.world) phi}. Again by  \texttt{prop_2_59_ii} , it implies \HOLtm{satis M w phi}. This completes the proof.
\end{proof}
\chapter{Conclusion}

\section{What we have done}

\begin{itemize}
\item Our entire project aim to formalize the theorems proved in the textbook `Modal Logic' by Blackburn et al. By now, every theorem proved in the book up to section 2.7 that can be captured by the basic modal language and the HOL4 are formalised. We take the proofs of those theorems from the textbook, and our definitions, statements and proofs are taken to be as close as possible to the original version of them appear in the book. 

%have stated the definiyi and translated


%And the proofs are taken as in the book. For the proofs which are omitted or left as exercise, we worked out the exercise and mechanised it in the HOL. And we fill the omitted details. In particular, we give a fully formalised proof of proposition 2.29, which is claimed to be obvious by the textbook.

%Due to the type issue, we cannot talk about class of models that `closed under ultraproduct', so cannot formalise theorem 2.75 and 2.76.
%Due to the fact that we restricted to the basic modal language, we cannot talk about propositional dynamic logic(PDL) and hence cannot prove theorem 2.84 in the book characterising formulas which are safe under bisimulation as PDL formulas in special pattern.


\item There are some results which are only used but not proved in the textbook. To be safe when using them, we formalize them all. The three most significant things which we filled in are proved in the thesis as the three interludes. \\


(1) The first interlude is about boolean combination and disjunction normal form. Use the idea there, we can produce a proof of `any boolean combination of propositional/first-order formulas' is equivalent to a disjunction normal form. \\
(2) The second interlude is about formalization of the theory of ultrafilters in set theory. We formalized the proof of ultrafilter theorem there.

(3) The third interlude is about formalization of the theory of ultraproducts. We proved the \L o\'s's theorem, which is also called `the fundamental theorem of ultraproduct', and the saturation property of ultraproduct models. This proof can be easily upgrade to a proof of compactness property of first order logic, and hence give an alternative to John Harrison's proof of compactness of first logic, given in 1998. This interlude only relies on John Harrison's previous work on first order logic, translated in HOL4. This piece of work can be taken as a part of first order logic done in HOL4. 

%The Interludes II can be taken as independent with our theory of modal logic, so does Interlude III which only relies on John Harrison's work on first order logic. These two pieces can be taken as a ground to do more work about ultrafilters, ultraproducts, and their relation to model theory.

%Interlude I does rely on our construction of modal formula, but it is enlightening and with mere effort one can use the same idea to prove any propositional formula is equivalent to a disjunction normal form, which is a `common sense' that we cannot find a proof anywhere online. 

\item We have yield by-products which can be put into the main library of HOL4.

(1) Initially, before we encounter the ultrafilters, we use natural numbers to encode worlds of any models. Hence we need to use natural numbers to represent lists of natural numbers. In order to be able to do this, we developed \texttt{nlistTheory}, which is eventually not used because we cannot restrict to countable world set anymore since ultrafiler models can have uncountable world set. But the \texttt{nlistTheory} is generally applicable. 


(2) For the proofs of Interlude I, which uses equivalence classes, we proved some theorems about partitioning a set using equivalence relations. This is the file \texttt{equiv_on_partitionTheory}. 
\end{itemize}

\section{Choices we made}

\begin{itemize}
\item Our entire formalization is only about one modal language, namely the basic modal language. In general, we allow more than one modal operator in a modal language and allow them to correspond to relations of any arity. We made this choice because of limitation of time, and the fact that the proofs for the basic modal language can be easily generalized to any modal language if we really take time to do it. 

\item For the formalization of theorem 2.68 and 2.78, the proof will be the similar idea if we replace \HOLtm{invar4bisim x (:α) (:α)} with  \HOLtm{invar4bisim x (:α) (:β)}, and replace \HOLtm{preserved_under_sim (:α) (:α)} with \HOLtm{preserved_under_sim (:α) (:β)}, for $\beta$ an arbitrary type. But the procedure of instantiate types to theorems we need to use will be tedious, so we choose not to bother with different types. 

\item We only have defined standard translation of modal formulas using natural number as propositional letter. This is because of the fact that since propositional formula is translated to unary predicate symbol under the standard translation, the only natural thing to do is to translate an $\alpha$-modal formula to a first order formula using predicate symbols of type $\alpha$, but the existing theory of first order logic use only  natural numbers to denote predicate symbols. 

\end{itemize}

\section{Problems we met}

All the problem we met in the project are due to the lack of expressiveness of simple type theory. 

\begin{itemize}

\item There are several problems which are consequences of the fact that we cannot quantify over types in simple type theory. \\
    (1) Some definitions must take types as its parameter, namely definition of \HOLtm{equiv0} \HOLtm{fequiv}, \HOLtm{invar4bisim} and \HOLtm{preserved_under_sim}. \\
   (2) We cannot refer to the collection, more precisely, the class, of all models at once. Because of this, we cannot unify the implications of two direction into a double implication for theorem 2.68 and 2.78. We have explained in detail about this issue in last section. 
   \\
 (3) Sometimes we need assumption on the type we are talking about when stating a theorem. For instance, we require the type universe of $\alpha$ to be infinite to prove `\HOLtm{equiv0 (:α) (DIAM phi1) (DIAM phi2) ==> equiv0 (:α) phi1 phi2}'. If we are allowed to quantify over types, and define equivalence of modal formulas \HOLtm{phi1} and \HOLtm{phi2} to be `for every model \HOLtm{M} of any arbitrary type and \HOLtm{w IN M.frame.world}, we have \HOLtm{satis M w psi1 <=> satis M w psi2}'. Then if \HOLtm{DIAM phi1} and \HOLtm{DIAM phi2} are equivalent under this notion, in particular, for any model \HOLtm{M} with its underlying set of infinite type, we require \HOLtm{satis M w (DIAM phi1) <=> satis M w (DIAM phi2)} for any \HOLtm{w IN M.frame.world}, and hence we can use the proof as in \texttt{equiv0_DIAM} to prove \HOLtm{phi1} and \HOLtm{phi2} must be equivalent.

\item In simple type theory, the domain and codomain is not an intrinsic property of a function. We do not have a notion of `the type of functions from set $A$ to set $B$'. This makes us require well-formedness assumption everywhere. For instance, to make sure that the interpretation of function symbols defined on a first order model makes sense, we need to add the assumption that `a function on the model does not send anything out of the domain of the model' once we are  talking about a first order model. That is why we need the notion of \HOLtm{wffm}. Similarly, that is why we need the notation of \HOLtm{valuation}. 

% For the same reason, once we are considering assign variable symbols in a first order formula to elements in the domain of a model


\end{itemize}


\section{Future work}

\begin{itemize}
\item Although some theorems (theorem 2.75 and 2.76) in the `decidability' section in chapter 2 cannot be directly stated in HOL4, it is still possible to capture the ideas of those proofs and prove some weakened version in HOL4. A possible further project is to capture those ideas and to work out which result can we prove in HOL4 using the idea of those proofs. 

\item Using the basics we have already developed, we can continue formalizing theorems in the further sections of the same textbook. 

\item There are many result about ultrafilters and ultraproducts proved in Interlude II and Interlude III which can be taken to be independent to our formalization of modal logic. They can serve to formalize more theorems about ultrafilters and ultraproducts later. In particular, they can be useful for our future project on formalizing model theory. 

\end{itemize}



%\begin{figure}[htbp]
%\input{dependency.tex}
%\end{figure}le

\end{document}

% Local variables:
% mode: latex
% End:
